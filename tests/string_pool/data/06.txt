The
author
disclaims
copyright
to
this
source
code
In
place
of
May
you
do
good
and
not
evil
May
you
share
freely
never
taking
more
than
you
give
presents
to
client
programs
If
a
C
function
structure
datatype
not
a
published
API
of
SQLite
is
subject
to
change
without
Some
of
the
definitions
that
are
in
this
file
are
marked
as
features
recently
added
to
SQLite
We
do
not
anticipate
changes
if
experience
from
use
suggest
such
changes
are
prudent
The
official
C
language
API
documentation
for
SQLite
is
derived
on
how
SQLite
interfaces
are
supposed
to
operate
The
name
of
this
file
under
configuration
management
is
the
version
number
and
changes
its
name
to
as
ifndef
SQLITE3_H
define
SQLITE3_H
Make
sure
we
can
call
this
stuff
from
C
ifdef
__cplusplus
extern
endif
Facilitate
override
of
interface
linkage
and
calling
conventions
translation
of
the
amalgamation
and
its
associated
header
file
The
SQLITE_EXTERN
and
SQLITE_API
macros
are
used
to
instruct
the
The
SQLITE_CDECL
macro
is
used
to
set
the
calling
convention
for
The
SQLITE_APICALL
macro
is
used
to
set
the
calling
convention
for
The
SQLITE_STDCALL
macro
is
no
longer
used
and
is
now
deprecated
The
SQLITE_CALLBACK
macro
is
used
to
set
the
calling
convention
for
The
SQLITE_SYSAPI
macro
is
used
to
set
the
calling
convention
for
Currently
the
SQLITE_CDECL
SQLITE_APICALL
SQLITE_CALLBACK
and
that
require
non
default
calling
conventions
ifndef
SQLITE_EXTERN
define
SQLITE_EXTERN
extern
endif
ifndef
SQLITE_API
define
SQLITE_API
endif
ifndef
SQLITE_CDECL
define
SQLITE_CDECL
endif
ifndef
SQLITE_APICALL
define
SQLITE_APICALL
endif
ifndef
SQLITE_STDCALL
define
SQLITE_STDCALL
SQLITE_APICALL
endif
ifndef
SQLITE_CALLBACK
define
SQLITE_CALLBACK
endif
ifndef
SQLITE_SYSAPI
define
SQLITE_SYSAPI
endif
These
no
op
macros
are
used
in
front
of
interfaces
to
mark
those
should
not
use
deprecated
interfaces
they
are
supported
for
backwards
experimental
interfaces
are
subject
to
change
in
point
releases
These
macros
used
to
resolve
to
various
kinds
of
compiler
magic
that
compiler
magic
ended
up
generating
such
a
flurry
of
bug
reports
noop
macros
define
SQLITE_DEPRECATED
define
SQLITE_EXPERIMENTAL
Ensure
these
symbols
were
not
defined
by
some
previous
header
file
ifdef
SQLITE_VERSION
undef
SQLITE_VERSION
endif
ifdef
SQLITE_VERSION_NUMBER
undef
SQLITE_VERSION_NUMBER
endif
CAPI3REF
Compile
Time
Library
Version
Numbers
The
SQLITE_VERSION
C
preprocessor
macro
in
the
sqlite3
h
header
format
where
X
is
the
major
version
number
always
for
The
SQLITE_VERSION_NUMBER
C
preprocessor
macro
resolves
to
an
integer
numbers
used
in
SQLITE_VERSION
be
larger
than
the
release
from
which
it
is
derived
Either
Y
will
and
Z
will
be
reset
to
zero
Since
version
dateof
a
href
Fossil
configuration
management
a
string
which
identifies
a
particular
check
in
of
SQLite
string
contains
the
date
and
time
of
the
check
in
UTC
and
a
SHA1
been
edited
in
any
way
since
it
was
last
checked
in
then
the
last
See
also
sqlite3_libversion
sqlite_version
and
sqlite_source_id
define
SQLITE_VERSION
define
SQLITE_VERSION_NUMBER
VERSION
NUMBER
define
SQLITE_SOURCE_ID
CAPI3REF
Run
Time
Library
Version
Numbers
These
interfaces
provide
the
same
information
as
the
SQLITE_VERSION
but
are
associated
with
the
library
instead
of
the
header
file
Cautious
verify
that
values
returned
by
these
interfaces
match
the
macros
in
compiled
with
matching
library
and
header
files
blockquote
pre
assert
strncmp
sqlite3_sourceid
SQLITE_SOURCE_ID
re
lockquote
The
sqlite3_version
string
constant
contains
the
text
of
SQLITE_VERSION
to
the
sqlite3_version
string
constant
The
sqlite3_libversion
direct
access
to
string
constants
within
the
DLL
The
SQLITE_VERSION_NUMBER
The
sqlite3_sourceid
function
returns
SQLITE_SOURCE_ID
C
preprocessor
macro
Except
if
SQLite
is
built
of
the
hash
might
be
different
from
SQLITE_SOURCE_ID
See
also
sqlite_version
and
sqlite_source_id
SQLITE_EXTERN
const
char
sqlite3_version
const
char
sqlite3_libversion
void
const
char
sqlite3_sourceid
void
int
sqlite3_libversion_number
void
CAPI3REF
Run
Time
Library
Compilation
Options
Diagnostics
The
sqlite3_compileoption_used
function
returns
or
compile
time
The
SQLITE_
prefix
may
be
omitted
from
the
The
sqlite3_compileoption_get
function
allows
iterating
returning
the
N
th
compile
time
option
string
If
N
is
out
of
range
prefix
is
omitted
from
any
strings
returned
by
Support
for
the
diagnostic
functions
sqlite3_compileoption_used
SQLITE_OMIT_COMPILEOPTION_DIAGS
option
at
compile
time
See
also
SQL
functions
sqlite_compileoption_used
and
ifndef
SQLITE_OMIT_COMPILEOPTION_DIAGS
int
sqlite3_compileoption_used
const
char
zOptName
const
char
sqlite3_compileoption_get
int
N
else
define
sqlite3_compileoption_used
X
define
sqlite3_compileoption_get
X
void
endif
CAPI3REF
Test
To
See
If
The
Library
Is
Threadsafe
The
sqlite3_threadsafe
function
returns
zero
if
and
only
if
SQLITE_THREADSAFE
compile
time
option
being
set
to
SQLite
can
be
compiled
with
or
without
mutexes
When
are
enabled
and
SQLite
is
threadsafe
When
the
the
mutexes
are
omitted
Without
the
mutexes
it
is
not
safe
Enabling
mutexes
incurs
a
measurable
performance
penalty
the
mutexes
But
for
maximum
safety
mutexes
should
be
enabled
This
interface
can
be
used
by
an
application
to
make
sure
that
the
the
desired
setting
of
the
SQLITE_THREADSAFE
macro
This
interface
only
reports
on
the
compile
time
mutex
setting
SQLITE_THREADSAFE
or
then
mutexes
are
enabled
by
default
but
with
the
verbs
SQLITE_CONFIG_SINGLETHREAD
SQLITE_CONFIG_MULTITHREAD
sqlite3_threadsafe
function
shows
only
the
compile
time
setting
of
sqlite3_config
In
other
words
the
return
value
from
sqlite3_threadsafe
See
the
threading
mode
documentation
for
additional
information
int
sqlite3_threadsafe
void
CAPI3REF
Database
Connection
Handle
Each
open
SQLite
database
is
represented
by
a
pointer
to
an
instance
of
pointer
as
an
object
The
sqlite3_open
sqlite3_open16
and
and
sqlite3_close_v2
are
its
destructors
There
are
many
other
sqlite3_prepare_v2
sqlite3_create_function
and
sqlite3
object
typedef
struct
sqlite3
sqlite3
CAPI3REF
Bit
Integer
Types
Because
there
is
no
cross
platform
way
to
specify
bit
integer
types
The
sqlite3_int64
and
sqlite3_uint64
are
the
preferred
type
definitions
compatibility
only
The
sqlite3_int64
and
sqlite_int64
types
can
store
integer
values
sqlite3_uint64
and
sqlite_uint64
types
can
store
integer
values
ifdef
SQLITE_INT64_TYPE
typedef
SQLITE_INT64_TYPE
sqlite_int64
ifdef
SQLITE_UINT64_TYPE
typedef
SQLITE_UINT64_TYPE
sqlite_uint64
else
typedef
unsigned
SQLITE_INT64_TYPE
sqlite_uint64
endif
elif
defined
_MSC_VER
defined
__BORLANDC__
typedef
__int64
sqlite_int64
typedef
unsigned
__int64
sqlite_uint64
else
typedef
long
long
int
sqlite_int64
typedef
unsigned
long
long
int
sqlite_uint64
endif
typedef
sqlite_int64
sqlite3_int64
typedef
sqlite_uint64
sqlite3_uint64
If
compiling
for
a
processor
that
lacks
floating
point
support
ifdef
SQLITE_OMIT_FLOATING_POINT
define
double
sqlite3_int64
endif
CAPI3REF
Closing
A
Database
Connection
The
sqlite3_close
and
sqlite3_close_v2
routines
are
destructors
Calls
to
sqlite3_close
and
sqlite3_close_v2
return
SQLITE_OK
if
resources
are
deallocated
Ideally
applications
should
sqlite3_finalize
finalize
all
sqlite3_backup_finish
finish
all
sqlite3_backup
objects
associated
If
the
database
connection
is
associated
with
unfinalized
prepared
sqlite3_close
will
leave
the
database
connection
open
and
return
statements
unclosed
BLOB
handlers
and
r
unfinished
sqlite3_backups
connection
immediately
it
marks
the
database
connection
as
an
unusable
connection
after
all
prepared
statements
are
finalized
all
BLOB
handles
is
intended
for
use
with
host
languages
that
are
garbage
collected
and
If
an
sqlite3
object
is
destroyed
while
a
transaction
is
open
The
C
parameter
to
sqlite3_close
C
and
sqlite3_close_v2
C
pointer
or
an
sqlite3
object
pointer
obtained
sqlite3_open_v2
and
not
previously
closed
argument
is
a
harmless
no
op
int
sqlite3_close
sqlite3
int
sqlite3_close_v2
sqlite3
The
type
for
a
callback
function
compatibility
and
is
not
documented
typedef
int
sqlite3_callback
void
int
char
char
CAPI3REF
One
Step
Query
Execution
Interface
The
sqlite3_exec
interface
is
a
convenience
wrapper
around
that
allows
an
application
to
run
multiple
statements
of
SQL
The
sqlite3_exec
interface
runs
zero
or
more
UTF
encoded
in
the
context
of
the
database
connection
passed
in
as
its
st
sqlite3_exec
is
not
NULL
then
it
is
invoked
for
each
result
row
sqlite3_exec
is
relayed
through
to
the
st
argument
of
each
is
NULL
then
no
callback
is
ever
invoked
and
result
rows
are
If
an
error
occurs
while
evaluating
the
SQL
statements
passed
into
subsequent
statements
are
skipped
If
the
th
parameter
to
sqlite3_exec
from
sqlite3_malloc
and
passed
back
through
the
th
parameter
on
error
message
strings
returned
through
the
th
parameter
of
If
the
th
parameter
to
sqlite3_exec
is
not
NULL
and
no
errors
NULL
before
returning
If
an
sqlite3_exec
callback
returns
non
zero
the
sqlite3_exec
without
running
any
subsequent
SQL
statements
The
nd
argument
to
the
sqlite3_exec
callback
function
is
the
callback
is
an
array
of
pointers
to
strings
obtained
as
if
from
result
row
is
NULL
then
the
corresponding
string
pointer
for
the
sqlite3_exec
callback
is
an
array
of
pointers
to
strings
where
each
from
sqlite3_column_name
If
the
nd
parameter
to
sqlite3_exec
is
a
NULL
pointer
a
pointer
SQL
comments
then
no
SQL
statements
are
evaluated
and
the
database
Restrictions
ul
is
a
valid
and
open
database
connection
the
st
parameter
to
sqlite3_exec
while
sqlite3_exec
is
running
the
nd
parameter
of
sqlite3_exec
while
sqlite3_exec
is
running
int
sqlite3_exec
sqlite3
const
char
sql
int
callback
void
int
char
char
void
char
errmsg
CAPI3REF
Result
Codes
Many
SQLite
functions
return
an
integer
result
code
from
the
set
shown
New
error
codes
may
be
added
in
future
versions
of
SQLite
See
also
extended
result
code
definitions
define
SQLITE_OK
beginning
of
error
codes
define
SQLITE_ERROR
define
SQLITE_INTERNAL
define
SQLITE_PERM
define
SQLITE_ABORT
define
SQLITE_BUSY
define
SQLITE_LOCKED
define
SQLITE_NOMEM
define
SQLITE_READONLY
define
SQLITE_INTERRUPT
define
SQLITE_IOERR
define
SQLITE_CORRUPT
define
SQLITE_NOTFOUND
define
SQLITE_FULL
define
SQLITE_CANTOPEN
define
SQLITE_PROTOCOL
define
SQLITE_EMPTY
define
SQLITE_SCHEMA
define
SQLITE_TOOBIG
define
SQLITE_CONSTRAINT
define
SQLITE_MISMATCH
define
SQLITE_MISUSE
define
SQLITE_NOLFS
define
SQLITE_AUTH
define
SQLITE_FORMAT
define
SQLITE_RANGE
define
SQLITE_NOTADB
define
SQLITE_NOTICE
define
SQLITE_WARNING
define
SQLITE_ROW
define
SQLITE_DONE
end
of
error
codes
CAPI3REF
Extended
Result
Codes
In
its
default
configuration
SQLite
API
routines
return
one
of
integer
these
result
codes
are
too
coarse
grained
They
do
not
provide
as
address
this
newer
versions
of
SQLite
version
dateof
support
for
additional
result
codes
that
provide
more
detailed
information
on
a
per
database
connection
basis
using
the
the
most
recent
error
can
be
obtained
using
define
SQLITE_ERROR_MISSING_COLLSEQ
SQLITE_ERROR
define
SQLITE_ERROR_RETRY
SQLITE_ERROR
define
SQLITE_ERROR_SNAPSHOT
SQLITE_ERROR
define
SQLITE_IOERR_READ
SQLITE_IOERR
define
SQLITE_IOERR_SHORT_READ
SQLITE_IOERR
define
SQLITE_IOERR_WRITE
SQLITE_IOERR
define
SQLITE_IOERR_FSYNC
SQLITE_IOERR
define
SQLITE_IOERR_DIR_FSYNC
SQLITE_IOERR
define
SQLITE_IOERR_TRUNCATE
SQLITE_IOERR
define
SQLITE_IOERR_FSTAT
SQLITE_IOERR
define
SQLITE_IOERR_UNLOCK
SQLITE_IOERR
define
SQLITE_IOERR_RDLOCK
SQLITE_IOERR
define
SQLITE_IOERR_DELETE
SQLITE_IOERR
define
SQLITE_IOERR_BLOCKED
SQLITE_IOERR
define
SQLITE_IOERR_NOMEM
SQLITE_IOERR
define
SQLITE_IOERR_ACCESS
SQLITE_IOERR
define
SQLITE_IOERR_CHECKRESERVEDLOCK
SQLITE_IOERR
define
SQLITE_IOERR_LOCK
SQLITE_IOERR
define
SQLITE_IOERR_CLOSE
SQLITE_IOERR
define
SQLITE_IOERR_DIR_CLOSE
SQLITE_IOERR
define
SQLITE_IOERR_SHMOPEN
SQLITE_IOERR
define
SQLITE_IOERR_SHMSIZE
SQLITE_IOERR
define
SQLITE_IOERR_SHMLOCK
SQLITE_IOERR
define
SQLITE_IOERR_SHMMAP
SQLITE_IOERR
define
SQLITE_IOERR_SEEK
SQLITE_IOERR
define
SQLITE_IOERR_DELETE_NOENT
SQLITE_IOERR
define
SQLITE_IOERR_MMAP
SQLITE_IOERR
define
SQLITE_IOERR_GETTEMPPATH
SQLITE_IOERR
define
SQLITE_IOERR_CONVPATH
SQLITE_IOERR
define
SQLITE_IOERR_VNODE
SQLITE_IOERR
define
SQLITE_IOERR_AUTH
SQLITE_IOERR
define
SQLITE_IOERR_BEGIN_ATOMIC
SQLITE_IOERR
define
SQLITE_IOERR_COMMIT_ATOMIC
SQLITE_IOERR
define
SQLITE_IOERR_ROLLBACK_ATOMIC
SQLITE_IOERR
define
SQLITE_IOERR_DATA
SQLITE_IOERR
define
SQLITE_IOERR_CORRUPTFS
SQLITE_IOERR
define
SQLITE_LOCKED_SHAREDCACHE
SQLITE_LOCKED
define
SQLITE_LOCKED_VTAB
SQLITE_LOCKED
define
SQLITE_BUSY_RECOVERY
SQLITE_BUSY
define
SQLITE_BUSY_SNAPSHOT
SQLITE_BUSY
define
SQLITE_BUSY_TIMEOUT
SQLITE_BUSY
define
SQLITE_CANTOPEN_NOTEMPDIR
SQLITE_CANTOPEN
define
SQLITE_CANTOPEN_ISDIR
SQLITE_CANTOPEN
define
SQLITE_CANTOPEN_FULLPATH
SQLITE_CANTOPEN
define
SQLITE_CANTOPEN_CONVPATH
SQLITE_CANTOPEN
define
SQLITE_CANTOPEN_DIRTYWAL
SQLITE_CANTOPEN
define
SQLITE_CANTOPEN_SYMLINK
SQLITE_CANTOPEN
define
SQLITE_CORRUPT_VTAB
SQLITE_CORRUPT
define
SQLITE_CORRUPT_SEQUENCE
SQLITE_CORRUPT
define
SQLITE_CORRUPT_INDEX
SQLITE_CORRUPT
define
SQLITE_READONLY_RECOVERY
SQLITE_READONLY
define
SQLITE_READONLY_CANTLOCK
SQLITE_READONLY
define
SQLITE_READONLY_ROLLBACK
SQLITE_READONLY
define
SQLITE_READONLY_DBMOVED
SQLITE_READONLY
define
SQLITE_READONLY_CANTINIT
SQLITE_READONLY
define
SQLITE_READONLY_DIRECTORY
SQLITE_READONLY
define
SQLITE_ABORT_ROLLBACK
SQLITE_ABORT
define
SQLITE_CONSTRAINT_CHECK
SQLITE_CONSTRAINT
define
SQLITE_CONSTRAINT_COMMITHOOK
SQLITE_CONSTRAINT
define
SQLITE_CONSTRAINT_FOREIGNKEY
SQLITE_CONSTRAINT
define
SQLITE_CONSTRAINT_FUNCTION
SQLITE_CONSTRAINT
define
SQLITE_CONSTRAINT_NOTNULL
SQLITE_CONSTRAINT
define
SQLITE_CONSTRAINT_PRIMARYKEY
SQLITE_CONSTRAINT
define
SQLITE_CONSTRAINT_TRIGGER
SQLITE_CONSTRAINT
define
SQLITE_CONSTRAINT_UNIQUE
SQLITE_CONSTRAINT
define
SQLITE_CONSTRAINT_VTAB
SQLITE_CONSTRAINT
define
SQLITE_CONSTRAINT_ROWID
SQLITE_CONSTRAINT
define
SQLITE_CONSTRAINT_PINNED
SQLITE_CONSTRAINT
define
SQLITE_CONSTRAINT_DATATYPE
SQLITE_CONSTRAINT
define
SQLITE_NOTICE_RECOVER_WAL
SQLITE_NOTICE
define
SQLITE_NOTICE_RECOVER_ROLLBACK
SQLITE_NOTICE
define
SQLITE_WARNING_AUTOINDEX
SQLITE_WARNING
define
SQLITE_AUTH_USER
SQLITE_AUTH
define
SQLITE_OK_LOAD_PERMANENTLY
SQLITE_OK
define
SQLITE_OK_SYMLINK
SQLITE_OK
CAPI3REF
Flags
For
File
Open
Operations
These
bit
values
are
intended
for
use
in
the
in
the
th
parameter
to
the
sqlite3_vfs
xOpen
method
Only
those
flags
marked
as
may
be
The
other
flags
have
historically
been
ignored
by
sqlite3_open_v2
raised
if
any
of
the
disallowed
bits
are
passed
into
sqlite3_open_v2
Note
in
particular
that
passing
the
SQLITE_OPEN_EXCLUSIVE
flag
into
to
be
opened
using
O_EXCL
Passing
SQLITE_OPEN_EXCLUSIVE
into
error
in
future
versions
of
SQLite
define
SQLITE_OPEN_READONLY
x00000001
define
SQLITE_OPEN_READWRITE
x00000002
define
SQLITE_OPEN_CREATE
x00000004
define
SQLITE_OPEN_DELETEONCLOSE
x00000008
define
SQLITE_OPEN_EXCLUSIVE
x00000010
define
SQLITE_OPEN_AUTOPROXY
x00000020
define
SQLITE_OPEN_URI
x00000040
define
SQLITE_OPEN_MEMORY
x00000080
define
SQLITE_OPEN_MAIN_DB
x00000100
define
SQLITE_OPEN_TEMP_DB
x00000200
define
SQLITE_OPEN_TRANSIENT_DB
x00000400
define
SQLITE_OPEN_MAIN_JOURNAL
x00000800
define
SQLITE_OPEN_TEMP_JOURNAL
x00001000
define
SQLITE_OPEN_SUBJOURNAL
x00002000
define
SQLITE_OPEN_SUPER_JOURNAL
x00004000
define
SQLITE_OPEN_NOMUTEX
x00008000
define
SQLITE_OPEN_FULLMUTEX
x00010000
define
SQLITE_OPEN_SHAREDCACHE
x00020000
define
SQLITE_OPEN_PRIVATECACHE
x00040000
define
SQLITE_OPEN_WAL
x00080000
define
SQLITE_OPEN_NOFOLLOW
x01000000
define
SQLITE_OPEN_EXRESCODE
x02000000
Legacy
compatibility
define
SQLITE_OPEN_MASTER_JOURNAL
x00004000
CAPI3REF
Device
Characteristics
The
xDeviceCharacteristics
method
of
the
sqlite3_io_methods
bit
values
expressing
I
characteristics
of
the
mass
storage
refers
to
The
SQLITE_IOCAP_ATOMIC
property
means
that
all
writes
of
mean
that
writes
of
blocks
that
are
nnn
bytes
in
size
and
nnn
are
atomic
The
SQLITE_IOCAP_SAFE_APPEND
value
means
first
then
the
size
of
the
file
is
extended
never
the
other
information
is
written
to
disk
in
the
same
order
as
calls
after
reboot
following
a
crash
or
power
loss
the
only
bytes
in
a
and
that
adjacent
bytes
even
bytes
within
the
same
sector
are
flag
indicates
that
a
file
cannot
be
deleted
when
open
The
read
only
media
and
cannot
be
changed
even
by
processes
with
The
SQLITE_IOCAP_BATCH_ATOMIC
property
means
that
the
underlying
write
operations
are
bracketed
by
SQLITE_FCNTL_BEGIN_ATOMIC_WRITE
and
define
SQLITE_IOCAP_ATOMIC
x00000001
define
SQLITE_IOCAP_ATOMIC512
x00000002
define
SQLITE_IOCAP_ATOMIC1K
x00000004
define
SQLITE_IOCAP_ATOMIC2K
x00000008
define
SQLITE_IOCAP_ATOMIC4K
x00000010
define
SQLITE_IOCAP_ATOMIC8K
x00000020
define
SQLITE_IOCAP_ATOMIC16K
x00000040
define
SQLITE_IOCAP_ATOMIC32K
x00000080
define
SQLITE_IOCAP_ATOMIC64K
x00000100
define
SQLITE_IOCAP_SAFE_APPEND
x00000200
define
SQLITE_IOCAP_SEQUENTIAL
x00000400
define
SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN
x00000800
define
SQLITE_IOCAP_POWERSAFE_OVERWRITE
x00001000
define
SQLITE_IOCAP_IMMUTABLE
x00002000
define
SQLITE_IOCAP_BATCH_ATOMIC
x00004000
CAPI3REF
File
Locking
Levels
SQLite
uses
one
of
these
integer
values
as
the
second
of
an
sqlite3_io_methods
object
These
values
are
ordered
from
The
argument
to
xLock
is
always
SHARED
or
higher
The
argument
to
define
SQLITE_LOCK_NONE
define
SQLITE_LOCK_SHARED
define
SQLITE_LOCK_RESERVED
define
SQLITE_LOCK_PENDING
define
SQLITE_LOCK_EXCLUSIVE
CAPI3REF
Synchronization
Type
Flags
When
SQLite
invokes
the
xSync
method
of
an
these
integer
values
as
the
second
argument
When
the
SQLITE_SYNC_DATAONLY
flag
is
used
it
means
that
the
information
need
not
be
flushed
If
the
lower
four
bits
of
the
flag
If
the
lower
four
bits
equal
SQLITE_SYNC_FULL
that
means
Do
not
confuse
the
SQLITE_SYNC_NORMAL
and
SQLITE_SYNC_FULL
flags
settings
The
synchronous
pragma
determines
when
calls
to
the
The
SQLITE_SYNC_NORMAL
and
SQLITE_SYNC_FULL
flags
determine
how
only
make
a
difference
on
Mac
OSX
for
the
default
SQLite
code
between
SQLITE_SYNC_NORMAL
and
SQLITE_SYNC_FULL
but
among
the
cares
about
the
difference
define
SQLITE_SYNC_NORMAL
x00002
define
SQLITE_SYNC_FULL
x00003
define
SQLITE_SYNC_DATAONLY
x00010
CAPI3REF
OS
Interface
Open
File
Handle
An
sqlite3_file
object
represents
an
open
file
in
the
implementations
will
for
their
own
use
The
pMethods
entry
is
a
pointer
to
an
I
operations
on
the
open
file
typedef
struct
sqlite3_file
sqlite3_file
struct
sqlite3_file
const
struct
sqlite3_io_methods
pMethods
CAPI3REF
OS
Interface
File
Virtual
Methods
Object
Every
file
opened
by
the
sqlite3_vfs
xOpen
method
populates
an
sqlite3_file
object
with
a
pointer
to
an
instance
of
this
object
against
the
open
file
represented
by
the
sqlite3_file
object
If
the
sqlite3_vfs
xOpen
method
sets
the
sqlite3_file
pMethods
element
may
be
invoked
even
if
the
sqlite3_vfs
xOpen
reported
that
it
failed
The
is
for
the
sqlite3_vfs
xOpen
to
set
the
sqlite3_file
pMethods
element
The
flags
argument
to
xSync
may
be
one
of
SQLITE_SYNC_NORMAL
or
The
second
choice
is
a
Mac
OS
X
style
fullsync
The
SQLITE_SYNC_DATAONLY
and
not
its
inode
needs
to
be
synced
The
integer
values
to
xLock
and
xUnlock
are
one
of
li
SQLITE_LOCK_NONE
li
SQLITE_LOCK_RESERVED
li
SQLITE_LOCK_EXCLUSIVE
xLock
upgrades
the
database
file
lock
In
other
words
xLock
moves
the
xLock
is
always
on
of
SHARED
RESERVED
PENDING
or
EXCLUSIVE
never
requested
lock
then
the
call
to
xLock
is
a
no
op
If
the
lock
is
already
at
or
below
the
requested
lock
state
then
the
call
The
xCheckReservedLock
method
checks
whether
any
database
connection
PENDING
or
EXCLUSIVE
lock
on
the
file
It
returns
true
The
xFileControl
method
is
a
generic
interface
that
allows
custom
sqlite3_file_control
interface
The
second
argument
is
an
point
to
a
structure
that
may
contain
arguments
or
space
in
which
to
functions
to
enable
blocking
locks
with
timeouts
to
change
the
about
the
status
of
a
lock
or
to
break
stale
locks
The
SQLite
A
file
control
opcodes
list
of
opcodes
less
than
is
available
greater
than
to
avoid
conflicts
VFS
implementations
should
recognize
The
xSectorSize
method
returns
the
sector
size
of
the
minimum
write
that
can
be
performed
without
disturbing
method
returns
a
bit
vector
describing
behaviors
of
the
ul
li
SQLITE_IOCAP_ATOMIC512
li
SQLITE_IOCAP_ATOMIC2K
li
SQLITE_IOCAP_ATOMIC8K
li
SQLITE_IOCAP_ATOMIC32K
li
SQLITE_IOCAP_SAFE_APPEND
li
SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN
li
SQLITE_IOCAP_IMMUTABLE
l
The
SQLITE_IOCAP_ATOMIC
property
means
that
all
writes
of
mean
that
writes
of
blocks
that
are
nnn
bytes
in
size
and
nnn
are
atomic
The
SQLITE_IOCAP_SAFE_APPEND
value
means
first
then
the
size
of
the
file
is
extended
never
the
other
information
is
written
to
disk
in
the
same
order
as
calls
If
xRead
returns
SQLITE_IOERR_SHORT_READ
it
must
also
fill
fails
to
zero
fill
short
reads
might
seem
to
work
However
database
corruption
typedef
struct
sqlite3_io_methods
sqlite3_io_methods
struct
sqlite3_io_methods
int
iVersion
int
xClose
sqlite3_file
int
xRead
sqlite3_file
void
int
iAmt
sqlite3_int64
iOfst
int
xWrite
sqlite3_file
const
void
int
iAmt
sqlite3_int64
iOfst
int
xTruncate
sqlite3_file
sqlite3_int64
size
int
xSync
sqlite3_file
int
flags
int
xFileSize
sqlite3_file
sqlite3_int64
pSize
int
xLock
sqlite3_file
int
int
xUnlock
sqlite3_file
int
int
xCheckReservedLock
sqlite3_file
int
pResOut
int
xFileControl
sqlite3_file
int
op
void
pArg
int
xSectorSize
sqlite3_file
int
xDeviceCharacteristics
sqlite3_file
int
xShmMap
sqlite3_file
int
iPg
int
pgsz
int
void
volatile
int
xShmLock
sqlite3_file
int
offset
int
n
int
flags
void
xShmBarrier
sqlite3_file
int
xShmUnmap
sqlite3_file
int
deleteFlag
int
xFetch
sqlite3_file
sqlite3_int64
iOfst
int
iAmt
void
pp
int
xUnfetch
sqlite3_file
sqlite3_int64
iOfst
void
p
CAPI3REF
Standard
File
Control
Opcodes
These
integer
constants
are
opcodes
for
the
xFileControl
method
interface
ul
The
SQLITE_FCNTL_LOCKSTATE
opcode
is
used
for
debugging
This
the
lock
one
of
SQLITE_LOCK_NONE
SQLITE_LOCK_SHARED
into
an
integer
that
the
pArg
argument
points
to
li
SQLITE_FCNTL_SIZE_HINT
layer
a
hint
of
how
large
the
database
file
will
grow
to
be
during
the
is
often
close
The
underlying
VFS
might
choose
to
preallocate
database
file
run
faster
li
SQLITE_FCNTL_SIZE_LIMIT
implements
sqlite3_deserialize
to
set
an
upper
bound
on
the
size
If
the
integer
pointed
to
is
negative
then
it
is
filled
in
with
the
of
the
integer
pointed
to
and
the
current
database
size
The
integer
li
SQLITE_FCNTL_CHUNK_SIZE
extends
and
truncates
the
database
file
in
chunks
of
a
size
specified
point
to
an
integer
type
int
containing
the
new
chunk
size
to
use
chunks
say
MB
at
a
time
may
reduce
file
system
fragmentation
and
li
SQLITE_FCNTL_FILE_POINTER
to
the
sqlite3_file
object
associated
with
a
particular
database
li
SQLITE_FCNTL_JOURNAL_POINTER
to
the
sqlite3_file
object
associated
with
the
journal
file
either
connection
See
also
SQLITE_FCNTL_FILE_POINTER
li
SQLITE_FCNTL_SYNC_OMITTED
li
SQLITE_FCNTL_SYNC
sent
to
the
VFS
immediately
before
the
xSync
method
is
invoked
on
a
because
the
user
has
configured
SQLite
with
of
the
xSync
method
In
most
cases
the
pointer
argument
passed
with
as
part
of
a
multi
database
commit
the
argument
points
to
a
nul
terminated
do
not
need
this
signal
should
silently
ignore
this
opcode
Applications
disrupt
the
operation
of
the
specialized
VFSes
that
do
require
it
li
SQLITE_FCNTL_COMMIT_PHASETWO
and
sent
to
the
VFS
after
a
transaction
has
been
committed
immediately
should
silently
ignore
this
opcode
Applications
should
not
call
operation
of
the
specialized
VFSes
that
do
require
it
li
SQLITE_FCNTL_WIN32_AV_RETRY
retry
counts
and
intervals
for
certain
disk
I
operations
for
the
anti
virus
programs
By
default
the
windows
VFS
will
retry
file
read
of
milliseconds
before
the
first
retry
and
with
the
delay
increasing
opcode
allows
these
two
values
retries
and
milliseconds
of
delay
within
the
same
process
The
argument
is
a
pointer
to
an
array
of
two
integer
is
the
delay
If
either
integer
is
negative
then
the
setting
into
the
array
entry
allowing
the
current
retry
settings
to
be
li
SQLITE_FCNTL_PERSIST_WAL
persistent
WAL
Write
Ahead
Log
setting
By
default
the
auxiliary
files
used
for
transaction
control
closes
Setting
persistent
WAL
mode
causes
those
files
to
persist
after
have
write
permission
on
the
directory
containing
the
database
file
want
in
order
for
the
database
to
be
readable
The
fourth
parameter
to
That
integer
is
to
disable
persistent
WAL
mode
or
to
enable
persistent
WAL
persistence
setting
li
SQLITE_FCNTL_POWERSAFE_OVERWRITE
persistent
or
setting
The
PSOW
setting
xDeviceCharacteristics
methods
The
fourth
parameter
to
That
integer
is
to
disable
zero
damage
mode
or
to
enable
zero
damage
zero
damage
mode
setting
li
SQLITE_FCNTL_OVERWRITE
a
write
transaction
to
indicate
that
unless
it
is
rolled
back
for
some
transaction
This
is
used
by
VACUUM
operations
li
SQLITE_FCNTL_VFSNAME
all
VFSes
in
the
VFS
stack
The
names
are
of
all
VFS
shims
and
the
sqlite3_malloc
and
the
result
is
stored
in
the
char
variable
The
caller
is
responsible
for
freeing
the
memory
when
done
As
with
do
anything
Callers
should
initialize
the
char
variable
to
a
NULL
is
intended
for
diagnostic
use
only
li
SQLITE_FCNTL_VFS_POINTER
VFSes
currently
in
use
The
argument
X
in
of
type
This
opcodes
will
set
X
When
there
are
multiple
VFS
shims
in
the
stack
this
opcode
finds
the
li
SQLITE_FCNTL_PRAGMA
file
control
is
sent
to
the
open
sqlite3_file
object
corresponding
to
the
SQLITE_FCNTL_PRAGMA
file
control
is
an
array
of
is
the
name
of
the
pragma
and
the
third
element
is
the
argument
to
the
SQLITE_FCNTL_PRAGMA
file
control
can
optionally
make
the
first
element
or
the
equivalent
and
that
string
will
become
the
result
of
the
pragma
or
SQLITE_FCNTL_PRAGMA
file
control
returns
SQLITE_NOTFOUND
then
normal
file
control
returns
SQLITE_OK
then
the
parser
assumes
that
the
prepared
statement
if
result
string
is
NULL
or
that
returns
a
copy
If
the
SQLITE_FCNTL_PRAGMA
file
control
returns
that
the
VFS
encountered
an
error
while
handling
the
PRAGMA
and
the
file
control
occurs
at
the
beginning
of
pragma
statement
analysis
and
so
li
SQLITE_FCNTL_BUSYHANDLER
file
control
may
be
invoked
by
SQLite
on
the
database
file
handle
to
the
connection
s
busy
handler
callback
The
argument
is
of
type
void
to
a
function
of
type
int
void
In
order
to
invoke
the
connection
s
the
array
as
the
only
argument
If
it
returns
non
zero
then
the
operation
current
operation
li
SQLITE_FCNTL_TEMPFILENAME
to
have
SQLite
generate
a
temporary
filenames
for
TEMP
tables
and
other
internal
uses
The
written
into
memory
obtained
from
sqlite3_malloc
The
caller
should
li
SQLITE_FCNTL_MMAP_SIZE
maximum
number
of
bytes
that
will
be
used
for
memory
mapped
I
is
an
advisory
maximum
number
of
bytes
in
the
file
to
memory
map
The
the
value
originally
pointed
to
is
negative
and
so
the
current
limit
file
control
is
used
internally
to
implement
PRAGMA
mmap_size
li
SQLITE_FCNTL_TRACE
to
the
VFS
about
what
the
higher
layers
of
the
SQLite
stack
are
doing
The
argument
is
a
zero
terminated
string
Higher
layers
in
the
the
SQLITE_USE_FCNTL_TRACE
compile
time
option
is
enabled
li
SQLITE_FCNTL_HAS_MOVED
pointer
to
an
integer
and
it
writes
a
boolean
into
that
integer
depending
was
first
opened
li
SQLITE_FCNTL_WIN32_GET_HANDLE
underlying
native
file
handle
associated
with
a
file
handle
This
file
writes
the
resulting
value
there
li
SQLITE_FCNTL_WIN32_SET_HANDLE
opcode
causes
the
xFileControl
method
to
swap
the
file
handle
with
the
one
and
only
needs
to
be
supported
when
SQLITE_TEST
is
defined
li
SQLITE_FCNTL_WAL_BLOCK
be
advantageous
to
block
on
the
next
WAL
lock
if
the
lock
is
not
immediately
circumstances
in
order
to
fix
a
problem
with
priority
inversion
li
SQLITE_FCNTL_ZIPVFS
VFS
should
return
SQLITE_NOTFOUND
for
this
opcode
li
SQLITE_FCNTL_RBU
the
RBU
extension
only
All
other
VFS
should
return
SQLITE_NOTFOUND
for
li
SQLITE_FCNTL_BEGIN_ATOMIC_WRITE
the
file
descriptor
is
placed
in
which
atomically
at
the
next
SQLITE_FCNTL_COMMIT_ATOMIC_WRITE
Systems
Following
a
successful
SQLITE_FCNTL_BEGIN_ATOMIC_WRITE
and
prior
to
SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE
SQLite
will
make
except
for
calls
to
the
xWrite
method
and
the
xFileControl
method
li
SQLITE_FCNTL_COMMIT_ATOMIC_WRITE
operations
since
the
previous
successful
call
to
This
file
control
returns
SQLITE_OK
if
and
only
if
the
writes
were
Regardless
of
whether
or
not
it
is
successful
this
file
control
takes
write
operations
are
independent
a
prior
successful
call
to
SQLITE_FCNTL_BEGIN_ATOMIC_WRITE
li
SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE
operations
since
the
previous
successful
call
to
This
file
control
takes
the
file
descriptor
out
of
batch
write
mode
SQLite
will
never
invoke
SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE
without
li
SQLITE_FCNTL_LOCK_TIMEOUT
to
block
for
up
to
M
milliseconds
before
failing
when
attempting
to
The
parameter
is
a
pointer
to
a
bit
signed
integer
that
contains
integer
is
overwritten
with
the
previous
value
of
M
li
SQLITE_FCNTL_DATA_VERSION
a
database
file
The
argument
is
a
pointer
to
a
bit
unsigned
integer
changes
whenever
any
change
occurs
to
the
corresponding
connection
or
through
transactions
committed
by
separate
database
interface
can
be
used
to
find
if
any
database
on
the
connection
has
changed
not
provide
a
mechanism
to
detect
changes
to
MAIN
only
Also
the
omits
changes
made
by
other
database
connections
The
a
single
attached
database
that
occur
due
to
other
database
connections
called
This
file
control
is
the
only
mechanism
to
detect
changes
that
a
particular
attached
database
li
SQLITE_FCNTL_CKPT_START
in
wal
mode
before
the
client
starts
to
copy
pages
from
the
wal
li
SQLITE_FCNTL_CKPT_DONE
in
wal
mode
after
the
client
has
finished
copying
pages
from
the
wal
record
the
fact
that
the
pages
have
been
checkpointed
li
SQLITE_FCNTL_EXTERNAL_READER
whether
or
not
there
is
a
database
client
in
another
process
with
a
wal
mode
void
argument
passed
with
this
file
control
should
be
a
pointer
to
a
mode
database
and
there
exists
at
least
one
client
in
another
process
that
the
database
is
not
a
wal
mode
db
or
if
there
is
no
such
connection
in
any
by
clients
within
the
current
process
only
within
other
processes
li
SQLITE_FCNTL_CKSM_FILE
li
SQLITE_FCNTL_RESET_CACHE
database
is
not
a
temp
db
then
this
file
control
purges
the
contents
the
db
is
a
temp
db
it
is
a
no
op
not
an
error
define
SQLITE_FCNTL_LOCKSTATE
define
SQLITE_FCNTL_GET_LOCKPROXYFILE
define
SQLITE_FCNTL_SET_LOCKPROXYFILE
define
SQLITE_FCNTL_LAST_ERRNO
define
SQLITE_FCNTL_SIZE_HINT
define
SQLITE_FCNTL_CHUNK_SIZE
define
SQLITE_FCNTL_FILE_POINTER
define
SQLITE_FCNTL_SYNC_OMITTED
define
SQLITE_FCNTL_WIN32_AV_RETRY
define
SQLITE_FCNTL_PERSIST_WAL
define
SQLITE_FCNTL_OVERWRITE
define
SQLITE_FCNTL_VFSNAME
define
SQLITE_FCNTL_POWERSAFE_OVERWRITE
define
SQLITE_FCNTL_PRAGMA
define
SQLITE_FCNTL_BUSYHANDLER
define
SQLITE_FCNTL_TEMPFILENAME
define
SQLITE_FCNTL_MMAP_SIZE
define
SQLITE_FCNTL_TRACE
define
SQLITE_FCNTL_HAS_MOVED
define
SQLITE_FCNTL_SYNC
define
SQLITE_FCNTL_COMMIT_PHASETWO
define
SQLITE_FCNTL_WIN32_SET_HANDLE
define
SQLITE_FCNTL_WAL_BLOCK
define
SQLITE_FCNTL_ZIPVFS
define
SQLITE_FCNTL_RBU
define
SQLITE_FCNTL_VFS_POINTER
define
SQLITE_FCNTL_JOURNAL_POINTER
define
SQLITE_FCNTL_WIN32_GET_HANDLE
define
SQLITE_FCNTL_PDB
define
SQLITE_FCNTL_BEGIN_ATOMIC_WRITE
define
SQLITE_FCNTL_COMMIT_ATOMIC_WRITE
define
SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE
define
SQLITE_FCNTL_LOCK_TIMEOUT
define
SQLITE_FCNTL_DATA_VERSION
define
SQLITE_FCNTL_SIZE_LIMIT
define
SQLITE_FCNTL_CKPT_DONE
define
SQLITE_FCNTL_RESERVE_BYTES
define
SQLITE_FCNTL_CKPT_START
define
SQLITE_FCNTL_EXTERNAL_READER
define
SQLITE_FCNTL_CKSM_FILE
define
SQLITE_FCNTL_RESET_CACHE
define
SQLITE_GET_LOCKPROXYFILE
SQLITE_FCNTL_GET_LOCKPROXYFILE
define
SQLITE_SET_LOCKPROXYFILE
SQLITE_FCNTL_SET_LOCKPROXYFILE
define
SQLITE_LAST_ERRNO
SQLITE_FCNTL_LAST_ERRNO
CAPI3REF
Mutex
Handle
The
mutex
module
within
SQLite
defines
sqlite3_mutex
to
be
an
at
the
internal
representation
of
an
sqlite3_mutex
It
only
Mutexes
are
created
using
sqlite3_mutex_alloc
typedef
struct
sqlite3_mutex
sqlite3_mutex
CAPI3REF
Loadable
Extension
Thunk
A
pointer
to
the
opaque
sqlite3_api_routines
structure
is
passed
as
structure
must
be
typedefed
in
order
to
work
around
compiler
warnings
typedef
struct
sqlite3_api_routines
sqlite3_api_routines
CAPI3REF
File
Name
Type
sqlite3_filename
is
used
by
SQLite
to
pass
filenames
to
the
as
a
normal
nul
terminated
UTF
buffer
containing
the
filename
but
ul
li
sqlite3_filename_journal
li
sqlite3_uri_parameter
li
sqlite3_uri_int64
l
typedef
const
char
sqlite3_filename
CAPI3REF
OS
Interface
Object
An
instance
of
the
sqlite3_vfs
object
defines
the
interface
between
in
the
name
of
the
object
stands
for
See
The
VFS
interface
is
sometimes
extended
by
adding
new
methods
onto
is
incremented
The
iVersion
value
started
out
as
in
with
SQLite
version
on
dateof
and
then
increased
may
be
appended
to
the
sqlite3_vfs
object
and
the
iVersion
value
Note
that
due
to
an
oversight
the
structure
SQLite
version
to
version
on
dateof
The
szOsFile
field
is
the
size
of
the
subclassed
sqlite3_file
a
pathname
in
this
VFS
Registered
sqlite3_vfs
objects
are
kept
on
a
linked
list
formed
by
and
sqlite3_vfs_unregister
interfaces
manage
this
list
searches
the
list
Neither
the
application
code
nor
the
VFS
The
pNext
field
is
the
only
field
in
the
sqlite3_vfs
or
modify
this
field
while
holding
a
particular
static
mutex
object
once
the
object
has
been
registered
The
zName
field
holds
the
name
of
the
VFS
module
The
name
must
sqlite3_vfs
xOpen
is
either
a
NULL
pointer
or
string
obtained
If
a
suffix
is
added
to
the
zFilename
parameter
it
will
alphanumeric
and
r
characters
the
string
will
be
valid
and
unchanged
until
xClose
is
the
sqlite3_file
can
safely
store
a
pointer
to
the
If
the
zFilename
parameter
to
xOpen
is
a
NULL
pointer
then
xOpen
xFilename
parameter
is
NULL
it
will
also
be
the
case
that
the
The
flags
argument
to
xOpen
includes
all
bits
set
in
or
sqlite3_open16
is
used
then
flags
includes
at
least
If
xOpen
opens
a
file
read
only
then
it
sets
pOutFlags
to
SQLite
will
also
add
one
of
the
following
flags
to
the
xOpen
ul
li
SQLITE_OPEN_MAIN_JOURNAL
li
SQLITE_OPEN_TEMP_JOURNAL
li
SQLITE_OPEN_SUBJOURNAL
li
SQLITE_OPEN_WAL
The
file
I
implementation
can
use
the
object
type
flags
to
that
does
not
care
about
crash
recovery
or
rollback
might
make
also
be
no
ops
and
any
attempt
to
read
the
journal
would
return
file
will
be
doing
page
aligned
sector
reads
and
writes
in
a
random
SQLite
might
also
add
one
of
the
following
flags
to
the
xOpen
method
ul
li
SQLITE_OPEN_EXCLUSIVE
The
SQLITE_OPEN_DELETEONCLOSE
flag
means
the
file
should
be
will
be
set
for
TEMP
databases
and
their
journals
transient
The
SQLITE_OPEN_EXCLUSIVE
flag
is
always
used
in
conjunction
analogous
to
the
O_EXCL
and
O_CREAT
flags
of
the
POSIX
open
SQLITE_OPEN_CREATE
is
used
to
indicate
that
file
should
always
It
is
i
not
used
to
indicate
the
file
should
be
opened
At
least
szOsFile
bytes
of
memory
are
allocated
by
SQLite
argument
to
xOpen
The
xOpen
method
does
not
have
to
the
xOpen
method
must
set
the
sqlite3_file
pMethods
to
either
this
even
if
the
open
fails
SQLite
expects
that
the
sqlite3_file
pMethods
or
failure
of
the
xOpen
call
sqlite3_vfs
xAccess
to
test
for
the
existence
of
a
file
or
SQLITE_ACCESS_READWRITE
to
to
test
whether
a
file
is
at
least
readable
The
SQLITE_ACCESS_READ
VFSes
of
SQLite
The
file
is
named
by
the
second
argument
and
can
be
a
non
zero
error
code
if
there
is
an
I
error
or
if
the
name
of
is
returned
then
non
zero
or
zero
is
written
into
pResOut
to
indicate
SQLite
will
always
allocate
at
least
mxPathname
bytes
for
the
is
also
passed
as
a
parameter
to
both
methods
If
the
output
buffer
handled
as
a
fatal
error
by
SQLite
vfs
implementations
should
endeavor
The
xRandomness
xSleep
xCurrentTime
and
xCurrentTimeInt64
included
in
the
VFS
structure
for
completeness
of
good
quality
randomness
into
zOut
The
return
value
is
The
xSleep
method
causes
the
calling
thread
to
sleep
for
at
method
returns
a
Julian
Day
Number
for
the
current
date
and
time
as
The
xCurrentTimeInt64
method
returns
as
an
integer
the
Julian
a
hour
day
date
and
time
if
that
method
is
available
if
iVersion
is
or
to
xCurrentTime
if
xCurrentTimeInt64
is
unavailable
The
xSetSystemCall
xGetSystemCall
and
xNestSystemCall
interfaces
by
some
VFSes
to
facilitate
testing
of
the
VFS
code
By
overriding
simulate
faults
and
error
conditions
that
would
otherwise
be
difficult
varies
from
one
VFS
to
another
and
from
one
version
of
the
same
VFS
to
the
or
all
of
these
interfaces
to
be
NULL
or
for
their
behavior
to
change
any
of
these
methods
if
the
iVersion
of
the
VFS
is
less
than
typedef
struct
sqlite3_vfs
sqlite3_vfs
typedef
void
sqlite3_syscall_ptr
void
struct
sqlite3_vfs
int
iVersion
int
szOsFile
int
mxPathname
sqlite3_vfs
pNext
const
char
zName
void
pAppData
int
xOpen
sqlite3_vfs
sqlite3_filename
zName
sqlite3_file
int
flags
int
pOutFlags
int
xDelete
sqlite3_vfs
const
char
zName
int
syncDir
int
xAccess
sqlite3_vfs
const
char
zName
int
flags
int
pResOut
int
xFullPathname
sqlite3_vfs
const
char
zName
int
nOut
char
zOut
void
xDlOpen
sqlite3_vfs
const
char
zFilename
void
xDlError
sqlite3_vfs
int
nByte
char
zErrMsg
void
xDlSym
sqlite3_vfs
void
const
char
zSymbol
void
void
xDlClose
sqlite3_vfs
void
int
xRandomness
sqlite3_vfs
int
nByte
char
zOut
int
xSleep
sqlite3_vfs
int
microseconds
int
xCurrentTime
sqlite3_vfs
double
int
xGetLastError
sqlite3_vfs
int
char
The
methods
above
are
in
version
of
the
sqlite_vfs
object
definition
Those
that
follow
are
added
in
version
or
later
int
xCurrentTimeInt64
sqlite3_vfs
sqlite3_int64
The
methods
above
are
in
versions
and
of
the
sqlite_vfs
object
Those
below
are
for
version
and
greater
int
xSetSystemCall
sqlite3_vfs
const
char
zName
sqlite3_syscall_ptr
sqlite3_syscall_ptr
xGetSystemCall
sqlite3_vfs
const
char
zName
const
char
xNextSystemCall
sqlite3_vfs
const
char
zName
The
methods
above
are
in
versions
through
of
the
sqlite_vfs
object
New
fields
may
be
appended
in
future
versions
The
iVersion
value
will
increment
whenever
this
happens
CAPI3REF
Flags
for
the
xAccess
VFS
method
These
integer
constants
can
be
used
as
the
third
parameter
to
what
kind
of
permissions
the
xAccess
method
is
looking
for
simply
checks
whether
the
file
exists
checks
whether
the
named
directory
is
both
readable
and
writable
the
directory
temp_store_directory
pragma
though
this
could
change
in
a
future
With
SQLITE_ACCESS_READ
the
xAccess
method
currently
unused
though
it
might
be
used
in
a
future
release
of
define
SQLITE_ACCESS_EXISTS
define
SQLITE_ACCESS_READWRITE
define
SQLITE_ACCESS_READ
CAPI3REF
Flags
for
the
xShmLock
VFS
method
These
integer
constants
define
the
various
locking
operations
following
are
the
only
legal
combinations
of
flags
to
the
ul
li
SQLITE_SHM_LOCK
SQLITE_SHM_EXCLUSIVE
li
SQLITE_SHM_UNLOCK
SQLITE_SHM_EXCLUSIVE
When
unlocking
the
same
SHARED
or
EXCLUSIVE
flag
must
be
supplied
as
The
xShmLock
method
can
transition
between
unlocked
and
SHARED
or
and
EXCLUSIVE
define
SQLITE_SHM_UNLOCK
define
SQLITE_SHM_LOCK
define
SQLITE_SHM_SHARED
define
SQLITE_SHM_EXCLUSIVE
CAPI3REF
Maximum
xShmLock
index
The
xShmLock
method
on
sqlite3_io_methods
may
use
values
The
SQLite
core
will
never
attempt
to
acquire
or
release
a
define
SQLITE_SHM_NLOCK
CAPI3REF
Initialize
The
SQLite
Library
The
sqlite3_initialize
routine
initializes
the
deallocates
any
resources
that
were
allocated
by
sqlite3_initialize
shutdown
on
embedded
systems
Workstation
applications
using
A
call
to
sqlite3_initialize
is
an
call
if
it
is
the
process
or
if
it
is
the
first
time
sqlite3_initialize
is
invoked
of
sqlite3_initialize
does
any
initialization
All
other
calls
A
call
to
sqlite3_shutdown
is
an
call
if
it
is
the
first
an
effective
call
to
sqlite3_shutdown
does
any
deinitialization
The
sqlite3_initialize
interface
is
threadsafe
but
sqlite3_shutdown
single
thread
All
open
database
connections
must
be
closed
and
all
sqlite3_shutdown
Among
other
things
sqlite3_initialize
will
invoke
will
invoke
sqlite3_os_end
The
sqlite3_initialize
routine
returns
SQLITE_OK
on
success
the
library
perhaps
it
is
unable
to
allocate
a
needed
resource
such
The
sqlite3_initialize
routine
is
called
internally
by
many
other
invoke
sqlite3_initialize
directly
For
example
sqlite3_open
initialized
when
sqlite3_open
is
called
if
it
has
not
be
initialized
compile
time
option
then
the
automatic
calls
to
sqlite3_initialize
prior
to
using
any
other
SQLite
interface
For
maximum
portability
directly
prior
to
using
any
other
SQLite
interface
Future
releases
when
SQLite
is
compiled
with
SQLITE_OMIT_AUTOINIT
might
become
the
The
sqlite3_os_init
routine
does
operating
system
specific
routine
undoes
the
effect
of
sqlite3_os_init
Typical
tasks
of
static
resources
initialization
of
global
variables
a
default
configuration
using
sqlite3_config
The
application
should
never
invoke
either
sqlite3_os_init
sqlite3_initialize
and
sqlite3_shutdown
The
sqlite3_os_init
sqlite3_os_end
is
called
by
sqlite3_shutdown
Appropriate
are
built
into
SQLite
when
it
is
compiled
for
Unix
Windows
or
OS
using
the
SQLITE_OS_OTHER
compile
time
sqlite3_os_init
and
sqlite3_os_end
An
application
supplied
must
return
SQLITE_OK
on
success
and
some
other
error
code
upon
int
sqlite3_initialize
void
int
sqlite3_shutdown
void
int
sqlite3_os_init
void
int
sqlite3_os_end
void
CAPI3REF
Configuring
The
SQLite
Library
The
sqlite3_config
interface
is
used
to
make
global
configuration
the
application
The
default
configuration
is
recommended
for
most
provided
to
support
rare
applications
with
unusual
needs
b
The
sqlite3_config
interface
is
not
threadsafe
The
application
threads
while
sqlite3_config
is
running
The
sqlite3_config
interface
sqlite3_initialize
or
after
shutdown
by
sqlite3_shutdown
sqlite3_shutdown
then
it
will
return
SQLITE_MISUSE
implementation
of
an
application
defined
sqlite3_os_init
The
first
argument
to
sqlite3_config
is
an
integer
what
property
of
SQLite
is
to
be
configured
Subsequent
arguments
in
the
first
argument
When
a
configuration
option
is
set
sqlite3_config
returns
SQLITE_OK
then
this
routine
returns
a
non
zero
error
code
int
sqlite3_config
int
CAPI3REF
Configure
database
connections
The
sqlite3_db_config
interface
is
used
to
make
configuration
sqlite3_config
except
that
the
changes
apply
to
a
single
The
second
argument
to
sqlite3_db_config
D
V
is
the
that
indicates
what
aspect
of
the
database
connection
is
being
configured
Calls
to
sqlite3_db_config
return
SQLITE_OK
if
and
only
if
int
sqlite3_db_config
sqlite3
int
op
CAPI3REF
Memory
Allocation
Routines
An
instance
of
this
object
defines
the
interface
between
SQLite
This
object
is
used
in
only
one
place
in
the
SQLite
interface
sqlite3_config
when
the
configuration
option
is
By
creating
an
instance
of
this
object
during
configuration
an
application
can
specify
an
alternative
dynamic
memory
needs
Note
that
SQLite
comes
with
several
built
in
memory
allocators
and
that
this
object
is
only
useful
to
a
tiny
minority
of
applications
also
used
during
testing
of
SQLite
in
order
to
specify
an
alternative
order
to
verify
that
SQLite
recovers
gracefully
from
such
The
xMalloc
xRealloc
and
xFree
methods
must
work
like
the
SQLite
guarantees
that
the
second
argument
to
xSize
should
return
the
allocated
size
of
a
memory
allocation
is
always
at
least
as
big
as
the
requested
size
but
may
be
larger
The
xRoundup
method
returns
what
would
be
the
allocated
size
of
allocators
round
up
memory
allocations
at
least
to
the
next
multiple
Every
memory
allocation
request
coming
in
through
sqlite3_malloc
that
causes
the
corresponding
memory
allocation
to
fail
The
xInit
method
initializes
the
memory
allocator
For
example
structures
The
xShutdown
method
is
invoked
indirectly
by
by
xInit
The
pAppData
pointer
is
used
as
the
only
parameter
to
SQLite
holds
the
SQLITE_MUTEX_STATIC_MAIN
mutex
when
it
invokes
xShutdown
method
is
only
called
from
sqlite3_shutdown
so
it
does
holds
the
SQLITE_MUTEX_STATIC_MEM
mutex
as
long
as
the
it
is
by
default
and
so
the
methods
are
automatically
serialized
methods
must
be
threadsafe
or
else
make
their
own
arrangements
for
SQLite
will
never
invoke
xInit
more
than
once
without
an
intervening
typedef
struct
sqlite3_mem_methods
sqlite3_mem_methods
struct
sqlite3_mem_methods
void
xMalloc
int
void
xFree
void
void
xRealloc
void
int
int
xSize
void
int
xRoundup
int
int
xInit
void
void
xShutdown
void
void
pAppData
CAPI3REF
Configuration
Options
These
constants
are
the
available
integer
configuration
options
that
New
configuration
options
may
be
added
in
future
releases
of
SQLite
should
check
the
return
code
from
sqlite3_config
to
make
sure
that
non
zero
error
code
if
a
discontinued
or
unsupported
configuration
option
dl
dd
There
are
no
arguments
to
this
option
This
option
sets
the
all
mutexing
and
puts
SQLite
into
a
mode
where
it
can
only
be
used
the
SQLITE_THREADSAFE
SQLITE_THREADSAFE
compile
time
option
then
value
of
Single
thread
and
so
sqlite3_config
will
return
configuration
option
d
SQLITE_CONFIG_MULTITHREAD
dt
SQLITE_CONFIG_MULTITHREAD
t
threading
mode
to
Multi
thread
In
other
words
it
disables
The
application
is
responsible
for
serializing
access
to
are
enabled
so
that
SQLite
will
be
safe
to
use
in
a
multi
threaded
database
connection
at
the
same
time
If
SQLite
is
compiled
with
it
is
not
possible
to
set
the
Multi
thread
threading
mode
and
SQLITE_CONFIG_MULTITHREAD
configuration
option
d
SQLITE_CONFIG_SERIALIZED
dt
SQLITE_CONFIG_SERIALIZED
t
threading
mode
to
Serialized
In
other
words
this
option
enables
mutexes
on
database
connection
and
prepared
statement
objects
SQLITE_THREADSAFE
the
SQLite
library
will
itself
serialize
access
application
is
free
to
use
the
same
database
connection
or
the
If
SQLite
is
compiled
with
it
is
not
possible
to
set
the
Serialized
threading
mode
and
SQLITE_CONFIG_SERIALIZED
configuration
option
d
SQLITE_CONFIG_MALLOC
dt
SQLITE_CONFIG_MALLOC
t
a
pointer
to
an
instance
of
the
sqlite3_mem_methods
structure
alternative
low
level
memory
allocation
routines
to
be
used
in
place
of
its
own
private
copy
of
the
content
of
the
sqlite3_mem_methods
structure
SQLITE_CONFIG_GETMALLOC
dt
SQLITE_CONFIG_GETMALLOC
t
is
a
pointer
to
an
instance
of
the
sqlite3_mem_methods
structure
structure
is
filled
with
the
currently
defined
memory
allocation
routines
routines
with
a
wrapper
that
simulations
memory
allocation
failure
or
SQLITE_CONFIG_SMALL_MALLOC
dt
SQLITE_CONFIG_SMALL_MALLOC
t
type
int
interpreted
as
a
boolean
which
if
true
provides
a
hint
to
SQLite
will
run
faster
if
it
is
free
to
make
large
memory
allocations
guarantees
about
memory
fragmentation
that
are
possible
if
large
d
SQLITE_CONFIG_MEMSTATUS
dt
SQLITE_CONFIG_MEMSTATUS
t
interpreted
as
a
boolean
which
enables
or
disables
the
collection
of
disabled
the
following
SQLite
interfaces
become
non
operational
li
sqlite3_hard_heap_limit64
li
sqlite3_memory_highwater
li
sqlite3_status64
Memory
allocation
statistics
are
enabled
by
default
unless
SQLite
is
allocation
statistics
are
disabled
by
default
SQLITE_CONFIG_SCRATCH
dt
SQLITE_CONFIG_SCRATCH
t
d
SQLITE_CONFIG_PAGECACHE
dt
SQLITE_CONFIG_PAGECACHE
t
that
SQLite
can
use
for
the
database
page
cache
with
the
default
page
This
configuration
option
is
a
no
op
if
an
application
defined
page
There
are
three
arguments
to
SQLITE_CONFIG_PAGECACHE
A
pointer
to
and
the
number
of
cache
lines
N
a
power
of
two
between
and
plus
some
extra
bytes
for
each
can
be
determined
using
SQLITE_CONFIG_PCACHE_HDRSZ
for
the
sz
parameter
to
be
larger
than
necessary
The
pMem
aligned
block
of
memory
of
at
least
sz
N
bytes
otherwise
When
pMem
is
not
NULL
SQLite
will
strive
to
use
the
memory
provided
a
page
cache
line
is
larger
than
sz
bytes
or
if
all
of
the
pMem
buffer
If
pMem
is
NULL
and
N
is
non
zero
then
each
database
connection
from
sqlite3_malloc
sufficient
for
N
cache
lines
if
N
is
positive
or
page
cache
memory
is
needed
beyond
what
is
provided
by
the
initial
additional
cache
line
d
SQLITE_CONFIG_HEAP
dt
SQLITE_CONFIG_HEAP
t
that
SQLite
will
use
for
all
of
its
dynamic
memory
allocation
needs
The
SQLITE_CONFIG_HEAP
option
is
only
available
if
SQLite
is
compiled
SQLITE_ERROR
if
invoked
otherwise
An
byte
aligned
pointer
to
the
memory
If
the
first
pointer
the
memory
pointer
is
NULL
then
SQLite
reverts
undoing
any
prior
invocation
of
SQLITE_CONFIG_MALLOC
If
the
allocator
is
engaged
to
handle
all
of
SQLites
memory
allocation
needs
boundary
or
subsequent
behavior
of
SQLite
will
be
undefined
for
the
minimum
allocation
size
are
through
d
SQLITE_CONFIG_MUTEX
dt
SQLITE_CONFIG_MUTEX
t
pointer
to
an
instance
of
the
sqlite3_mutex_methods
structure
in
place
the
mutex
routines
built
into
SQLite
SQLite
makes
a
copy
of
sqlite3_config
returns
If
SQLite
is
compiled
with
the
entire
mutexing
subsystem
is
omitted
from
the
build
and
hence
calls
to
return
SQLITE_ERROR
d
SQLITE_CONFIG_GETMUTEX
dt
SQLITE_CONFIG_GETMUTEX
t
is
a
pointer
to
an
instance
of
the
sqlite3_mutex_methods
structure
The
structure
is
filled
with
the
currently
defined
mutex
routines
routines
with
a
wrapper
used
to
track
mutex
usage
for
performance
the
SQLITE_THREADSAFE
SQLITE_THREADSAFE
compile
time
option
then
sqlite3_config
with
the
SQLITE_CONFIG_GETMUTEX
configuration
option
will
SQLITE_CONFIG_LOOKASIDE
dt
SQLITE_CONFIG_LOOKASIDE
t
the
default
size
of
lookaside
memory
on
each
database
connection
size
of
each
lookaside
buffer
slot
and
the
second
is
the
number
of
sets
the
i
default
lookaside
size
The
SQLITE_DBCONFIG_LOOKASIDE
configuration
on
individual
connections
d
SQLITE_CONFIG_PCACHE2
dt
SQLITE_CONFIG_PCACHE2
t
a
pointer
to
an
sqlite3_pcache_methods2
object
This
object
specifies
SQLite
makes
a
copy
of
the
sqlite3_pcache_methods2
object
d
SQLITE_CONFIG_GETPCACHE2
dt
SQLITE_CONFIG_GETPCACHE2
t
is
a
pointer
to
an
sqlite3_pcache_methods2
object
SQLite
copies
of
SQLITE_CONFIG_LOG
dt
SQLITE_CONFIG_LOG
t
global
error
log
function
with
a
call
signature
of
void
void
int
const
char
invoked
by
sqlite3_log
to
process
each
logging
event
If
the
The
void
pointer
that
is
the
second
argument
to
SQLITE_CONFIG_LOG
is
function
whenever
that
function
is
invoked
The
second
parameter
to
sqlite3_log
call
and
is
intended
to
be
a
result
code
or
an
log
message
after
formatting
via
sqlite3_snprintf
supplied
by
the
application
must
not
invoke
any
SQLite
interface
function
must
be
threadsafe
d
SQLITE_CONFIG_URI
dt
SQLITE_CONFIG_URI
If
non
zero
then
URI
handling
is
globally
enabled
If
the
parameter
is
zero
enabled
all
filenames
passed
to
sqlite3_open
sqlite3_open_v2
specified
as
part
of
ATTACH
commands
are
interpreted
as
URIs
regardless
connection
is
opened
If
it
is
globally
disabled
filenames
are
database
connection
is
opened
By
default
URI
handling
is
globally
SQLITE_USE_URI
symbol
defined
SQLITE_CONFIG_COVERING_INDEX_SCAN
dt
SQLITE_CONFIG_COVERING_INDEX_SCAN
argument
which
is
interpreted
as
a
boolean
in
order
to
enable
or
disable
The
default
setting
is
determined
if
that
compile
time
option
is
omitted
is
because
some
incorrectly
coded
legacy
applications
might
malfunction
disable
the
optimization
allows
the
older
buggy
application
code
to
work
SQLITE_CONFIG_PCACHE
SQLITE_CONFIG_GETPCACHE
dd
These
options
are
obsolete
and
should
not
be
used
by
new
code
d
SQLITE_CONFIG_SQLLOG
dd
This
option
is
only
available
if
sqlite
is
compiled
with
the
be
a
pointer
to
a
function
of
type
void
void
sqlite3
const
char
int
in
three
separate
circumstances
identified
by
the
value
passed
as
the
passed
as
the
second
argument
has
just
been
opened
The
third
argument
fourth
parameter
is
then
the
SQL
statement
that
the
third
parameter
the
connection
being
passed
as
the
second
parameter
is
being
closed
The
configuration
option
can
be
seen
in
the
source
file
in
SQLITE_CONFIG_MMAP_SIZE
dd
SQLITE_CONFIG_MMAP_SIZE
takes
two
bit
integer
sqlite3_int64
values
PRAGMA
mmap_size
and
the
maximum
allowed
mmap
size
limit
either
the
PRAGMA
mmap_size
command
or
by
using
the
will
be
silently
truncated
if
necessary
so
that
it
does
not
exceed
the
SQLITE_MAX_MMAP_SIZE
compile
time
option
changed
to
its
compile
time
default
SQLITE_CONFIG_WIN32_HEAPSIZE
dd
The
SQLITE_CONFIG_WIN32_HEAPSIZE
option
is
only
available
if
SQLite
is
defined
SQLITE_CONFIG_WIN32_HEAPSIZE
takes
a
bit
unsigned
integer
value
SQLITE_CONFIG_PCACHE_HDRSZ
dd
The
SQLITE_CONFIG_PCACHE_HDRSZ
option
takes
a
single
parameter
which
bytes
per
page
required
for
each
page
in
SQLITE_CONFIG_PAGECACHE
target
platform
and
SQLite
version
SQLITE_CONFIG_PMASZ
dd
The
SQLITE_CONFIG_PMASZ
option
takes
a
single
parameter
which
sorter
to
that
integer
The
default
minimum
PMA
Size
is
set
by
the
to
help
with
sort
operations
when
multithreaded
sorting
to
be
sorted
exceeds
the
page
size
times
the
minimum
of
the
SQLITE_CONFIG_STMTJRNL_SPILL
dd
The
SQLITE_CONFIG_STMTJRNL_SPILL
option
takes
a
single
parameter
which
Statement
journals
are
held
in
memory
until
their
size
in
bytes
Or
if
the
threshold
is
statement
journals
are
always
held
Since
many
statement
journals
never
become
large
setting
the
spill
I
required
to
support
statement
rollback
SQLITE_STMTJRNL_SPILL
compile
time
option
SQLITE_CONFIG_SORTERREF_SIZE
dd
The
SQLITE_CONFIG_SORTERREF_SIZE
option
accepts
a
single
parameter
Usually
when
SQLite
uses
an
external
sort
to
order
records
according
sorted
records
However
if
SQLite
determines
based
on
the
declared
type
than
the
configured
sorter
reference
size
threshold
then
a
reference
from
the
database
as
records
are
returned
in
sorted
order
The
default
negative
value
for
this
option
restores
the
default
behaviour
SQLITE_ENABLE_SORTER_REFERENCES
compile
time
option
SQLITE_CONFIG_MEMDB_MAXSIZE
dd
The
SQLITE_CONFIG_MEMDB_MAXSIZE
option
accepts
a
single
parameter
database
created
using
sqlite3_deserialize
This
default
maximum
SQLITE_FCNTL_SIZE_LIMIT
sqlite3_file_control
file
control
If
this
by
the
SQLITE_MEMDB_DEFAULT_MAXSIZE
compile
time
option
If
that
l
define
SQLITE_CONFIG_SINGLETHREAD
define
SQLITE_CONFIG_MULTITHREAD
define
SQLITE_CONFIG_SERIALIZED
define
SQLITE_CONFIG_MALLOC
define
SQLITE_CONFIG_GETMALLOC
define
SQLITE_CONFIG_SCRATCH
define
SQLITE_CONFIG_PAGECACHE
define
SQLITE_CONFIG_HEAP
define
SQLITE_CONFIG_MEMSTATUS
define
SQLITE_CONFIG_MUTEX
define
SQLITE_CONFIG_GETMUTEX
previously
SQLITE_CONFIG_CHUNKALLOC
which
is
now
unused
define
SQLITE_CONFIG_LOOKASIDE
define
SQLITE_CONFIG_PCACHE
define
SQLITE_CONFIG_GETPCACHE
define
SQLITE_CONFIG_LOG
define
SQLITE_CONFIG_URI
define
SQLITE_CONFIG_PCACHE2
define
SQLITE_CONFIG_GETPCACHE2
define
SQLITE_CONFIG_COVERING_INDEX_SCAN
define
SQLITE_CONFIG_SQLLOG
define
SQLITE_CONFIG_MMAP_SIZE
define
SQLITE_CONFIG_WIN32_HEAPSIZE
define
SQLITE_CONFIG_PCACHE_HDRSZ
define
SQLITE_CONFIG_PMASZ
define
SQLITE_CONFIG_STMTJRNL_SPILL
define
SQLITE_CONFIG_SMALL_MALLOC
define
SQLITE_CONFIG_SORTERREF_SIZE
define
SQLITE_CONFIG_MEMDB_MAXSIZE
CAPI3REF
Database
Connection
Configuration
Options
These
constants
are
the
available
integer
configuration
options
that
New
configuration
options
may
be
added
in
future
releases
of
SQLite
should
check
the
return
code
from
sqlite3_db_config
to
make
sure
that
non
zero
error
code
if
a
discontinued
or
unsupported
configuration
option
dl
dt
SQLITE_DBCONFIG_LOOKASIDE
t
lookaside
memory
allocator
configuration
for
the
database
connection
pointer
to
a
memory
buffer
to
use
for
lookaside
memory
may
be
NULL
in
which
case
SQLite
will
allocate
the
size
of
each
lookaside
buffer
slot
The
third
argument
is
the
number
of
or
equal
to
the
product
of
the
second
and
third
arguments
The
buffer
SQLITE_DBCONFIG_LOOKASIDE
is
not
a
multiple
of
it
is
internally
configuration
for
a
database
connection
can
only
be
changed
when
that
when
the
returned
by
Any
attempt
to
change
the
lookaside
memory
configuration
when
lookaside
SQLITE_BUSY
d
SQLITE_DBCONFIG_ENABLE_FKEY
dd
This
option
is
used
to
enable
or
disable
the
enforcement
of
The
first
argument
is
an
integer
which
is
to
disable
FK
enforcement
unchanged
The
second
parameter
is
a
pointer
to
an
integer
into
which
following
this
call
The
second
parameter
may
be
a
NULL
pointer
in
SQLITE_DBCONFIG_ENABLE_TRIGGER
dd
This
option
is
used
to
enable
or
disable
CREATE
TRIGGER
triggers
The
first
argument
is
an
integer
which
is
to
disable
triggers
The
second
parameter
is
a
pointer
to
an
integer
into
which
following
this
call
The
second
parameter
may
be
a
NULL
pointer
in
p
Originally
this
option
disabled
all
triggers
However
since
this
option
is
off
So
in
other
words
this
option
now
only
disables
databases
d
SQLITE_DBCONFIG_ENABLE_VIEW
dd
This
option
is
used
to
enable
or
disable
CREATE
VIEW
views
The
first
argument
is
an
integer
which
is
to
disable
views
The
second
parameter
is
a
pointer
to
an
integer
into
which
following
this
call
The
second
parameter
may
be
a
NULL
pointer
in
p
Originally
this
option
disabled
all
views
However
since
this
option
is
off
So
in
other
words
this
option
now
only
disables
databases
d
SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER
dd
This
option
is
used
to
enable
or
disable
the
FTS3
full
text
search
engine
extension
The
first
argument
is
an
integer
which
is
to
disable
fts3_tokenizer
or
unchanged
is
written
or
to
indicate
whether
fts3_tokenizer
is
disabled
or
enabled
which
case
the
new
setting
is
not
reported
back
d
SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION
dd
This
option
is
used
to
enable
or
disable
the
sqlite3_load_extension
The
sqlite3_enable_load_extension
API
enables
or
disables
both
the
There
should
be
two
additional
arguments
enabled
and
the
SQL
function
remains
disabled
If
the
first
argument
to
If
the
first
argument
is
then
no
changes
are
made
to
state
of
either
the
The
second
parameter
is
a
pointer
to
an
integer
into
which
is
disabled
or
enabled
following
this
call
The
second
parameter
may
d
SQLITE_DBCONFIG_MAINDBNAME
dt
SQLITE_DBCONFIG_MAINDBNAME
t
schema
The
sole
argument
is
a
pointer
to
a
constant
UTF8
string
does
not
make
a
copy
of
the
new
main
schema
name
string
so
the
application
until
after
the
database
connection
closes
SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE
dd
Usually
when
a
database
in
wal
mode
is
closed
or
detached
from
a
connections
at
all
to
the
database
If
so
it
performs
a
checkpoint
override
this
behaviour
The
first
parameter
passed
to
this
operation
default
to
enable
them
and
negative
to
leave
the
setting
unchanged
into
which
is
written
or
to
indicate
whether
checkpoints
on
close
d
SQLITE_DBCONFIG_ENABLE_QPSG
dt
SQLITE_DBCONFIG_ENABLE_QPSG
t
the
query
planner
stability
guarantee
QPSG
When
the
QPSG
is
active
of
values
of
bound
parameters
The
QPSG
disables
some
query
optimizations
slower
But
the
QPSG
has
the
advantage
of
more
predictable
behavior
With
was
used
during
testing
in
the
lab
the
QPSG
positive
to
enable
QPSG
or
negative
to
leave
the
setting
is
written
or
to
indicate
whether
the
QPSG
is
disabled
or
enabled
d
SQLITE_DBCONFIG_TRIGGER_EQP
dt
SQLITE_DBCONFIG_TRIGGER_EQP
t
include
output
for
any
operations
performed
by
trigger
programs
This
behavior
The
first
parameter
passed
to
this
operation
is
an
integer
or
negative
to
leave
the
setting
unchanged
or
to
indicate
whether
output
for
triggers
has
been
disabled
if
d
SQLITE_DBCONFIG_RESET_DATABASE
dt
SQLITE_DBCONFIG_RESET_DATABASE
t
VACUUM
in
order
to
reset
a
database
back
to
an
empty
database
a
badly
corrupted
database
file
li
If
the
database
connection
is
newly
opened
make
sure
it
has
read
the
database
or
calling
sqlite3_table_column_metadata
ignoring
any
the
database
in
WAL
mode
after
the
reset
if
it
was
in
WAL
mode
before
li
sqlite3_db_config
db
SQLITE_DBCONFIG_RESET_DATABASE
li
sqlite3_db_config
db
SQLITE_DBCONFIG_RESET_DATABASE
Because
resetting
a
database
is
destructive
and
irreversible
the
ensure
that
it
does
not
happen
by
accident
SQLITE_DBCONFIG_DEFENSIVE
dt
SQLITE_DBCONFIG_DEFENSIVE
t
flag
for
a
database
connection
When
the
defensive
deliberately
corrupt
the
database
file
are
disabled
The
disabled
ul
li
The
PRAGMA
journal_mode
OFF
statement
li
Writes
to
the
sqlite_dbpage
virtual
table
l
SQLITE_DBCONFIG_WRITABLE_SCHEMA
dt
SQLITE_DBCONFIG_WRITABLE_SCHEMA
t
flag
This
has
the
same
effect
and
is
logically
equivalent
The
first
argument
to
this
setting
is
an
integer
which
is
to
disable
leave
the
setting
unchanged
The
second
parameter
is
a
pointer
to
an
is
enabled
or
disabled
following
this
call
SQLITE_DBCONFIG_LEGACY_ALTER_TABLE
dd
The
SQLITE_DBCONFIG_LEGACY_ALTER_TABLE
option
activates
or
deactivates
behaves
as
it
did
prior
to
version
See
the
additional
information
This
feature
can
also
be
turned
on
and
off
d
SQLITE_DBCONFIG_DQS_DML
dd
The
SQLITE_DBCONFIG_DQS_DML
option
activates
or
deactivates
only
that
is
DELETE
INSERT
SELECT
and
UPDATE
statements
The
compile
time
option
SQLITE_DBCONFIG_DQS_DDL
dd
The
SQLITE_DBCONFIG_DQS
option
activates
or
deactivates
such
as
CREATE
TABLE
and
CREATE
INDEX
The
compile
time
option
SQLITE_DBCONFIG_TRUSTED_SCHEMA
dd
The
SQLITE_DBCONFIG_TRUSTED_SCHEMA
option
tells
SQLite
to
When
the
SQLITE_DBCONFIG_TRUSTED_SCHEMA
option
is
disabled
SQLite
including
li
Prohibit
the
use
of
SQL
functions
inside
triggers
views
partial
indexes
or
generated
columns
li
Prohibit
the
use
of
virtual
tables
inside
of
triggers
or
views
l
all
applications
are
advised
to
turn
it
off
if
possible
This
setting
d
SQLITE_DBCONFIG_LEGACY_FILE_FORMAT
dd
The
SQLITE_DBCONFIG_LEGACY_FILE_FORMAT
option
activates
or
deactivates
created
database
file
to
have
a
schema
format
version
number
the
byte
means
that
the
resulting
database
file
will
be
readable
and
writable
by
newly
created
databases
are
generally
not
understandable
by
SQLite
versions
is
now
scarcely
any
need
to
generated
database
files
that
are
compatible
practical
use
but
is
provided
so
that
SQLite
can
continue
to
claim
the
the
VACUUM
command
will
fail
with
an
obscure
error
when
attempting
to
not
considered
a
bug
since
SQLite
versions
and
earlier
do
not
support
d
define
SQLITE_DBCONFIG_MAINDBNAME
define
SQLITE_DBCONFIG_LOOKASIDE
define
SQLITE_DBCONFIG_ENABLE_FKEY
define
SQLITE_DBCONFIG_ENABLE_TRIGGER
define
SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER
define
SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION
define
SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE
define
SQLITE_DBCONFIG_ENABLE_QPSG
define
SQLITE_DBCONFIG_TRIGGER_EQP
define
SQLITE_DBCONFIG_RESET_DATABASE
define
SQLITE_DBCONFIG_DEFENSIVE
define
SQLITE_DBCONFIG_WRITABLE_SCHEMA
define
SQLITE_DBCONFIG_LEGACY_ALTER_TABLE
define
SQLITE_DBCONFIG_DQS_DML
define
SQLITE_DBCONFIG_DQS_DDL
define
SQLITE_DBCONFIG_ENABLE_VIEW
define
SQLITE_DBCONFIG_LEGACY_FILE_FORMAT
define
SQLITE_DBCONFIG_TRUSTED_SCHEMA
define
SQLITE_DBCONFIG_MAX
CAPI3REF
Enable
Or
Disable
Extended
Result
Codes
The
sqlite3_extended_result_codes
routine
enables
or
disables
the
codes
are
disabled
by
default
for
historical
compatibility
int
sqlite3_extended_result_codes
sqlite3
int
onoff
CAPI3REF
Last
Insert
Rowid
Each
entry
in
most
SQLite
tables
except
for
WITHOUT
ROWID
tables
integer
key
called
the
ROWID
The
rowid
is
always
available
names
are
not
also
used
by
explicitly
declared
columns
If
is
another
alias
for
the
rowid
The
sqlite3_last_insert_rowid
D
interface
usually
returns
the
rowid
of
on
database
connection
D
Inserts
into
WITHOUT
ROWID
tables
are
not
on
the
database
connection
D
then
sqlite3_last_insert_rowid
D
returns
As
well
as
being
set
automatically
as
rows
are
inserted
into
database
sqlite3_set_last_insert_rowid
Some
virtual
table
implementations
may
INSERT
rows
into
rowid
tables
as
to
disk
In
this
case
subsequent
calls
to
this
function
return
the
rowid
unintuitive
results
Virtual
table
implementations
that
do
write
to
rowid
rowid
value
using
sqlite3_set_last_insert_rowid
before
returning
If
an
INSERT
occurs
within
a
trigger
then
this
routine
will
running
Once
the
trigger
program
ends
the
value
returned
An
INSERT
that
fails
due
to
a
constraint
violation
is
not
a
routine
Thus
INSERT
OR
FAIL
INSERT
OR
IGNORE
INSERT
OR
ROLLBACK
routine
when
their
insertion
fails
When
INSERT
OR
REPLACE
INSERT
continues
to
completion
after
deleting
rows
that
caused
the
return
value
of
this
interface
For
the
purposes
of
this
routine
an
INSERT
is
considered
to
This
function
is
accessible
to
SQL
statements
via
the
If
a
separate
thread
performs
a
new
INSERT
on
the
same
function
is
running
and
thus
changes
the
last
insert
rowid
unpredictable
and
might
not
equal
either
the
old
or
the
new
sqlite3_int64
sqlite3_last_insert_rowid
sqlite3
CAPI3REF
Set
the
Last
Insert
Rowid
value
The
sqlite3_set_last_insert_rowid
D
R
method
allows
the
application
to
without
inserting
a
row
into
the
database
void
sqlite3_set_last_insert_rowid
sqlite3
sqlite3_int64
CAPI3REF
Count
The
Number
Of
Rows
Modified
These
functions
return
the
number
of
rows
modified
inserted
or
statement
on
the
database
connection
specified
by
the
only
parameter
and
that
if
the
number
of
rows
modified
by
the
most
recent
INSERT
UPDATE
the
return
value
of
sqlite3_changes
is
undefined
Executing
any
other
Only
changes
made
directly
by
the
INSERT
UPDATE
or
DELETE
statement
are
foreign
key
actions
or
REPLACE
constraint
resolution
are
not
counted
Changes
to
a
view
that
are
intercepted
by
returned
by
sqlite3_changes
immediately
after
an
INSERT
UPDATE
or
tables
are
counted
Things
are
more
complicated
if
the
sqlite3_changes
function
is
program
uses
the
changes
SQL
function
or
if
some
other
callback
li
Before
entering
a
trigger
program
the
value
returned
by
has
finished
the
original
value
is
restored
li
Within
a
trigger
program
each
INSERT
UPDATE
and
DELETE
upon
completion
as
normal
Of
course
this
value
will
not
include
value
will
be
saved
and
restored
after
each
sub
trigger
has
run
by
the
first
INSERT
UPDATE
or
DELETE
statement
within
a
trigger
it
If
it
is
used
by
the
second
or
subsequent
such
statement
within
a
trigger
previous
INSERT
UPDATE
or
DELETE
statement
within
the
same
trigger
If
a
separate
thread
makes
changes
on
the
same
database
connection
is
unpredictable
and
not
meaningful
See
also
li
the
sqlite3_total_changes
interface
li
the
changes
SQL
function
l
int
sqlite3_changes
sqlite3
sqlite3_int64
sqlite3_changes64
sqlite3
CAPI3REF
Total
Number
Of
Rows
Modified
These
functions
return
the
total
number
of
rows
inserted
modified
or
since
the
database
connection
was
opened
including
those
executed
as
type
of
the
return
value
and
that
if
the
number
of
rows
modified
by
the
the
return
value
of
sqlite3_total_changes
is
undefined
Executing
sqlite3_total_changes
Changes
made
as
part
of
foreign
key
actions
are
included
in
the
not
Changes
to
a
view
that
are
intercepted
by
INSTEAD
OF
triggers
The
sqlite3_total_changes
D
interface
only
reports
the
number
connection
D
Any
changes
by
other
database
connections
are
ignored
connections
use
the
PRAGMA
data_version
command
or
the
while
sqlite3_total_changes
is
running
then
the
value
See
also
li
the
sqlite3_changes
interface
li
the
changes
SQL
function
li
the
SQLITE_FCNTL_DATA_VERSION
file
control
int
sqlite3_total_changes
sqlite3
sqlite3_int64
sqlite3_total_changes64
sqlite3
CAPI3REF
Interrupt
A
Long
Running
Query
This
function
causes
any
pending
database
operation
to
abort
and
called
in
response
to
a
user
action
such
as
pressing
immediately
It
is
safe
to
call
this
routine
from
a
thread
different
from
the
is
not
safe
to
call
this
routine
with
a
database
connection
that
If
an
SQL
operation
is
very
nearly
finished
at
the
time
when
to
be
interrupted
and
might
continue
to
completion
An
SQL
operation
that
is
interrupted
will
return
SQLITE_INTERRUPT
that
is
inside
an
explicit
transaction
then
the
entire
transaction
The
sqlite3_interrupt
D
call
is
in
effect
until
all
currently
running
that
are
started
after
the
sqlite3_interrupt
call
and
before
the
running
prior
to
the
sqlite3_interrupt
call
New
SQL
statements
not
effected
by
the
sqlite3_interrupt
SQL
statements
is
a
no
op
and
has
no
effect
on
SQL
statements
void
sqlite3_interrupt
sqlite3
CAPI3REF
Determine
If
An
SQL
Statement
Is
Complete
These
routines
are
useful
during
command
line
input
to
determine
if
the
if
additional
input
is
needed
before
sending
the
text
into
appears
to
be
a
complete
SQL
statement
A
statement
is
judged
to
be
well
formed
CREATE
TRIGGER
statement
Semicolons
that
are
embedded
within
independent
tokens
they
are
part
of
the
token
in
which
they
are
and
comments
that
follow
the
final
semicolon
are
ignored
These
routines
return
if
the
statement
is
incomplete
If
a
These
routines
do
not
parse
the
SQL
statements
thus
If
SQLite
has
not
been
initialized
using
sqlite3_initialize
prior
automatically
by
sqlite3_complete16
If
that
initialization
fails
regardless
of
whether
or
not
the
input
SQL
is
complete
The
input
to
sqlite3_complete
must
be
a
zero
terminated
The
input
to
sqlite3_complete16
must
be
a
zero
terminated
int
sqlite3_complete
const
char
sql
int
sqlite3_complete16
const
void
sql
CAPI3REF
Register
A
Callback
To
Handle
SQLITE_BUSY
Errors
METHOD
sqlite3
The
sqlite3_busy_handler
D
X
P
routine
sets
a
callback
function
X
an
attempt
is
made
to
access
a
database
table
associated
with
or
process
has
the
table
locked
sqlite3_busy_timeout
and
PRAGMA
busy_timeout
If
the
busy
callback
is
NULL
then
SQLITE_BUSY
is
not
NULL
then
the
callback
might
be
invoked
with
two
arguments
The
first
argument
to
the
busy
handler
is
a
copy
of
the
void
pointer
which
the
busy
handler
callback
is
the
number
of
times
that
the
busy
handler
has
busy
callback
returns
then
no
additional
attempts
are
made
to
to
the
application
is
made
to
access
the
database
and
the
cycle
repeats
The
presence
of
a
busy
handler
does
not
guarantee
that
it
will
be
invoked
handler
could
result
in
a
deadlock
it
will
go
ahead
and
return
SQLITE_BUSY
busy
handler
it
is
trying
to
promote
to
a
reserved
lock
and
to
promote
to
an
exclusive
lock
The
first
process
cannot
proceed
proceed
because
it
is
blocked
by
the
first
If
both
processes
SQLite
returns
SQLITE_BUSY
for
the
first
process
hoping
that
this
the
second
process
to
proceed
The
default
busy
callback
is
NULL
There
can
only
be
a
single
busy
handler
defined
for
each
previously
set
handler
Note
that
calling
sqlite3_busy_timeout
busy
handler
and
thus
clear
any
previously
set
busy
handler
The
busy
callback
should
not
take
any
actions
which
modify
the
the
busy
handler
is
not
reentrant
Any
such
actions
or
prepared
statement
that
invoked
the
busy
handler
int
sqlite3_busy_handler
sqlite3
int
void
int
void
CAPI3REF
Set
A
Busy
Timeout
This
routine
sets
a
sqlite3_busy_handler
busy
handler
that
sleeps
will
sleep
multiple
times
until
at
least
milliseconds
of
sleeping
the
handler
returns
which
causes
sqlite3_step
to
return
Calling
this
routine
with
an
argument
less
than
or
equal
to
zero
There
can
only
be
a
single
busy
handler
for
a
particular
was
defined
using
sqlite3_busy_handler
prior
to
calling
See
also
PRAGMA
busy_timeout
int
sqlite3_busy_timeout
sqlite3
int
ms
CAPI3REF
Convenience
Routines
For
Running
Queries
This
is
a
legacy
interface
that
is
preserved
for
backwards
compatibility
Definition
A
b
result
table
is
memory
data
structure
created
by
the
complete
query
results
from
one
or
more
queries
The
table
conceptually
has
a
number
of
rows
and
columns
But
numbers
are
obtained
separately
Let
N
be
the
number
of
rows
A
result
table
is
an
array
of
pointers
to
zero
terminated
UTF
strings
to
zero
terminated
strings
that
contain
the
names
of
the
columns
in
NULL
pointers
All
other
values
are
in
their
UTF
zero
terminated
A
result
table
might
consist
of
one
or
more
memory
allocations
A
result
table
should
be
deallocated
using
sqlite3_free_table
As
an
example
of
the
result
table
format
suppose
a
query
result
blockquote
pre
Bob
re
lockquote
There
are
two
columns
M
and
three
rows
N
Thus
the
in
an
array
named
azResult
Then
azResult
holds
this
content
blockquote
pre
azResult
azResult
azResult
azResult
The
sqlite3_get_table
function
evaluates
one
or
more
string
of
its
nd
parameter
and
returns
a
result
table
to
the
After
the
application
has
finished
with
the
result
from
sqlite3_get_table
release
the
memory
that
was
malloced
Because
of
the
way
the
function
must
not
try
to
call
sqlite3_free
directly
Only
The
sqlite3_get_table
interface
is
implemented
as
a
wrapper
around
to
any
internal
data
structures
of
SQLite
It
uses
only
the
public
wrapper
layer
outside
of
the
internal
sqlite3_exec
call
are
not
sqlite3_errmsg
int
sqlite3_get_table
sqlite3
db
const
char
zSql
char
pazResult
int
pnRow
int
pnColumn
char
pzErrmsg
void
sqlite3_free_table
char
result
CAPI3REF
Formatted
String
Printing
Functions
These
routines
are
work
alikes
of
the
family
of
functions
These
routines
understand
most
of
the
common
formatting
options
from
plus
some
additional
non
standard
formats
q
Q
w
and
z
The
sqlite3_mprintf
and
sqlite3_vmprintf
routines
write
their
The
strings
returned
by
these
two
routines
should
be
NULL
pointer
if
sqlite3_malloc64
is
unable
to
allocate
enough
The
sqlite3_snprintf
routine
is
similar
to
from
buffer
supplied
as
the
second
parameter
whose
size
is
given
by
first
two
parameters
is
reversed
from
snprintf
This
is
an
backwards
compatibility
Note
also
that
sqlite3_snprintf
characters
actually
written
into
the
buffer
We
admit
that
value
but
we
cannot
change
the
implementation
of
sqlite3_snprintf
As
long
as
the
buffer
size
is
greater
than
zero
sqlite3_snprintf
parameter
is
the
total
size
of
the
buffer
including
space
for
written
will
be
n
characters
The
sqlite3_vsnprintf
routine
is
a
varargs
version
of
sqlite3_snprintf
See
also
built
in
printf
printf
SQL
function
char
sqlite3_mprintf
const
char
char
sqlite3_vmprintf
const
char
va_list
char
sqlite3_snprintf
int
char
const
char
char
sqlite3_vsnprintf
int
char
const
char
va_list
CAPI3REF
Memory
Allocation
Subsystem
The
SQLite
core
uses
these
three
routines
for
all
of
its
own
does
not
include
operating
system
specific
VFS
implementation
The
The
sqlite3_malloc
routine
returns
a
pointer
to
a
block
If
sqlite3_malloc
is
unable
to
obtain
sufficient
free
sqlite3_malloc
is
zero
or
negative
then
sqlite3_malloc
returns
The
sqlite3_malloc64
N
routine
works
just
like
of
a
signed
bit
integer
Calling
sqlite3_free
with
a
pointer
previously
returned
that
it
might
be
reused
The
sqlite3_free
routine
is
to
sqlite3_free
is
harmless
After
being
freed
memory
memory
might
result
in
a
segmentation
fault
or
other
severe
error
might
result
if
sqlite3_free
is
called
with
a
non
NULL
pointer
that
The
sqlite3_realloc
X
N
interface
attempts
to
resize
a
If
the
X
parameter
to
sqlite3_realloc
X
N
sqlite3_malloc
N
negative
then
the
behavior
is
exactly
the
same
as
calling
sqlite3_realloc
X
N
returns
a
pointer
to
a
memory
allocation
If
M
is
the
size
of
the
prior
allocation
then
min
N
M
bytes
by
sqlite3_realloc
X
N
and
the
prior
allocation
is
freed
prior
allocation
is
not
freed
The
sqlite3_realloc64
X
N
interfaces
works
the
same
as
of
a
bit
signed
integer
If
X
is
a
memory
allocation
previously
obtained
from
sqlite3_malloc
sqlite3_msize
X
returns
the
size
of
that
memory
allocation
in
bytes
of
bytes
requested
when
X
was
allocated
If
X
is
a
NULL
pointer
then
the
beginning
of
memory
allocation
or
if
it
points
to
a
formerly
of
sqlite3_msize
X
is
undefined
and
possibly
harmful
The
memory
returned
by
sqlite3_malloc
sqlite3_realloc
is
always
aligned
to
at
least
an
byte
boundary
or
to
a
option
is
used
The
pointer
arguments
to
sqlite3_free
and
sqlite3_realloc
invocation
of
sqlite3_malloc
or
sqlite3_realloc
that
have
The
application
must
not
read
or
write
any
part
of
sqlite3_free
or
sqlite3_realloc
void
sqlite3_malloc
int
void
sqlite3_malloc64
sqlite3_uint64
void
sqlite3_realloc
void
int
void
sqlite3_realloc64
void
sqlite3_uint64
void
sqlite3_free
void
sqlite3_uint64
sqlite3_msize
void
CAPI3REF
Memory
Allocator
Statistics
SQLite
provides
these
two
interfaces
for
reporting
on
the
status
routines
which
form
the
built
in
memory
allocation
subsystem
The
sqlite3_memory_used
routine
returns
the
number
of
bytes
The
sqlite3_memory_highwater
routine
returns
the
maximum
was
last
reset
The
values
returned
by
sqlite3_memory_used
and
added
by
SQLite
in
its
implementation
of
sqlite3_malloc
routines
that
sqlite3_malloc
may
call
The
memory
high
water
mark
is
reset
to
the
current
value
of
sqlite3_memory_highwater
is
true
The
value
returned
prior
to
the
reset
sqlite3_int64
sqlite3_memory_used
void
sqlite3_int64
sqlite3_memory_highwater
int
resetFlag
CAPI3REF
Pseudo
Random
Number
Generator
SQLite
contains
a
high
quality
pseudo
random
number
generator
PRNG
used
to
already
uses
the
largest
possible
ROWID
The
PRNG
is
also
used
for
applications
to
access
the
same
PRNG
for
other
purposes
A
call
to
this
routine
stores
N
bytes
of
randomness
into
buffer
P
If
this
routine
has
not
been
previously
called
or
if
the
previous
seeded
using
randomness
obtained
from
the
xRandomness
method
of
If
the
previous
call
to
this
routine
had
an
N
of
or
more
and
a
internally
and
without
recourse
to
the
sqlite3_vfs
xRandomness
void
sqlite3_randomness
int
N
void
P
CAPI3REF
Compile
Time
Authorization
Callbacks
KEYWORDS
authorizer
callback
This
routine
registers
an
authorizer
callback
with
a
particular
The
authorizer
callback
is
invoked
as
SQL
statements
are
being
compiled
sqlite3_prepare_v3
sqlite3_prepare16
sqlite3_prepare16_v2
points
during
the
compilation
process
as
logic
is
being
created
see
if
those
actions
are
allowed
The
authorizer
callback
should
specific
action
but
allow
the
SQL
statement
to
continue
to
be
rejected
with
an
error
If
the
authorizer
callback
returns
then
the
sqlite3_prepare_v2
or
equivalent
call
that
triggered
When
the
callback
returns
SQLITE_OK
that
means
the
operation
sqlite3_prepare_v2
or
equivalent
call
that
triggered
the
access
is
denied
The
first
parameter
to
the
authorizer
callback
is
a
copy
of
the
third
to
the
callback
is
an
integer
SQLITE_COPY
action
code
that
specifies
to
the
callback
are
either
NULL
pointers
or
zero
terminated
strings
Applications
must
always
be
prepared
to
encounter
a
NULL
pointer
in
any
If
the
action
code
is
SQLITE_READ
prepared
statement
statement
is
constructed
to
substitute
been
read
if
SQLITE_OK
had
been
returned
The
SQLITE_IGNORE
columns
of
a
table
extracted
from
that
table
for
example
in
a
query
like
is
invoked
once
for
that
table
with
a
column
name
that
is
an
empty
string
SQLITE_IGNORE
then
the
DELETE
operation
proceeds
but
the
An
authorizer
is
used
when
sqlite3_prepare
preparing
do
not
try
to
access
data
they
are
not
allowed
to
see
or
that
they
do
not
example
an
application
may
allow
a
user
to
enter
arbitrary
not
want
the
user
to
be
able
to
make
arbitrary
changes
to
the
user
entered
SQL
is
being
sqlite3_prepare
prepared
that
Applications
that
need
to
process
SQL
from
untrusted
sources
and
limiting
database
size
using
the
max_page_count
PRAGMA
Only
a
single
authorizer
can
be
in
place
on
a
database
connection
previous
call
Disable
the
authorizer
by
installing
a
NULL
callback
The
authorizer
callback
must
not
do
anything
that
will
modify
Note
that
sqlite3_prepare_v2
and
sqlite3_step
both
modify
their
When
sqlite3_prepare_v2
is
used
to
prepare
a
statement
the
schema
change
Hence
the
application
should
ensure
that
the
Note
that
the
authorizer
callback
is
invoked
only
during
performed
during
statement
evaluation
in
sqlite3_step
unless
sqlite3_prepare_v2
to
reprepare
a
statement
after
a
schema
change
int
sqlite3_set_authorizer
sqlite3
int
xAuth
void
int
const
char
const
char
const
char
const
char
void
pUserData
CAPI3REF
Authorizer
Return
Codes
The
sqlite3_set_authorizer
authorizer
callback
function
must
to
signal
SQLite
whether
or
not
the
action
is
permitted
See
the
information
Note
that
SQLITE_IGNORE
is
also
used
as
a
conflict
resolution
mode
define
SQLITE_DENY
define
SQLITE_IGNORE
CAPI3REF
Authorizer
Action
Codes
The
sqlite3_set_authorizer
interface
registers
a
callback
function
second
parameter
to
the
callback
is
an
integer
code
that
specifies
the
authorizer
callback
may
be
passed
These
action
code
values
signify
what
kind
of
operation
is
to
be
callback
function
will
be
parameters
or
NULL
depending
on
which
of
these
authorizer
callback
is
the
name
of
the
database
is
the
name
of
the
inner
most
trigger
or
view
that
is
responsible
for
top
level
SQL
code
define
SQLITE_CREATE_INDEX
define
SQLITE_CREATE_TABLE
define
SQLITE_CREATE_TEMP_INDEX
define
SQLITE_CREATE_TEMP_TABLE
define
SQLITE_CREATE_TEMP_TRIGGER
define
SQLITE_CREATE_TEMP_VIEW
define
SQLITE_CREATE_TRIGGER
define
SQLITE_CREATE_VIEW
define
SQLITE_DELETE
define
SQLITE_DROP_INDEX
define
SQLITE_DROP_TABLE
define
SQLITE_DROP_TEMP_INDEX
define
SQLITE_DROP_TEMP_TABLE
define
SQLITE_DROP_TEMP_TRIGGER
define
SQLITE_DROP_TEMP_VIEW
define
SQLITE_DROP_TRIGGER
define
SQLITE_DROP_VIEW
define
SQLITE_INSERT
define
SQLITE_PRAGMA
define
SQLITE_READ
define
SQLITE_SELECT
define
SQLITE_TRANSACTION
define
SQLITE_UPDATE
define
SQLITE_ATTACH
define
SQLITE_DETACH
define
SQLITE_ALTER_TABLE
define
SQLITE_REINDEX
define
SQLITE_ANALYZE
define
SQLITE_CREATE_VTABLE
define
SQLITE_DROP_VTABLE
define
SQLITE_FUNCTION
define
SQLITE_SAVEPOINT
define
SQLITE_COPY
define
SQLITE_RECURSIVE
CAPI3REF
Tracing
And
Profiling
Functions
These
routines
are
deprecated
Use
the
sqlite3_trace_v2
interface
These
routines
register
callback
functions
that
can
be
used
for
The
callback
function
registered
by
sqlite3_trace
is
invoked
at
The
sqlite3_trace
callback
is
invoked
with
a
UTF
rendering
of
the
Additional
sqlite3_trace
callbacks
might
occur
contain
a
UTF
SQL
comment
that
identifies
the
trigger
The
SQLITE_TRACE_SIZE_LIMIT
compile
time
option
can
be
used
to
limit
The
callback
function
registered
by
sqlite3_profile
is
invoked
the
original
statement
text
and
an
estimate
of
wall
clock
time
time
is
in
units
of
nanoseconds
however
the
current
implementation
digits
in
the
time
are
meaningless
Future
versions
of
SQLite
either
sqlite3_trace
or
sqlite3_trace_v2
will
cancel
the
SQLITE_DEPRECATED
void
sqlite3_trace
sqlite3
void
xTrace
void
const
char
void
SQLITE_DEPRECATED
void
sqlite3_profile
sqlite3
void
xProfile
void
const
char
sqlite3_uint64
void
CAPI3REF
SQL
Trace
Event
Codes
These
constants
identify
classes
of
events
that
can
be
monitored
to
sqlite3_trace_v2
D
M
X
P
is
an
OR
ed
combination
of
one
or
more
of
is
one
of
the
following
constants
New
tracing
constants
may
be
added
in
future
releases
A
trace
callback
has
four
arguments
xCallback
T
C
P
X
The
C
argument
is
a
copy
of
the
context
pointer
passed
in
as
the
The
P
and
X
arguments
are
pointers
whose
meanings
depend
on
T
dl
dd
An
SQLITE_TRACE_STMT
callback
is
invoked
when
a
prepared
statement
execution
of
the
prepared
statement
such
as
at
the
start
of
each
prepared
statement
The
X
argument
is
a
pointer
to
a
string
which
that
indicates
the
invocation
of
a
trigger
The
callback
can
compute
interface
by
using
the
X
argument
when
X
begins
with
and
invoking
SQLITE_TRACE_PROFILE
dt
SQLITE_TRACE_PROFILE
t
information
as
is
provided
by
the
sqlite3_profile
callback
X
argument
points
to
a
bit
integer
which
is
the
estimated
of
The
SQLITE_TRACE_PROFILE
callback
is
invoked
when
the
statement
finishes
SQLITE_TRACE_ROW
dt
SQLITE_TRACE_ROW
t
statement
generates
a
single
row
of
result
X
argument
is
unused
SQLITE_TRACE_CLOSE
dt
SQLITE_TRACE_CLOSE
t
connection
closes
and
the
X
argument
is
unused
define
SQLITE_TRACE_STMT
x01
define
SQLITE_TRACE_PROFILE
x02
define
SQLITE_TRACE_ROW
x04
define
SQLITE_TRACE_CLOSE
x08
CAPI3REF
SQL
Trace
Hook
The
sqlite3_trace_v2
D
M
X
P
interface
registers
a
trace
callback
and
context
pointer
P
If
the
X
callback
is
M
argument
should
be
the
bitwise
OR
ed
combination
of
Each
call
to
either
sqlite3_trace
or
sqlite3_trace_v2
overrides
The
X
callback
is
invoked
whenever
any
of
the
events
identified
by
ignored
though
this
may
change
in
future
releases
Callback
A
trace
callback
is
invoked
with
four
arguments
callback
T
C
P
X
constants
to
indicate
why
the
callback
was
invoked
The
P
and
X
arguments
are
pointers
whose
meanings
depend
on
T
The
sqlite3_trace_v2
interface
is
intended
to
replace
the
legacy
are
deprecated
int
sqlite3_trace_v2
sqlite3
unsigned
uMask
int
xCallback
unsigned
void
void
void
void
pCtx
CAPI3REF
Query
Progress
Callbacks
The
sqlite3_progress_handler
D
N
X
P
interface
causes
the
callback
sqlite3_exec
sqlite3_step
and
sqlite3_get_table
for
interface
is
to
keep
a
GUI
updated
during
a
large
query
The
parameter
P
is
passed
through
as
the
only
parameter
to
the
virtual
machine
instructions
that
are
evaluated
between
successive
handler
is
disabled
Only
a
single
progress
handler
may
be
defined
at
one
time
per
old
one
Setting
parameter
X
to
NULL
disables
the
progress
handler
than
If
the
progress
callback
returns
non
zero
the
operation
is
button
on
a
GUI
progress
dialog
box
The
progress
handler
callback
must
not
do
anything
that
will
modify
Note
that
sqlite3_prepare_v2
and
sqlite3_step
both
modify
their
void
sqlite3_progress_handler
sqlite3
int
int
void
void
CAPI3REF
Opening
A
New
Database
Connection
These
routines
open
an
SQLite
database
file
as
specified
by
the
sqlite3_open
and
sqlite3_open_v2
and
as
UTF
in
the
native
byte
returned
in
ppDb
even
if
an
error
occurs
The
only
exception
is
that
a
NULL
will
be
written
into
ppDb
instead
of
a
pointer
to
the
sqlite3
SQLITE_OK
is
returned
Otherwise
an
error
code
is
returned
The
an
English
language
description
of
the
error
following
a
failure
of
any
The
default
encoding
will
be
UTF
for
databases
created
using
created
using
sqlite3_open16
will
be
UTF
in
the
native
byte
order
Whether
or
not
an
error
occurs
when
it
is
opened
resources
passing
it
to
sqlite3_close
when
it
is
no
longer
required
The
sqlite3_open_v2
interface
works
like
sqlite3_open
over
the
new
database
connection
The
flags
parameter
to
three
flag
combinations
dl
dd
The
database
is
opened
in
read
only
mode
If
the
database
does
not
dt
SQLITE_OPEN_READWRITE
t
only
if
the
file
is
write
protected
by
the
operating
system
In
either
dt
SQLITE_OPEN_READWRITE
SQLITE_OPEN_CREATE
t
it
does
not
already
exist
This
is
the
behavior
that
is
always
used
for
l
In
addition
to
the
required
flags
the
following
optional
flags
are
dl
dd
The
filename
can
be
interpreted
as
a
URI
if
this
flag
is
set
d
dt
SQLITE_OPEN_MEMORY
t
is
named
by
the
argument
for
the
purposes
of
cache
sharing
d
dt
SQLITE_OPEN_NOMUTEX
t
threading
mode
This
means
that
separate
threads
are
allowed
a
different
database
connection
dt
SQLITE_OPEN_FULLMUTEX
t
threading
mode
This
means
the
multiple
threads
can
safely
Mutexes
will
block
any
actual
concurrency
but
in
this
mode
dt
SQLITE_OPEN_SHAREDCACHE
t
the
default
shared
cache
setting
provided
by
The
use
of
shared
cache
mode
is
discouraged
and
hence
shared
cache
this
option
is
a
no
op
dt
SQLITE_OPEN_PRIVATECACHE
t
the
default
shared
cache
setting
provided
by
OPEN_EXRESCODE
dt
SQLITE_OPEN_EXRESCODE
t
In
other
words
the
database
behaves
has
if
connection
as
soon
as
the
connection
is
created
In
addition
to
setting
to
return
an
extended
result
code
d
OPEN_NOFOLLOW
dt
SQLITE_OPEN_NOFOLLOW
t
l
If
the
rd
parameter
to
sqlite3_open_v2
is
not
one
of
the
SQLITE_OPEN_READONLY
SQLITE_OPEN_
bits
have
silently
ignored
surplus
bits
in
the
flags
parameter
to
into
future
versions
of
SQLite
and
so
applications
should
not
rely
for
sqlite3_open_v2
The
SQLITE_OPEN_EXCLUSIVE
does
not
cause
flag
is
intended
for
use
by
the
sqlite3_vfs
VFS
interface
only
and
not
The
fourth
parameter
to
sqlite3_open_v2
is
the
name
of
the
the
new
database
connection
should
use
If
the
fourth
parameter
is
If
the
filename
is
then
a
private
temporary
in
memory
database
the
database
connection
is
closed
Future
versions
of
SQLite
might
It
is
recommended
that
when
a
database
filename
actually
does
begin
with
to
avoid
ambiguity
If
the
filename
is
an
empty
string
then
a
private
temporary
automatically
deleted
as
soon
as
the
database
connection
is
closed
URI
filenames
in
sqlite3_open
h3
URI
Filenames
If
URI
filename
interpretation
is
enabled
and
the
filename
argument
filename
interpretation
is
enabled
if
the
SQLITE_OPEN_URI
flag
is
been
enabled
globally
using
the
SQLITE_CONFIG_URI
option
with
the
URI
filename
interpretation
is
turned
off
interpretation
by
default
See
for
additional
URI
filenames
are
parsed
according
to
RFC
If
the
URI
contains
an
If
the
authority
is
not
an
empty
string
or
an
present
is
ignored
SQLite
uses
the
path
component
of
the
URI
as
the
name
of
the
disk
file
then
it
is
interpreted
as
an
absolute
path
If
the
path
does
not
begin
then
the
path
is
interpreted
as
a
relative
path
is
a
drive
specification
e
g
core
URI
query
parameters
either
by
SQLite
itself
or
by
a
VFS
custom
VFS
implementation
following
query
parameters
ul
a
VFS
object
that
provides
the
operating
system
interface
that
should
an
empty
string
the
default
VFS
object
is
used
Specifying
an
unknown
present
then
the
VFS
specified
by
the
option
takes
precedence
over
li
b
mode
The
mode
parameter
may
be
set
to
either
an
error
access
just
as
if
the
SQLITE_OPEN_READONLY
flag
had
been
set
in
the
then
the
database
is
opened
for
read
write
but
not
create
been
set
Value
is
equivalent
to
setting
both
set
to
then
a
pure
in
memory
database
that
never
reads
the
mode
parameter
that
is
less
restrictive
than
that
specified
by
li
b
cache
The
cache
parameter
may
be
set
to
either
or
SQLITE_OPEN_SHAREDCACHE
bit
in
the
flags
argument
passed
to
equivalent
to
setting
the
SQLITE_OPEN_PRIVATECACHE
bit
a
URI
filename
its
value
overrides
any
behavior
requested
by
setting
li
b
psow
The
psow
parameter
indicates
whether
or
not
the
storage
media
on
which
the
database
file
resides
li
b
nolock
The
nolock
parameter
is
a
boolean
query
parameter
is
useful
for
accessing
a
database
on
a
filesystem
that
does
not
or
more
processes
write
to
the
same
database
and
any
one
of
those
li
b
immutable
The
immutable
parameter
is
a
boolean
query
read
only
media
When
immutable
is
set
SQLite
assumes
that
the
privilege
and
so
the
database
is
opened
read
only
and
all
locking
property
on
a
database
file
that
does
in
fact
change
can
result
See
also
SQLITE_IOCAP_IMMUTABLE
l
Specifying
an
unknown
parameter
in
the
query
component
of
a
URI
is
not
an
parameters
See
for
URI
filename
examples
h3
URI
filename
examples
table
border
align
center
cellpadding
tr
td
file
data
db
td
tr
td
file
ome
red
ata
db
br
file
Open
the
database
file
An
error
is
not
a
recognized
authority
file
td
Windows
only
Open
the
file
on
fred
s
desktop
on
drive
necessary
space
characters
can
be
used
literally
tr
td
file
data
db
mode
ro
cache
private
td
Regardless
of
whether
or
not
shared
cache
mode
is
enabled
by
tr
td
file
ome
red
ata
db
vfs
unix
dotfile
td
that
uses
dot
files
in
place
of
posix
advisory
locking
An
error
is
not
a
valid
option
for
the
parameter
able
URI
hexadecimal
escape
sequences
HH
are
supported
within
the
path
and
percent
sign
followed
by
exactly
two
hexadecimal
digits
URI
filename
are
interpreted
they
are
encoded
using
UTF
and
all
corresponding
octet
If
this
process
generates
an
invalid
UTF
encoding
b
Note
to
Windows
users
The
encoding
used
for
the
filename
argument
codepage
is
currently
defined
Filenames
containing
international
sqlite3_open
or
sqlite3_open_v2
b
Note
to
Windows
Runtime
users
The
temporary
directory
must
be
set
features
that
require
the
use
of
temporary
files
may
fail
See
also
sqlite3_temp_directory
int
sqlite3_open
const
char
filename
sqlite3
ppDb
int
sqlite3_open16
const
void
filename
sqlite3
ppDb
int
sqlite3_open_v2
const
char
filename
sqlite3
ppDb
int
flags
const
char
zVfs
CAPI3REF
Obtain
Values
For
URI
Parameters
These
are
utility
routines
useful
to
VFS
custom
VFS
implementations
parameter
and
if
so
obtains
the
value
of
that
query
parameter
The
first
parameter
to
these
interfaces
hereafter
referred
to
ul
passed
into
the
xOpen
method
of
a
VFS
implemention
or
li
A
new
filename
constructed
using
sqlite3_create_filename
If
the
F
parameter
is
not
one
of
the
above
then
the
behavior
is
more
tolerant
of
invalid
F
parameters
than
newer
versions
If
F
is
a
suitable
filename
as
described
in
the
previous
paragraph
sqlite3_uri_parameter
F
P
returns
the
value
of
the
P
query
parameter
on
F
If
P
is
a
query
parameter
of
F
and
it
a
pointer
to
an
empty
string
The
sqlite3_uri_boolean
F
P
B
routine
assumes
that
P
is
a
boolean
of
P
The
sqlite3_uri_boolean
F
P
B
routine
returns
true
if
the
case
or
if
the
value
begins
with
a
non
zero
number
The
query
parameter
P
is
one
of
or
in
any
case
or
parameter
on
F
or
if
the
value
of
P
does
not
match
any
of
the
The
sqlite3_uri_int64
F
P
D
routine
converts
the
value
of
P
into
a
exist
If
the
value
of
P
is
something
other
than
an
integer
then
The
sqlite3_uri_key
F
N
returns
a
pointer
to
the
name
not
pointer
if
N
is
less
than
zero
or
greater
than
the
number
of
query
the
name
of
the
first
query
parameter
for
the
second
parameter
and
sqlite3_uri_boolean
F
P
B
returns
B
If
F
is
not
a
NULL
pointer
and
into
the
xOpen
VFS
method
then
the
behavior
of
this
routine
is
undefined
Beginning
with
SQLite
version
dateof
the
input
F
in
addition
to
the
main
database
file
Prior
to
version
these
When
the
F
parameter
is
the
name
of
the
rollback
journal
or
WAL
file
main
database
file
See
the
URI
filename
documentation
for
additional
information
const
char
sqlite3_uri_parameter
sqlite3_filename
z
const
char
zParam
int
sqlite3_uri_boolean
sqlite3_filename
z
const
char
zParam
int
bDefault
sqlite3_int64
sqlite3_uri_int64
sqlite3_filename
const
char
sqlite3_int64
const
char
sqlite3_uri_key
sqlite3_filename
z
int
N
CAPI3REF
Translate
filenames
These
routines
are
available
to
VFS
custom
VFS
implementations
for
and
the
WAL
file
If
F
is
the
name
of
an
sqlite
database
file
journal
file
or
WAL
file
returns
the
name
of
the
corresponding
database
file
If
F
is
the
name
of
an
sqlite
database
file
journal
file
or
WAL
file
obtained
from
sqlite3_db_filename
then
sqlite3_filename_journal
F
If
F
is
the
name
of
an
sqlite
database
file
journal
file
or
WAL
file
filename
obtained
from
sqlite3_db_filename
then
WAL
file
In
all
of
the
above
if
F
is
not
the
name
of
a
database
journal
or
WAL
return
value
from
sqlite3_db_filename
then
the
result
is
const
char
sqlite3_filename_database
sqlite3_filename
const
char
sqlite3_filename_journal
sqlite3_filename
const
char
sqlite3_filename_wal
sqlite3_filename
CAPI3REF
Database
File
Corresponding
To
A
Journal
If
X
is
the
name
of
a
rollback
or
WAL
mode
journal
file
that
is
sqlite3_database_file_object
X
returns
a
pointer
to
the
sqlite3_file
This
routine
is
intended
for
use
in
custom
VFS
implementations
The
argument
sqlite3_file_object
X
must
be
a
filename
pointer
that
flags
parameter
to
xOpen
contains
one
of
the
bits
of
this
routine
results
in
undefined
and
probably
undesirable
sqlite3_file
sqlite3_database_file_object
const
char
CAPI3REF
Create
and
Destroy
VFS
Filenames
These
interfces
are
provided
for
use
by
VFS
shim
implementations
and
The
sqlite3_create_filename
D
J
W
N
P
allocates
memory
to
hold
a
version
of
with
N
URI
parameters
key
alues
pairs
in
the
array
P
The
result
from
is
safe
to
pass
to
routines
like
li
sqlite3_uri_parameter
li
sqlite3_uri_int64
li
sqlite3_filename_database
li
sqlite3_filename_wal
If
a
memory
allocation
error
occurs
sqlite3_create_filename
might
must
be
released
by
a
corresponding
call
to
sqlite3_free_filename
Y
The
P
parameter
in
sqlite3_create_filename
D
J
W
N
P
should
be
an
array
to
a
key
and
value
for
a
query
parameter
The
P
parameter
may
be
a
NULL
NULL
pointers
and
key
pointers
should
not
be
empty
strings
be
NULL
pointers
though
they
can
be
empty
strings
The
sqlite3_free_filename
Y
routine
releases
a
memory
allocation
sqlite3_free_filename
Y
where
Y
is
a
NULL
pointer
is
a
harmless
no
op
If
the
Y
parameter
to
sqlite3_free_filename
Y
is
anything
other
sqlite3_create_filename
then
bad
things
such
as
heap
used
again
after
sqlite3_free_filename
Y
has
been
called
This
means
then
the
corresponding
sqlite3_module
xClose
method
should
also
be
sqlite3_filename
sqlite3_create_filename
const
char
zDatabase
const
char
zJournal
const
char
zWal
int
nParam
const
char
azParam
void
sqlite3_free_filename
sqlite3_filename
CAPI3REF
Error
Codes
And
Messages
If
the
most
recent
sqlite3_
API
call
associated
with
returns
the
numeric
result
code
or
extended
result
code
for
that
The
sqlite3_extended_errcode
extended
result
code
even
when
extended
result
codes
are
The
values
returned
by
sqlite3_errcode
and
r
Except
there
are
some
interfaces
that
are
guaranteed
to
never
interfaces
include
the
following
ul
li
sqlite3_extended_errcode
li
sqlite3_errmsg16
l
The
sqlite3_errmsg
and
sqlite3_errmsg16
return
English
language
Memory
to
hold
the
error
message
string
is
managed
internally
However
the
error
string
might
be
overwritten
or
deallocated
by
The
sqlite3_errstr
interface
returns
the
English
language
text
Memory
to
hold
the
error
message
string
is
managed
internally
If
the
most
recent
error
references
a
specific
token
in
the
input
of
the
start
of
that
token
The
byte
offset
returned
by
If
the
most
recent
error
does
not
reference
a
specific
token
in
the
input
When
the
serialized
threading
mode
is
in
use
it
might
be
the
the
time
of
the
first
error
and
the
call
to
these
interfaces
interfaces
always
report
the
most
recent
result
To
avoid
by
invoking
sqlite3_mutex_enter
sqlite3_db_mutex
D
before
beginning
all
calls
to
the
interfaces
listed
here
are
completed
If
an
interface
fails
with
SQLITE_MISUSE
that
means
the
interface
error
code
and
message
may
or
may
not
be
set
int
sqlite3_errcode
sqlite3
db
int
sqlite3_extended_errcode
sqlite3
db
const
char
sqlite3_errmsg
sqlite3
const
void
sqlite3_errmsg16
sqlite3
const
char
sqlite3_errstr
int
int
sqlite3_error_offset
sqlite3
db
CAPI3REF
Prepared
Statement
Object
An
instance
of
this
object
represents
a
single
SQL
statement
that
Think
of
each
SQL
statement
as
a
separate
computer
program
The
is
the
compiled
object
code
All
SQL
must
be
converted
into
a
The
life
cycle
of
a
prepared
statement
object
usually
goes
like
this
ol
li
Bind
values
to
parameters
using
the
sqlite3_bind_
li
Run
the
SQL
by
calling
sqlite3_step
one
or
more
times
to
step
Do
this
zero
or
more
times
l
typedef
struct
sqlite3_stmt
sqlite3_stmt
CAPI3REF
Run
time
Limits
This
interface
allows
the
size
of
various
constructs
to
be
limited
database
connection
whose
limit
is
to
be
set
or
queried
The
class
of
constructs
to
be
size
limited
The
third
parameter
is
the
If
the
new
limit
is
a
negative
number
the
limit
is
unchanged
limits
hard
upper
bound
limits
SQLITE_MAX_
i
NAME
Attempts
to
increase
a
limit
above
its
hard
upper
bound
are
Regardless
of
whether
or
not
the
limit
was
changed
the
Hence
to
find
the
current
value
of
a
limit
without
changing
it
Run
time
limits
are
intended
for
use
in
applications
that
manage
by
untrusted
external
sources
An
example
application
might
be
a
separate
databases
controlled
by
JavaScript
applications
downloaded
large
default
limits
Databases
managed
by
external
sources
can
attack
Developers
might
also
want
to
use
the
sqlite3_set_authorizer
created
by
an
untrusted
script
can
be
contained
using
the
New
run
time
limit
categories
may
be
added
in
future
releases
int
sqlite3_limit
sqlite3
int
id
int
newVal
CAPI3REF
Run
Time
Limit
Categories
These
constants
define
various
performance
limits
The
synopsis
of
the
meanings
of
the
various
limits
is
shown
below
dl
dd
The
maximum
size
of
any
string
or
BLOB
or
table
row
in
bytes
dd
SQLITE_LIMIT_SQL_LENGTH
dt
SQLITE_LIMIT_SQL_LENGTH
t
SQLITE_LIMIT_COLUMN
dt
SQLITE_LIMIT_COLUMN
t
result
set
of
a
SELECT
or
the
maximum
number
of
columns
in
an
index
SQLITE_LIMIT_EXPR_DEPTH
dt
SQLITE_LIMIT_EXPR_DEPTH
t
SQLITE_LIMIT_COMPOUND_SELECT
dt
SQLITE_LIMIT_COMPOUND_SELECT
t
SQLITE_LIMIT_VDBE_OP
dt
SQLITE_LIMIT_VDBE_OP
t
used
to
implement
an
SQL
statement
If
sqlite3_prepare_v2
or
in
a
single
prepared
statement
an
SQLITE_NOMEM
error
is
returned
d
SQLITE_LIMIT_FUNCTION_ARG
dt
SQLITE_LIMIT_FUNCTION_ARG
t
SQLITE_LIMIT_ATTACHED
dt
SQLITE_LIMIT_ATTACHED
t
SQLITE_LIMIT_LIKE_PATTERN_LENGTH
dd
The
maximum
length
of
the
pattern
argument
to
the
LIKE
or
SQLITE_LIMIT_VARIABLE_NUMBER
dd
The
maximum
index
number
of
any
parameter
in
an
SQL
statement
SQLITE_LIMIT_TRIGGER_DEPTH
dt
SQLITE_LIMIT_TRIGGER_DEPTH
t
SQLITE_LIMIT_WORKER_THREADS
dt
SQLITE_LIMIT_WORKER_THREADS
t
prepared
statement
may
start
d
define
SQLITE_LIMIT_LENGTH
define
SQLITE_LIMIT_SQL_LENGTH
define
SQLITE_LIMIT_COLUMN
define
SQLITE_LIMIT_EXPR_DEPTH
define
SQLITE_LIMIT_COMPOUND_SELECT
define
SQLITE_LIMIT_VDBE_OP
define
SQLITE_LIMIT_FUNCTION_ARG
define
SQLITE_LIMIT_ATTACHED
define
SQLITE_LIMIT_LIKE_PATTERN_LENGTH
define
SQLITE_LIMIT_VARIABLE_NUMBER
define
SQLITE_LIMIT_TRIGGER_DEPTH
define
SQLITE_LIMIT_WORKER_THREADS
CAPI3REF
Prepare
Flags
These
constants
define
various
flags
that
can
be
passed
into
sqlite3_prepare16_v3
interfaces
New
flags
may
be
added
in
future
releases
of
SQLite
dl
dd
The
SQLITE_PREPARE_PERSISTENT
flag
is
a
hint
to
the
query
planner
probably
reused
many
times
Without
this
flag
sqlite3_prepare_v3
be
used
just
once
or
at
most
a
few
times
and
then
destroyed
using
on
this
hint
by
avoiding
the
use
of
lookaside
memory
so
as
not
to
SQLite
may
act
on
this
hint
differently
SQLITE_PREPARE_NORMALIZE
dt
SQLITE_PREPARE_NORMALIZE
t
to
be
required
for
any
prepared
statement
that
wanted
to
use
the
sqlite3_normalized_sql
interface
is
now
available
to
all
flag
SQLITE_PREPARE_NO_VTAB
dt
SQLITE_PREPARE_NO_VTAB
t
to
return
an
error
error
code
SQLITE_ERROR
if
the
statement
uses
l
define
SQLITE_PREPARE_PERSISTENT
x01
define
SQLITE_PREPARE_NORMALIZE
x02
define
SQLITE_PREPARE_NO_VTAB
x04
CAPI3REF
Compiling
An
SQL
Statement
METHOD
sqlite3
To
execute
an
SQL
statement
it
must
first
be
compiled
into
a
byte
code
are
constructors
for
the
prepared
statement
object
The
preferred
routine
to
use
is
sqlite3_prepare_v2
The
sqlite3_prepare_v3
has
an
extra
option
that
is
used
The
use
of
the
UTF
interfaces
is
preferred
as
SQLite
currently
as
a
convenience
The
UTF
interfaces
work
by
converting
the
The
first
argument
is
a
database
connection
obtained
from
a
sqlite3_open16
The
database
connection
must
not
have
been
closed
The
second
argument
is
the
statement
to
be
compiled
encoded
and
sqlite3_prepare_v3
and
sqlite3_prepare16_v3
use
UTF
If
the
nByte
argument
is
negative
then
zSql
is
read
up
to
the
number
of
bytes
read
from
zSql
If
nByte
is
zero
then
no
prepared
If
the
caller
knows
that
the
supplied
string
is
nul
terminated
then
is
the
number
of
bytes
in
the
input
string
i
including
If
pzTail
is
not
NULL
then
pzTail
is
made
to
point
to
the
first
byte
compile
the
first
statement
in
zSql
so
pzTail
is
left
pointing
to
ppStmt
is
left
pointing
to
a
compiled
prepared
statement
that
can
be
to
NULL
If
the
input
text
contains
no
SQL
if
the
input
is
an
empty
The
calling
procedure
is
responsible
for
deleting
the
compiled
ppStmt
may
not
be
NULL
On
success
the
sqlite3_prepare
family
of
routines
return
SQLITE_OK
The
sqlite3_prepare_v2
sqlite3_prepare_v3
sqlite3_prepare16_v2
The
older
interfaces
sqlite3_prepare
and
sqlite3_prepare16
In
the
interfaces
the
prepared
statement
original
SQL
text
This
causes
the
sqlite3_step
interface
to
ol
If
the
database
schema
changes
instead
of
returning
SQLITE_SCHEMA
as
it
statement
and
try
to
run
it
again
As
many
as
SQLITE_MAX_SCHEMA_RETRY
i
li
error
codes
or
extended
error
codes
The
legacy
behavior
was
that
and
the
application
would
have
to
make
a
second
call
to
sqlite3_reset
interfaces
the
underlying
reason
for
the
error
is
returned
immediately
li
WHERE
clause
might
influence
the
choice
of
query
plan
for
a
statement
a
schema
change
on
the
first
sqlite3_step
call
following
any
change
The
specific
value
of
a
WHERE
clause
parameter
might
influence
the
or
GLOB
operator
or
if
the
parameter
is
compared
to
an
indexed
column
i
p
sqlite3_prepare_v3
differs
from
sqlite3_prepare_v2
only
in
having
more
of
the
SQLITE_PREPARE_PERSISTENT
SQLITE_PREPARE_
flags
The
sqlite3_prepare_v3
with
a
zero
prepFlags
parameter
int
sqlite3_prepare
sqlite3
db
const
char
zSql
int
nByte
sqlite3_stmt
ppStmt
const
char
pzTail
int
sqlite3_prepare_v2
sqlite3
db
const
char
zSql
int
nByte
sqlite3_stmt
ppStmt
const
char
pzTail
int
sqlite3_prepare_v3
sqlite3
db
const
char
zSql
int
nByte
unsigned
int
prepFlags
sqlite3_stmt
ppStmt
const
char
pzTail
int
sqlite3_prepare16
sqlite3
db
const
void
zSql
int
nByte
sqlite3_stmt
ppStmt
const
void
pzTail
int
sqlite3_prepare16_v2
sqlite3
db
const
void
zSql
int
nByte
sqlite3_stmt
ppStmt
const
void
pzTail
int
sqlite3_prepare16_v3
sqlite3
db
const
void
zSql
int
nByte
unsigned
int
prepFlags
sqlite3_stmt
ppStmt
const
void
pzTail
CAPI3REF
Retrieving
Statement
SQL
The
sqlite3_sql
P
interface
returns
a
pointer
to
a
copy
of
the
UTF
created
by
sqlite3_prepare_v2
sqlite3_prepare_v3
The
sqlite3_expanded_sql
P
interface
returns
a
pointer
to
a
UTF
bound
parameters
expanded
string
containing
the
normalized
SQL
text
of
prepared
statement
P
The
to
change
At
a
minimum
literal
values
will
be
replaced
with
suitable
For
example
if
a
prepared
statement
is
created
using
the
SQL
and
parameter
xyz
is
unbound
then
sqlite3_sql
will
return
will
return
The
sqlite3_expanded_sql
interface
returns
NULL
if
insufficient
memory
the
maximum
string
length
determined
by
the
SQLITE_LIMIT_LENGTH
The
SQLITE_TRACE_SIZE_LIMIT
compile
time
option
limits
the
size
of
option
causes
sqlite3_expanded_sql
to
always
return
NULL
The
strings
returned
by
sqlite3_sql
P
and
sqlite3_normalized_sql
P
statement
is
finalized
is
obtained
from
sqlite3_malloc
and
must
be
freed
by
the
application
The
sqlite3_normalized_sql
interface
is
only
available
if
const
char
sqlite3_sql
sqlite3_stmt
pStmt
char
sqlite3_expanded_sql
sqlite3_stmt
pStmt
ifdef
SQLITE_ENABLE_NORMALIZE
const
char
sqlite3_normalized_sql
sqlite3_stmt
pStmt
endif
CAPI3REF
Determine
If
An
SQL
Statement
Writes
The
Database
The
sqlite3_stmt_readonly
X
interface
returns
true
non
zero
if
the
content
of
the
database
file
Note
that
application
defined
SQL
functions
or
For
example
if
an
application
defines
a
function
that
change
the
database
file
through
side
effects
blockquote
pre
re
lockquote
But
because
the
SELECT
statement
does
not
change
the
database
file
Transaction
control
statements
such
as
BEGIN
COMMIT
ROLLBACK
since
the
statements
themselves
do
not
actually
modify
the
database
but
database
The
ATTACH
and
DETACH
statements
also
cause
change
the
configuration
of
a
database
connection
they
do
not
make
The
sqlite3_stmt_readonly
interface
returns
true
for
BEGIN
since
BEGIN
BEGIN
EXCLUSIVE
commands
do
touch
the
database
and
so
This
routine
returns
false
if
there
is
any
possibility
that
the
not
guarantee
that
the
statement
will
change
the
database
file
makes
it
a
no
op
but
the
sqlite3_stmt_readonly
result
would
still
read
only
no
op
if
the
table
already
exists
but
If
prepared
statement
X
is
an
EXPLAIN
or
EXPLAIN
QUERY
PLAN
if
the
EXPLAIN
or
EXPLAIN
QUERY
PLAN
prefix
were
omitted
int
sqlite3_stmt_readonly
sqlite3_stmt
pStmt
CAPI3REF
Query
The
EXPLAIN
Setting
For
A
Prepared
Statement
The
sqlite3_stmt_isexplain
S
interface
returns
if
the
statement
S
is
an
EXPLAIN
QUERY
PLAN
an
ordinary
statement
or
a
NULL
pointer
int
sqlite3_stmt_isexplain
sqlite3_stmt
pStmt
CAPI3REF
Determine
If
A
Prepared
Statement
Has
Been
Reset
The
sqlite3_stmt_busy
S
interface
returns
true
non
zero
if
the
sqlite3_step
S
but
has
neither
run
to
completion
returned
been
reset
using
sqlite3_reset
S
The
sqlite3_stmt_busy
S
NULL
pointer
and
is
not
a
pointer
to
a
valid
prepared
statement
This
interface
can
be
used
in
combination
sqlite3_next_stmt
connection
that
are
in
need
of
being
reset
This
can
be
used
statements
that
are
holding
a
transaction
open
int
sqlite3_stmt_busy
sqlite3_stmt
CAPI3REF
Dynamically
Typed
Value
Object
SQLite
uses
the
sqlite3_value
object
to
represent
all
values
for
the
values
it
stores
Values
stored
in
sqlite3_value
objects
An
sqlite3_value
object
may
be
either
or
will
accept
either
a
protected
or
an
unprotected
sqlite3_value
whether
or
not
it
requires
a
protected
sqlite3_value
The
protected
sqlite3_value
from
an
unprotected
sqlite3_value
The
terms
and
refer
to
whether
or
not
sqlite3_value
object
but
no
mutex
is
held
for
an
unprotected
with
SQLITE_THREADSAFE
and
with
sqlite3_threadsafe
returning
SQLITE_CONFIG_SINGLETHREAD
or
SQLITE_CONFIG_MULTITHREAD
sqlite3_value
objects
and
they
can
be
used
interchangeably
However
still
make
the
distinction
between
protected
and
unprotected
The
sqlite3_value
objects
that
are
passed
as
parameters
into
the
The
sqlite3_value
objects
returned
by
sqlite3_vtab_rhs_value
The
sqlite3_value
object
returned
by
Unprotected
sqlite3_value
objects
may
only
be
used
as
arguments
sqlite3_value_dup
interfaces
require
protected
sqlite3_value
objects
typedef
struct
sqlite3_value
sqlite3_value
CAPI3REF
SQL
Function
Context
Object
The
context
in
which
an
SQL
function
executes
is
stored
in
an
is
always
first
parameter
to
application
defined
SQL
functions
pointer
through
into
calls
to
sqlite3_result_int
sqlite3_result
sqlite3_context_db_handle
sqlite3_get_auxdata
typedef
struct
sqlite3_context
sqlite3_context
CAPI3REF
Binding
Values
To
Prepared
Statements
KEYWORDS
SQL
parameter
SQL
parameters
parameter
binding
In
the
SQL
statement
text
input
to
sqlite3_prepare_v2
and
its
variants
templates
ul
li
NNN
li
VVV
l
In
the
templates
above
NNN
represents
an
integer
literal
parameters
also
called
or
The
first
argument
to
the
sqlite3_bind_
routines
is
always
sqlite3_prepare_v2
or
its
variants
The
second
argument
is
the
index
of
the
SQL
parameter
to
be
set
SQL
parameter
is
used
more
than
once
second
and
subsequent
The
index
for
named
parameters
can
be
looked
up
using
the
for
parameters
is
the
value
of
NNN
parameter
SQLITE_LIMIT_VARIABLE_NUMBER
default
value
The
third
argument
is
the
value
to
bind
to
the
parameter
or
sqlite3_bind_blob
is
a
NULL
pointer
then
the
fourth
parameter
If
the
third
parameter
to
sqlite3_bind_text
is
not
NULL
then
If
the
third
parameter
to
sqlite3_bind_text16
is
not
NULL
then
If
the
third
parameter
to
sqlite3_bind_text64
is
not
NULL
then
either
UTF8
if
the
sixth
parameter
is
SQLITE_UTF8
or
UTF16
byte
order
determination
rules
The
byte
order
of
found
in
first
character
which
is
removed
or
in
the
absence
of
a
BOM
machine
for
sqlite3_bind_text16
or
the
byte
order
specified
in
If
UTF16
input
text
contains
invalid
unicode
into
the
unicode
replacement
character
U
FFFD
In
those
routines
that
have
a
fourth
argument
its
value
is
the
number
of
u
bytes
in
the
value
not
the
number
of
characters
is
negative
then
the
length
of
the
string
is
If
the
fourth
parameter
to
sqlite3_bind_blob
is
negative
then
If
a
non
negative
fourth
parameter
is
provided
to
sqlite3_bind_text
that
parameter
must
be
the
byte
offset
terminated
If
any
NUL
characters
occurs
at
byte
offsets
less
than
contain
embedded
NULs
The
result
of
expressions
involving
strings
The
fifth
argument
to
the
BLOB
and
string
binding
interfaces
controls
These
three
options
exist
with
it
may
be
passed
It
is
called
to
dispose
of
the
BLOB
or
string
even
the
third
parameter
is
a
NULL
pointer
or
the
fourth
parameter
is
negative
the
application
remains
responsible
for
disposing
of
the
object
In
this
either
the
prepared
statement
is
finalized
or
the
same
SQL
parameter
is
The
constant
SQLITE_TRANSIENT
may
be
passed
to
indicate
that
the
object
and
pointer
to
it
must
remain
valid
until
then
SQLite
will
then
The
sixth
argument
to
sqlite3_bind_text64
must
be
one
of
to
specify
the
encoding
of
the
text
in
the
third
parameter
If
allowed
values
shown
above
or
if
the
text
encoding
is
different
is
undefined
The
sqlite3_bind_zeroblob
routine
binds
a
BLOB
of
length
N
that
just
an
integer
to
hold
its
size
while
it
is
being
processed
content
is
later
written
using
A
negative
value
for
the
zeroblob
results
in
a
zero
length
BLOB
The
sqlite3_bind_pointer
S
I
P
T
D
routine
causes
the
I
th
parameter
in
associated
with
the
pointer
P
of
type
T
D
is
either
a
NULL
pointer
or
destructor
D
with
a
single
argument
of
P
when
it
is
finished
using
literal
The
sqlite3_bind_pointer
routine
is
part
of
the
If
any
of
the
sqlite3_bind_
routines
are
called
with
a
NULL
pointer
sqlite3_step
has
been
called
more
recently
than
sqlite3_reset
routine
is
passed
a
prepared
statement
that
has
been
finalized
the
Bindings
are
not
cleared
by
the
sqlite3_reset
routine
The
sqlite3_bind_
routines
return
SQLITE_OK
on
success
or
an
SQLITE_TOOBIG
might
be
returned
if
the
size
of
a
string
or
BLOB
SQLITE_MAX_LENGTH
index
is
out
of
range
SQLITE_NOMEM
is
returned
if
malloc
fails
See
also
sqlite3_bind_parameter_count
int
sqlite3_bind_blob
sqlite3_stmt
int
const
void
int
n
void
void
int
sqlite3_bind_blob64
sqlite3_stmt
int
const
void
sqlite3_uint64
void
void
int
sqlite3_bind_double
sqlite3_stmt
int
double
int
sqlite3_bind_int
sqlite3_stmt
int
int
int
sqlite3_bind_int64
sqlite3_stmt
int
sqlite3_int64
int
sqlite3_bind_null
sqlite3_stmt
int
int
sqlite3_bind_text
sqlite3_stmt
int
const
char
int
void
void
int
sqlite3_bind_text16
sqlite3_stmt
int
const
void
int
void
void
int
sqlite3_bind_text64
sqlite3_stmt
int
const
char
sqlite3_uint64
void
void
unsigned
char
encoding
int
sqlite3_bind_value
sqlite3_stmt
int
const
sqlite3_value
int
sqlite3_bind_pointer
sqlite3_stmt
int
void
const
char
void
void
int
sqlite3_bind_zeroblob
sqlite3_stmt
int
int
n
int
sqlite3_bind_zeroblob64
sqlite3_stmt
int
sqlite3_uint64
CAPI3REF
Number
Of
SQL
Parameters
This
routine
can
be
used
to
find
the
number
of
SQL
parameters
form
or
that
serve
as
to
the
parameters
at
a
later
time
This
routine
actually
returns
the
index
of
the
largest
rightmost
number
of
unique
parameters
If
parameters
of
the
NNN
form
are
used
See
also
sqlite3_bind_blob
sqlite3_bind
sqlite3_bind_parameter_index
int
sqlite3_bind_parameter_count
sqlite3_stmt
CAPI3REF
Name
Of
A
Host
Parameter
The
sqlite3_bind_parameter_name
P
N
interface
returns
SQL
parameters
of
the
form
or
or
or
respectively
is
included
as
part
of
the
name
and
are
referred
to
as
or
The
first
host
parameter
has
an
index
of
not
If
the
value
N
is
out
of
range
or
if
the
N
th
parameter
is
always
in
UTF
encoding
even
if
the
named
parameter
was
sqlite3_prepare16_v2
or
sqlite3_prepare16_v3
See
also
sqlite3_bind_blob
sqlite3_bind
sqlite3_bind_parameter_index
const
char
sqlite3_bind_parameter_name
sqlite3_stmt
int
CAPI3REF
Index
Of
A
Parameter
With
A
Given
Name
Return
the
index
of
an
SQL
parameter
given
its
name
The
parameter
to
sqlite3_bind_blob
sqlite3_bind
A
zero
name
must
be
given
in
UTF
even
if
the
original
statement
sqlite3_prepare16_v3
See
also
sqlite3_bind_blob
sqlite3_bind
sqlite3_bind_parameter_name
int
sqlite3_bind_parameter_index
sqlite3_stmt
const
char
zName
CAPI3REF
Reset
All
Bindings
On
A
Prepared
Statement
Contrary
to
the
intuition
of
many
sqlite3_reset
does
not
reset
Use
this
routine
to
reset
all
host
parameters
to
NULL
int
sqlite3_clear_bindings
sqlite3_stmt
CAPI3REF
Number
Of
Columns
In
A
Result
Set
Return
the
number
of
columns
in
the
result
set
returned
by
the
prepared
statement
returns
no
data
for
example
an
UPDATE
mean
that
one
or
more
rows
of
data
will
be
returned
A
SELECT
statement
WHERE
clause
constraints
and
the
table
content
it
might
return
no
rows
See
also
sqlite3_data_count
int
sqlite3_column_count
sqlite3_stmt
pStmt
CAPI3REF
Column
Names
In
A
Result
Set
These
routines
return
the
name
assigned
to
a
particular
column
interface
returns
a
pointer
to
a
zero
terminated
UTF
string
UTF
string
The
first
parameter
is
the
prepared
statement
column
number
The
leftmost
column
is
number
The
returned
string
pointer
is
valid
until
either
the
prepared
statement
reprepared
by
the
first
call
to
sqlite3_step
for
a
particular
run
sqlite3_column_name
or
sqlite3_column_name16
on
the
same
column
If
sqlite3_malloc
fails
during
the
processing
of
either
routine
NULL
pointer
is
returned
The
name
of
a
result
column
is
the
value
of
the
clause
for
then
the
name
of
the
column
is
unspecified
and
may
change
from
const
char
sqlite3_column_name
sqlite3_stmt
int
N
const
void
sqlite3_column_name16
sqlite3_stmt
int
N
CAPI3REF
Source
Of
Data
In
A
Query
Result
These
routines
provide
a
means
to
determine
the
database
table
and
SELECT
statement
either
a
UTF
or
UTF
string
The
_database_
routines
return
the
origin_
routines
return
the
column
name
using
sqlite3_finalize
or
until
the
statement
is
automatically
or
until
the
same
information
is
requested
The
names
returned
are
the
original
un
aliased
names
of
the
The
first
argument
to
these
interfaces
is
a
prepared
statement
the
statement
where
N
is
the
second
function
argument
If
the
Nth
column
returned
by
the
statement
is
an
expression
or
NULL
These
routines
might
also
return
NULL
if
a
memory
allocation
error
or
column
that
query
result
column
was
extracted
from
As
with
all
other
SQLite
APIs
those
whose
names
end
with
return
These
APIs
are
only
available
if
the
library
was
compiled
with
the
If
two
or
more
threads
call
one
or
more
for
the
same
prepared
statement
and
result
column
const
char
sqlite3_column_database_name
sqlite3_stmt
int
const
void
sqlite3_column_database_name16
sqlite3_stmt
int
const
char
sqlite3_column_table_name
sqlite3_stmt
int
const
void
sqlite3_column_table_name16
sqlite3_stmt
int
const
char
sqlite3_column_origin_name
sqlite3_stmt
int
const
void
sqlite3_column_origin_name16
sqlite3_stmt
int
CAPI3REF
Declared
Datatype
Of
A
Query
Result
The
first
parameter
is
a
prepared
statement
returned
result
set
of
that
SELECT
is
a
table
column
not
an
column
is
returned
If
the
Nth
column
of
the
result
set
is
an
The
returned
string
is
always
UTF
encoded
For
example
given
the
database
schema
CREATE
TABLE
t1
c1
VARIANT
and
the
following
statement
to
be
compiled
SELECT
c1
c1
FROM
t1
this
routine
would
return
the
string
for
the
second
result
SQLite
uses
dynamic
run
time
typing
So
just
because
a
column
data
stored
in
that
column
is
of
the
declared
type
SQLite
is
is
associated
with
individual
values
not
with
the
containers
const
char
sqlite3_column_decltype
sqlite3_stmt
int
const
void
sqlite3_column_decltype16
sqlite3_stmt
int
CAPI3REF
Evaluate
An
SQL
Statement
After
a
prepared
statement
has
been
prepared
using
any
of
or
sqlite3_prepare16_v3
or
one
of
the
legacy
must
be
called
one
or
more
times
to
evaluate
the
statement
The
details
of
the
behavior
of
the
sqlite3_step
interface
depend
sqlite3_prepare_v3
sqlite3_prepare_v2
sqlite3_prepare16_v3
interfaces
sqlite3_prepare
and
sqlite3_prepare16
The
use
of
the
interface
will
continue
to
be
supported
In
the
legacy
interface
the
return
value
will
be
either
SQLITE_BUSY
With
the
interface
any
of
the
other
result
codes
or
SQLITE_BUSY
means
that
the
database
engine
was
unable
to
acquire
the
or
occurs
outside
of
an
explicit
transaction
then
you
can
retry
the
explicit
transaction
then
you
should
rollback
the
transaction
before
SQLITE_DONE
means
that
the
statement
has
finished
executing
machine
without
first
calling
sqlite3_reset
to
reset
the
virtual
If
the
SQL
statement
being
executed
returns
any
data
then
SQLITE_ROW
caller
The
values
may
be
accessed
using
the
column
access
functions
SQLITE_ERROR
means
that
a
run
time
error
such
as
a
constraint
the
VM
More
information
may
be
found
by
calling
sqlite3_errmsg
SQLITE_INTERRUPT
SQLITE_SCHEMA
SQLITE_CORRUPT
and
so
forth
prepared
statement
In
the
interface
SQLITE_MISUSE
means
that
the
this
routine
was
called
inappropriately
already
been
sqlite3_finalize
finalized
or
on
one
that
had
be
the
case
that
the
same
database
connection
is
being
used
by
two
or
For
all
versions
of
SQLite
up
to
and
including
a
call
to
other
than
SQLITE_ROW
before
any
subsequent
invocation
of
sqlite3_reset
would
result
in
an
SQLITE_MISUSE
return
from
sqlite3_step
began
than
returning
SQLITE_MISUSE
This
is
not
considered
a
compatibility
is
broken
by
definition
The
SQLITE_OMIT_AUTORESET
compile
time
option
b
Goofy
Interface
Alert
In
the
legacy
interface
the
sqlite3_step
error
other
than
SQLITE_BUSY
and
SQLITE_MISUSE
You
must
call
specific
error
codes
that
better
describes
the
error
with
the
interface
If
you
prepare
all
of
your
SQL
statements
or
sqlite3_prepare16_v2
or
sqlite3_prepare16_v3
instead
then
the
more
specific
error
codes
are
returned
directly
int
sqlite3_step
sqlite3_stmt
CAPI3REF
Number
of
columns
in
a
result
set
The
sqlite3_data_count
P
interface
returns
the
number
of
columns
in
the
If
prepared
statement
P
does
not
have
results
ready
to
return
interfaces
then
sqlite3_data_count
P
returns
The
sqlite3_data_count
P
routine
returns
if
the
previous
call
to
will
return
non
zero
if
previous
call
to
sqlite3_step
P
returned
where
it
always
returns
zero
since
each
step
of
that
multi
step
See
also
sqlite3_column_count
int
sqlite3_data_count
sqlite3_stmt
pStmt
CAPI3REF
Fundamental
Datatypes
Every
value
in
SQLite
has
one
of
five
fundamental
datatypes
ul
li
bit
IEEE
floating
point
number
li
BLOB
l
These
constants
are
codes
for
each
of
those
types
Note
that
the
SQLITE_TEXT
constant
was
also
used
in
SQLite
version
SQLite
version
and
SQLite
version
should
use
SQLITE3_TEXT
not
define
SQLITE_INTEGER
define
SQLITE_FLOAT
define
SQLITE_BLOB
define
SQLITE_NULL
ifdef
SQLITE_TEXT
undef
SQLITE_TEXT
else
define
SQLITE_TEXT
endif
define
SQLITE3_TEXT
CAPI3REF
Result
Values
From
A
Query
METHOD
sqlite3_stmt
b
Summary
tr
td
b
sqlite3_column_blob
td
rarr
td
BLOB
result
tr
td
b
sqlite3_column_int
td
rarr
td
bit
INTEGER
result
tr
td
b
sqlite3_column_text
td
rarr
td
UTF
TEXT
result
tr
td
b
sqlite3_column_value
td
rarr
td
The
result
as
an
tr
td
nbsp
td
nbsp
td
nbsp
or
a
UTF
TEXT
result
in
bytes
td
rarr
nbsp
nbsp
td
Size
of
UTF
tr
td
b
sqlite3_column_type
td
rarr
td
Default
able
lockquote
b
Details
These
routines
return
information
about
a
single
column
of
the
current
to
the
prepared
statement
that
is
being
evaluated
the
sqlite3_stmt
and
the
second
argument
is
the
index
of
the
column
for
which
information
The
number
of
columns
in
the
result
can
be
determined
using
If
the
SQL
statement
does
not
currently
point
to
a
valid
row
or
if
the
These
routines
may
only
be
called
when
the
most
recent
call
to
sqlite3_reset
nor
sqlite3_finalize
have
been
called
subsequently
sqlite3_finalize
or
after
sqlite3_step
has
returned
If
sqlite3_step
or
sqlite3_reset
or
sqlite3_finalize
are
pending
then
the
results
are
undefined
The
first
six
interfaces
_blob
_double
_int
_int64
_text
and
_text16
the
result
column
is
not
initially
in
the
requested
format
for
example
is
used
to
extract
the
value
then
an
automatic
type
conversion
is
performed
The
sqlite3_column_type
routine
returns
the
of
the
result
column
The
returned
value
is
one
of
SQLITE_INTEGER
The
return
value
of
sqlite3_column_type
can
be
used
to
decide
which
The
value
returned
by
sqlite3_column_type
is
only
meaningful
if
no
After
a
type
conversion
the
result
of
calling
sqlite3_column_type
versions
of
SQLite
may
change
the
behavior
of
sqlite3_column_type
If
the
result
is
a
BLOB
or
a
TEXT
string
then
the
sqlite3_column_bytes
of
that
BLOB
or
string
If
the
result
is
a
BLOB
or
UTF
string
then
the
sqlite3_column_bytes
If
the
result
is
a
UTF
string
then
sqlite3_column_bytes
converts
If
the
result
is
a
numeric
value
then
sqlite3_column_bytes
uses
the
number
of
bytes
in
that
string
If
the
result
is
a
BLOB
or
UTF
string
then
the
sqlite3_column_bytes16
If
the
result
is
a
UTF
string
then
sqlite3_column_bytes16
converts
If
the
result
is
a
numeric
value
then
sqlite3_column_bytes16
uses
the
number
of
bytes
in
that
string
The
values
returned
by
sqlite3_column_bytes
and
of
the
string
For
clarity
the
values
returned
by
bytes
in
the
string
not
the
number
of
characters
Strings
returned
by
sqlite3_column_text
and
sqlite3_column_text16
value
from
sqlite3_column_blob
for
a
zero
length
BLOB
is
a
NULL
pointer
Strings
returned
by
sqlite3_column_text16
always
have
the
endianness
for
the
database
b
Warning
The
object
returned
by
sqlite3_column_value
is
an
an
unprotected
sqlite3_value
object
may
only
be
used
safely
with
If
the
unprotected
sqlite3_value
object
returned
by
to
routines
like
sqlite3_value_int
sqlite3_value_text
Hence
the
sqlite3_column_value
interface
application
defined
SQL
functions
or
virtual
tables
not
within
These
routines
may
attempt
to
convert
the
datatype
of
the
result
is
requested
sqlite3_snprintf
is
used
internally
to
perform
the
that
are
applied
blockquote
tr
th
Internal
br
Type
th
Requested
br
Type
th
Conversion
tr
td
NULL
td
INTEGER
td
Result
is
tr
td
NULL
td
TEXT
td
Result
is
a
NULL
pointer
tr
td
INTEGER
td
FLOAT
td
Convert
from
integer
to
float
tr
td
INTEGER
td
BLOB
td
Same
as
INTEGER
TEXT
tr
td
FLOAT
td
TEXT
td
ASCII
rendering
of
the
float
tr
td
TEXT
td
INTEGER
td
CAST
to
INTEGER
tr
td
TEXT
td
BLOB
td
No
change
tr
td
BLOB
td
FLOAT
td
CAST
to
REAL
able
Note
that
when
type
conversions
occur
pointers
returned
by
prior
sqlite3_column_text16
may
be
invalidated
in
the
following
cases
ul
sqlite3_column_text16
is
called
A
zero
terminator
might
li
The
initial
content
is
UTF
text
and
sqlite3_column_bytes16
or
to
UTF
i
sqlite3_column_text
is
called
The
content
must
be
converted
l
Conversions
between
UTF
be
and
UTF
le
are
always
done
in
place
and
do
that
the
prior
pointer
references
will
have
been
modified
Other
kinds
are
not
possible
and
in
those
cases
prior
pointers
are
invalidated
The
safest
policy
is
to
invoke
these
routines
ul
li
sqlite3_column_blob
followed
by
sqlite3_column_bytes
i
l
In
other
words
you
should
call
sqlite3_column_text
into
the
desired
format
then
invoke
sqlite3_column_bytes
or
to
sqlite3_column_text
or
sqlite3_column_blob
with
calls
to
with
calls
to
sqlite3_column_bytes
The
pointers
returned
are
valid
until
a
type
conversion
occurs
as
sqlite3_finalize
is
called
The
memory
space
used
to
hold
strings
from
sqlite3_column_blob
sqlite3_column_text
etc
into
As
long
as
the
input
parameters
are
correct
these
routines
will
only
Only
the
following
subset
of
interfaces
are
subject
to
out
of
memory
ul
li
sqlite3_column_text
li
sqlite3_column_bytes
l
If
an
out
of
memory
error
occurs
then
the
return
value
from
these
Valid
SQL
NULL
returns
can
be
distinguished
from
out
of
memory
errors
return
value
is
obtained
and
before
any
const
void
sqlite3_column_blob
sqlite3_stmt
int
iCol
double
sqlite3_column_double
sqlite3_stmt
int
iCol
int
sqlite3_column_int
sqlite3_stmt
int
iCol
sqlite3_int64
sqlite3_column_int64
sqlite3_stmt
int
iCol
const
unsigned
char
sqlite3_column_text
sqlite3_stmt
int
iCol
const
void
sqlite3_column_text16
sqlite3_stmt
int
iCol
sqlite3_value
sqlite3_column_value
sqlite3_stmt
int
iCol
int
sqlite3_column_bytes
sqlite3_stmt
int
iCol
int
sqlite3_column_bytes16
sqlite3_stmt
int
iCol
int
sqlite3_column_type
sqlite3_stmt
int
iCol
CAPI3REF
Destroy
A
Prepared
Statement
Object
The
sqlite3_finalize
function
is
called
to
delete
a
prepared
statement
or
if
the
statement
is
never
been
evaluated
then
sqlite3_finalize
returns
sqlite3_finalize
S
returns
the
appropriate
error
code
or
The
sqlite3_finalize
S
routine
can
be
called
at
any
point
during
before
statement
S
is
ever
evaluated
after
to
sqlite3_step
regardless
of
whether
or
not
the
statement
has
Invoking
sqlite3_finalize
on
a
NULL
pointer
is
a
harmless
no
op
The
application
must
finalize
every
prepared
statement
in
order
to
avoid
a
prepared
statement
after
it
has
been
finalized
Any
use
of
a
prepared
undesirable
behavior
such
as
segfaults
and
heap
corruption
int
sqlite3_finalize
sqlite3_stmt
pStmt
CAPI3REF
Reset
A
Prepared
Statement
Object
The
sqlite3_reset
function
is
called
to
reset
a
prepared
statement
Any
SQL
statement
variables
that
had
values
bound
to
them
using
Use
sqlite3_clear_bindings
to
reset
the
bindings
The
sqlite3_reset
S
interface
resets
the
prepared
statement
S
If
the
most
recent
call
to
sqlite3_step
S
for
the
or
if
sqlite3_step
S
has
never
before
been
called
on
S
If
the
most
recent
call
to
sqlite3_step
S
for
the
sqlite3_reset
S
returns
an
appropriate
error
code
The
sqlite3_reset
S
interface
does
not
change
the
values
int
sqlite3_reset
sqlite3_stmt
pStmt
CAPI3REF
Create
Or
Redefine
SQL
Functions
METHOD
sqlite3
These
functions
collectively
known
as
of
existing
SQL
functions
or
aggregates
The
only
differences
between
expected
for
the
second
parameter
the
name
of
the
function
being
the
application
data
pointer
Function
sqlite3_create_window_function
needed
by
aggregate
window
functions
The
first
parameter
is
the
database
connection
to
which
the
SQL
connection
then
application
defined
SQL
functions
must
be
added
The
second
parameter
is
the
name
of
the
SQL
function
to
be
created
or
representation
exclusive
of
the
zero
terminator
Note
that
the
name
Any
attempt
to
create
a
function
with
a
longer
name
The
third
parameter
nArg
aggregate
takes
If
this
parameter
is
then
the
SQL
function
or
set
by
sqlite3_limit
SQLITE_LIMIT_FUNCTION_ARG
If
the
third
undefined
The
fourth
parameter
eTextRep
specifies
what
its
parameters
The
application
should
set
this
parameter
to
sqlite3_value_text16le
on
an
input
or
SQLITE_UTF16BE
if
the
SQLITE_UTF16
if
sqlite3_value_text16
is
used
or
SQLITE_UTF8
different
preferred
text
encodings
with
different
implementations
for
When
multiple
implementations
of
the
same
function
are
available
SQLite
The
fourth
parameter
may
optionally
be
ORed
with
SQLITE_DETERMINISTIC
the
same
inputs
within
a
single
SQL
statement
Most
SQL
functions
are
function
that
is
not
deterministic
The
SQLite
query
planner
is
able
to
of
the
SQLITE_DETERMINISTIC
flag
is
recommended
where
possible
The
fourth
parameter
may
also
optionally
include
the
SQLITE_DIRECTONLY
within
VIEWs
TRIGGERs
CHECK
constraints
generated
column
expressions
For
best
security
the
SQLITE_DIRECTONLY
flag
is
recommended
for
used
inside
of
triggers
view
CHECK
constraints
or
other
elements
of
functions
that
have
side
effects
or
reveal
internal
application
state
a
database
file
to
include
invocations
of
the
function
with
parameters
the
database
file
is
opened
and
read
The
fifth
parameter
is
an
arbitrary
pointer
The
implementation
of
the
The
sixth
seventh
and
eighth
parameters
passed
to
the
three
pointers
to
C
language
functions
that
implement
the
SQL
function
or
callback
only
NULL
pointers
must
be
passed
as
the
xStep
and
xFinal
and
xFinal
and
NULL
pointer
must
be
passed
for
xFunc
To
delete
an
existing
callbacks
The
sixth
seventh
eighth
and
ninth
parameters
xStep
xFinal
xValue
C
language
callbacks
that
implement
the
new
function
xStep
and
xFinal
which
case
a
regular
aggregate
function
is
created
or
must
both
be
or
aggregate
window
function
More
details
regarding
the
implementation
user
defined
window
functions
available
here
If
the
final
parameter
to
sqlite3_create_function_v2
or
the
application
data
pointer
The
destructor
is
invoked
when
the
function
closes
The
destructor
is
also
invoked
if
the
call
to
invoked
it
is
passed
a
single
argument
which
is
a
copy
of
the
application
It
is
permitted
to
register
multiple
implementations
of
the
same
arguments
or
differing
preferred
text
encodings
SQLite
will
use
SQL
function
is
used
A
function
implementation
with
a
non
negative
a
negative
nArg
A
function
where
the
preferred
text
encoding
match
than
a
function
where
the
encoding
is
different
is
a
closer
match
than
a
function
where
the
encoding
difference
is
Built
in
functions
may
be
overloaded
by
new
application
defined
functions
An
application
defined
function
is
permitted
to
call
other
close
the
database
connection
nor
finalize
or
reset
the
prepared
int
sqlite3_create_function
sqlite3
db
const
char
zFunctionName
int
nArg
int
eTextRep
void
pApp
void
xFunc
sqlite3_context
int
sqlite3_value
void
xStep
sqlite3_context
int
sqlite3_value
void
xFinal
sqlite3_context
int
sqlite3_create_function16
sqlite3
db
const
void
zFunctionName
int
nArg
int
eTextRep
void
pApp
void
xFunc
sqlite3_context
int
sqlite3_value
void
xStep
sqlite3_context
int
sqlite3_value
void
xFinal
sqlite3_context
int
sqlite3_create_function_v2
sqlite3
db
const
char
zFunctionName
int
nArg
int
eTextRep
void
pApp
void
xFunc
sqlite3_context
int
sqlite3_value
void
xStep
sqlite3_context
int
sqlite3_value
void
xFinal
sqlite3_context
void
xDestroy
void
int
sqlite3_create_window_function
sqlite3
db
const
char
zFunctionName
int
nArg
int
eTextRep
void
pApp
void
xStep
sqlite3_context
int
sqlite3_value
void
xFinal
sqlite3_context
void
xValue
sqlite3_context
void
xInverse
sqlite3_context
int
sqlite3_value
void
xDestroy
void
CAPI3REF
Text
Encodings
These
constant
define
integer
codes
that
represent
the
various
define
SQLITE_UTF8
define
SQLITE_UTF16LE
define
SQLITE_UTF16BE
define
SQLITE_UTF16
define
SQLITE_ANY
define
SQLITE_UTF16_ALIGNED
CAPI3REF
Function
Flags
These
constants
may
be
ORed
together
with
the
to
sqlite3_create_function
sqlite3_create_function16
or
dl
The
SQLITE_DETERMINISTIC
flag
means
that
the
new
function
always
gives
The
abs
abs
function
is
deterministic
for
example
but
be
deterministic
in
order
to
be
used
in
certain
contexts
such
as
SQLite
might
also
optimize
deterministic
functions
by
factoring
them
d
SQLITE_DIRECTONLY
dt
SQLITE_DIRECTONLY
t
dd
from
top
level
SQL
and
cannot
be
used
in
VIEWs
or
TRIGGERs
nor
in
expression
indexes
partial
indexes
or
generated
columns
for
all
application
defined
SQL
functions
and
especially
for
functions
information
SQLITE_INNOCUOUS
dt
SQLITE_INNOCUOUS
t
dd
to
cause
problems
even
if
misused
An
innocuous
function
should
have
input
parameters
The
abs
abs
function
is
an
example
of
an
The
load_extension
SQL
function
is
not
innocuous
because
of
its
p
SQLITE_INNOCUOUS
is
similar
to
SQLITE_DETERMINISTIC
but
is
not
function
that
is
innocuous
but
not
deterministic
SQLITE_DBCONFIG_TRUSTED_SCHEMA
and
PRAGMA
trusted_schema
OFF
schema
structures
such
as
CHECK
constraints
DEFAULT
clauses
the
function
is
tagged
with
SQLITE_INNOCUOUS
Most
built
in
functions
SQLITE_INNOCUOUS
flag
for
application
defined
functions
unless
the
security
adverse
side
effects
and
information
leaks
SQLITE_SUBTYPE
dt
SQLITE_SUBTYPE
t
dd
sqlite3_value_subtype
to
inspect
the
sub
types
of
its
arguments
functions
However
if
it
is
not
specified
for
a
user
defined
window
function
may
be
discarded
before
the
window
function
is
called
i
e
d
define
SQLITE_DETERMINISTIC
x000000800
define
SQLITE_DIRECTONLY
x000080000
define
SQLITE_SUBTYPE
x000100000
define
SQLITE_INNOCUOUS
x000200000
CAPI3REF
Deprecated
Functions
These
functions
are
deprecated
In
order
to
maintain
to
be
supported
However
new
applications
should
avoid
these
functions
we
will
not
explain
what
they
do
ifndef
SQLITE_OMIT_DEPRECATED
SQLITE_DEPRECATED
int
sqlite3_aggregate_count
sqlite3_context
SQLITE_DEPRECATED
int
sqlite3_expired
sqlite3_stmt
SQLITE_DEPRECATED
int
sqlite3_transfer_bindings
sqlite3_stmt
sqlite3_stmt
SQLITE_DEPRECATED
int
sqlite3_global_recover
void
SQLITE_DEPRECATED
void
sqlite3_thread_cleanup
void
SQLITE_DEPRECATED
int
sqlite3_memory_alarm
void
void
sqlite3_int64
int
void
sqlite3_int64
endif
CAPI3REF
Obtaining
SQL
Values
b
Summary
tr
td
b
sqlite3_value_blob
td
rarr
td
BLOB
value
tr
td
b
sqlite3_value_int
td
rarr
td
bit
INTEGER
value
tr
td
b
sqlite3_value_pointer
td
rarr
td
Pointer
value
tr
td
b
sqlite3_value_text16
td
rarr
td
UTF
TEXT
value
in
tr
td
b
sqlite3_value_text16be
td
rarr
td
UTF
be
TEXT
value
tr
td
nbsp
td
nbsp
td
nbsp
or
a
UTF
TEXT
in
bytes
td
rarr
nbsp
nbsp
td
Size
of
UTF
tr
td
b
sqlite3_value_type
td
rarr
td
Default
tr
td
b
sqlite3_value_numeric_type
nbsp
nbsp
tr
td
b
sqlite3_value_nochange
nbsp
nbsp
against
a
virtual
table
td
rarr
nbsp
nbsp
td
True
if
value
originated
from
a
bound
parameter
b
Details
These
routines
extract
type
size
and
content
information
from
are
used
to
pass
parameter
information
into
the
functions
that
These
routines
work
only
with
protected
sqlite3_value
objects
is
not
threadsafe
These
routines
work
just
like
the
corresponding
column
access
functions
pointer
instead
of
a
sqlite3_stmt
pointer
and
an
integer
column
number
The
sqlite3_value_text16
interface
extracts
a
UTF
string
sqlite3_value_text16be
and
sqlite3_value_text16le
interfaces
If
sqlite3_value
object
V
was
initialized
and
if
X
and
Y
are
strings
that
compare
equal
according
to
strcmp
X
Y
sqlite3_value_pointer
V
Y
returns
a
NULL
The
sqlite3_bind_pointer
The
sqlite3_value_type
V
interface
returns
the
sqlite3_value
object
V
The
returned
value
is
one
of
SQLITE_INTEGER
Other
interfaces
might
change
the
datatype
for
an
sqlite3_value
object
sqlite3_value_text
V
is
called
to
extract
a
text
value
for
that
SQLITE_TEXT
Whether
or
not
a
persistent
internal
datatype
conversion
The
sqlite3_value_numeric_type
interface
attempts
to
apply
made
to
convert
the
value
to
an
integer
or
floating
point
If
words
if
the
value
is
a
string
that
looks
like
a
number
The
SQLITE_INTEGER
datatype
after
conversion
is
returned
The
sqlite3_value_encoding
X
interface
returns
one
of
SQLITE_UTF8
of
the
value
X
assuming
that
X
has
type
TEXT
If
sqlite3_value_type
X
sqlite3_value_encoding
X
is
meaningless
Calls
to
sqlite3_value_text16le
X
sqlite3_value_bytes
X
or
thus
change
the
return
from
subsequent
calls
to
sqlite3_value_encoding
X
Within
the
xUpdate
method
of
a
virtual
table
the
the
column
corresponding
to
X
is
unchanged
by
the
UPDATE
operation
and
the
prior
xColumn
method
call
that
was
invoked
to
extracted
because
it
queried
sqlite3_vtab_nochange
and
found
that
the
column
sqlite3_value_nochange
X
is
true
will
in
all
other
respects
appear
than
within
an
xUpdate
method
call
for
an
UPDATE
statement
then
The
sqlite3_value_frombind
X
interface
returns
non
zero
if
the
interfaces
If
X
comes
from
an
SQL
literal
value
or
a
table
column
Please
pay
particular
attention
to
the
fact
that
the
pointer
returned
sqlite3_value_text16
can
be
invalidated
by
a
subsequent
call
to
or
sqlite3_value_text16
These
routines
must
be
called
from
the
same
thread
as
As
long
as
the
input
parameter
is
correct
these
routines
can
only
Only
the
following
subset
of
interfaces
are
subject
to
out
of
memory
ul
li
sqlite3_value_text
li
sqlite3_value_text16le
li
sqlite3_value_bytes
l
If
an
out
of
memory
error
occurs
then
the
return
value
from
these
Valid
SQL
NULL
returns
can
be
distinguished
from
out
of
memory
errors
return
value
is
obtained
and
before
any
const
void
sqlite3_value_blob
sqlite3_value
double
sqlite3_value_double
sqlite3_value
int
sqlite3_value_int
sqlite3_value
sqlite3_int64
sqlite3_value_int64
sqlite3_value
void
sqlite3_value_pointer
sqlite3_value
const
char
const
unsigned
char
sqlite3_value_text
sqlite3_value
const
void
sqlite3_value_text16
sqlite3_value
const
void
sqlite3_value_text16le
sqlite3_value
const
void
sqlite3_value_text16be
sqlite3_value
int
sqlite3_value_bytes
sqlite3_value
int
sqlite3_value_bytes16
sqlite3_value
int
sqlite3_value_type
sqlite3_value
int
sqlite3_value_numeric_type
sqlite3_value
int
sqlite3_value_nochange
sqlite3_value
int
sqlite3_value_frombind
sqlite3_value
int
sqlite3_value_encoding
sqlite3_value
CAPI3REF
Finding
The
Subtype
Of
SQL
Values
The
sqlite3_value_subtype
V
function
returns
the
subtype
for
information
can
be
used
to
pass
a
limited
amount
of
context
from
routine
to
set
the
subtype
for
the
return
value
of
an
SQL
function
unsigned
int
sqlite3_value_subtype
sqlite3_value
CAPI3REF
Copy
And
Free
SQL
Values
The
sqlite3_value_dup
V
interface
makes
a
copy
of
the
sqlite3_value
is
a
protected
sqlite3_value
object
even
if
the
input
is
not
memory
allocation
fails
If
V
is
a
pointer
value
then
the
result
The
sqlite3_value_free
V
interface
frees
an
sqlite3_value
object
then
sqlite3_value_free
V
is
a
harmless
no
op
sqlite3_value
sqlite3_value_dup
const
sqlite3_value
void
sqlite3_value_free
sqlite3_value
CAPI3REF
Obtain
Aggregate
Function
Context
Implementations
of
aggregate
SQL
functions
use
this
The
first
time
the
sqlite3_aggregate_context
C
N
routine
is
called
N
bytes
of
memory
zeroes
out
that
memory
and
returns
a
pointer
sqlite3_aggregate_context
for
the
same
aggregate
function
instance
called
once
for
each
invocation
of
the
xStep
callback
and
then
one
an
aggregate
query
the
xStep
callback
of
the
aggregate
function
In
those
cases
sqlite3_aggregate_context
might
be
called
for
the
The
sqlite3_aggregate_context
C
N
routine
returns
a
NULL
pointer
allocation
error
occurs
The
amount
of
space
allocated
by
sqlite3_aggregate_context
C
N
is
value
of
N
in
any
subsequent
call
to
sqlite3_aggregate_context
within
allocation
Within
the
xFinal
callback
it
is
customary
to
set
pointless
memory
allocations
occur
SQLite
automatically
frees
the
memory
allocated
by
The
first
parameter
must
be
a
copy
of
the
to
the
xStep
or
xFinal
callback
routine
that
implements
the
aggregate
This
routine
must
be
called
from
the
same
thread
in
which
void
sqlite3_aggregate_context
sqlite3_context
int
nBytes
CAPI3REF
User
Data
For
Functions
The
sqlite3_user_data
interface
returns
a
copy
of
of
the
sqlite3_create_function
registered
the
application
defined
function
This
routine
must
be
called
from
the
same
thread
in
which
void
sqlite3_user_data
sqlite3_context
CAPI3REF
Database
Connection
For
Functions
The
sqlite3_context_db_handle
interface
returns
a
copy
of
of
the
sqlite3_create_function
registered
the
application
defined
function
sqlite3
sqlite3_context_db_handle
sqlite3_context
CAPI3REF
Function
Auxiliary
Data
These
functions
may
be
used
by
non
aggregate
SQL
functions
to
multiple
invocations
of
the
same
SQL
function
during
query
execution
under
of
where
this
might
be
useful
is
in
a
regular
expression
matching
metadata
associated
with
the
pattern
string
the
compiled
regular
expression
can
be
reused
on
multiple
The
sqlite3_get_auxdata
C
N
interface
returns
a
pointer
to
the
metadata
value
to
the
application
defined
function
N
is
zero
for
the
left
most
associated
with
the
function
argument
the
sqlite3_get_auxdata
C
N
interface
The
sqlite3_set_auxdata
C
N
P
X
interface
saves
P
as
metadata
for
the
N
th
calls
to
sqlite3_get_auxdata
C
N
return
P
from
the
most
recent
NULL
if
the
metadata
has
been
discarded
SQLite
will
invoke
the
destructor
function
X
with
parameter
P
exactly
SQLite
is
free
to
discard
the
metadata
at
any
time
including
ul
li
when
sqlite3_reset
or
sqlite3_finalize
is
called
for
the
li
when
sqlite3_set_auxdata
is
invoked
again
on
the
same
li
during
the
original
sqlite3_set_auxdata
call
when
a
memory
Note
the
last
bullet
in
particular
The
destructor
X
in
sqlite3_set_auxdata
interface
even
returns
Hence
sqlite3_set_auxdata
function
implementation
should
not
make
any
use
of
P
after
In
practice
metadata
is
preserved
between
function
calls
for
values
and
parameters
and
expressions
composed
from
the
same
The
value
of
the
N
parameter
to
these
interfaces
should
be
non
negative
kinds
of
function
caching
behavior
These
routines
must
be
called
from
the
same
thread
in
which
void
sqlite3_get_auxdata
sqlite3_context
int
N
void
sqlite3_set_auxdata
sqlite3_context
int
N
void
void
void
CAPI3REF
Constants
Defining
Special
Destructor
Behavior
These
are
special
values
for
the
destructor
that
is
passed
in
as
the
argument
is
SQLITE_STATIC
it
means
that
the
content
pointer
is
constant
SQLITE_TRANSIENT
value
means
that
the
content
will
likely
change
in
the
content
before
returning
The
typedef
is
necessary
to
work
around
problems
in
certain
typedef
void
sqlite3_destructor_type
void
define
SQLITE_STATIC
sqlite3_destructor_type
define
SQLITE_TRANSIENT
sqlite3_destructor_type
CAPI3REF
Setting
The
Result
Of
An
SQL
Function
These
routines
are
used
by
the
xFunc
or
xFinal
callbacks
that
sqlite3_create_function
and
sqlite3_create_function16
These
functions
work
very
much
like
the
parameter
binding
family
of
Refer
to
the
SQL
parameter
documentation
for
additional
information
The
sqlite3_result_blob
interface
sets
the
result
from
to
by
the
second
parameter
and
which
is
N
bytes
long
where
N
is
the
The
sqlite3_result_zeroblob
C
N
and
sqlite3_result_zeroblob64
C
N
a
BLOB
containing
all
zero
bytes
and
N
bytes
in
size
The
sqlite3_result_double
interface
sets
the
result
from
by
its
nd
argument
The
sqlite3_result_error
and
sqlite3_result_error16
functions
SQLite
uses
the
string
pointed
to
by
the
as
the
text
of
an
error
message
SQLite
interprets
the
error
interprets
the
string
from
sqlite3_result_error16
as
UTF
using
If
the
third
parameter
to
sqlite3_result_error
message
all
text
up
through
the
first
zero
character
sqlite3_result_error16
is
non
negative
then
SQLite
takes
that
many
The
sqlite3_result_error
and
sqlite3_result_error16
they
return
Hence
the
calling
function
can
deallocate
or
The
sqlite3_result_error_code
function
changes
the
error
code
the
error
code
is
SQLITE_ERROR
A
subsequent
call
to
sqlite3_result_error
The
sqlite3_result_error_toobig
interface
causes
SQLite
to
throw
an
The
sqlite3_result_error_nomem
interface
causes
SQLite
to
throw
an
The
sqlite3_result_int
interface
sets
the
return
value
value
given
in
the
nd
argument
of
the
application
defined
function
to
be
the
bit
signed
integer
The
sqlite3_result_null
interface
sets
the
return
value
The
sqlite3_result_text
sqlite3_result_text16
set
the
return
value
of
the
application
defined
function
to
be
UTF
little
endian
or
UTF
big
endian
respectively
application
defined
function
to
be
a
text
string
in
an
encoding
of
SQLITE_UTF8
SQLITE_UTF16
SQLITE_UTF16BE
or
SQLITE_UTF16LE
the
nd
parameter
of
the
sqlite3_result_text
interfaces
other
than
sqlite3_result_text64
is
negative
then
SQLite
computes
zero
character
is
non
negative
then
as
many
bytes
not
characters
of
the
text
function
result
If
the
rd
parameter
is
non
negative
then
it
appear
if
the
string
where
NUL
terminated
If
any
NUL
characters
occur
parameter
then
the
resulting
string
will
contain
embedded
NULs
and
the
If
the
th
parameter
to
the
sqlite3_result_text
interfaces
function
as
the
destructor
on
the
text
or
BLOB
result
when
it
has
If
the
th
parameter
to
the
sqlite3_result_text
interfaces
or
to
assumes
that
the
text
or
BLOB
result
is
in
constant
space
and
does
not
when
it
has
finished
using
that
result
or
sqlite3_result_blob
is
the
special
constant
SQLITE_TRANSIENT
from
sqlite3_malloc
before
it
returns
For
the
sqlite3_result_text16
sqlite3_result_text16le
and
when
the
encoding
is
not
UTF8
if
the
input
UTF16
begins
with
a
string
and
the
rest
of
the
string
is
interpreted
according
to
the
the
BOM
at
the
beginning
of
the
text
overrides
the
byte
order
sqlite3_result_text16le
is
invoked
with
text
that
begins
first
two
bytes
of
input
are
skipped
and
the
remaining
input
For
UTF16
input
text
to
the
sqlite3_result_text16
sqlite3_result_text64
routines
if
the
text
contains
invalid
into
the
unicode
replacement
character
U
FFFD
The
sqlite3_result_value
interface
sets
the
result
of
unprotected
sqlite3_value
object
specified
by
the
nd
parameter
The
so
that
the
sqlite3_value
specified
in
the
parameter
may
change
or
A
protected
sqlite3_value
object
may
always
be
used
where
an
kind
of
sqlite3_value
object
can
be
used
with
this
interface
The
sqlite3_result_pointer
C
P
T
D
interface
sets
the
result
to
an
also
associates
the
host
language
pointer
P
or
type
T
with
that
application
defined
SQL
function
using
sqlite3_value_pointer
for
the
P
parameter
SQLite
invokes
D
with
P
as
its
only
argument
string
and
preferably
a
string
literal
The
sqlite3_result_pointer
If
these
routines
are
called
from
within
the
different
thread
the
sqlite3_context
pointer
the
results
are
undefined
void
sqlite3_result_blob
sqlite3_context
const
void
int
void
void
void
sqlite3_result_blob64
sqlite3_context
const
void
sqlite3_uint64
void
void
void
sqlite3_result_double
sqlite3_context
double
void
sqlite3_result_error
sqlite3_context
const
char
int
void
sqlite3_result_error16
sqlite3_context
const
void
int
void
sqlite3_result_error_toobig
sqlite3_context
void
sqlite3_result_error_nomem
sqlite3_context
void
sqlite3_result_error_code
sqlite3_context
int
void
sqlite3_result_int
sqlite3_context
int
void
sqlite3_result_int64
sqlite3_context
sqlite3_int64
void
sqlite3_result_null
sqlite3_context
void
sqlite3_result_text
sqlite3_context
const
char
int
void
void
void
sqlite3_result_text64
sqlite3_context
const
char
sqlite3_uint64
void
void
unsigned
char
encoding
void
sqlite3_result_text16
sqlite3_context
const
void
int
void
void
void
sqlite3_result_text16le
sqlite3_context
const
void
int
void
void
void
sqlite3_result_text16be
sqlite3_context
const
void
int
void
void
void
sqlite3_result_value
sqlite3_context
sqlite3_value
void
sqlite3_result_pointer
sqlite3_context
void
const
char
void
void
void
sqlite3_result_zeroblob
sqlite3_context
int
n
int
sqlite3_result_zeroblob64
sqlite3_context
sqlite3_uint64
n
CAPI3REF
Setting
The
Subtype
Of
An
SQL
Function
The
sqlite3_result_subtype
C
T
function
causes
the
subtype
of
sqlite3_context
C
to
be
the
value
T
Only
the
lower
bits
higher
order
bits
are
discarded
in
future
releases
of
SQLite
void
sqlite3_result_subtype
sqlite3_context
unsigned
int
CAPI3REF
Define
New
Collating
Sequences
These
functions
add
remove
or
modify
a
collation
associated
The
name
of
the
collation
is
a
UTF
string
and
a
UTF
string
in
native
byte
order
for
sqlite3_create_collation16
considered
to
be
the
same
name
The
third
argument
eTextRep
must
be
one
of
the
constants
li
SQLITE_UTF8
li
SQLITE_UTF16BE
li
SQLITE_UTF16_ALIGNED
The
eTextRep
argument
determines
the
encoding
of
strings
passed
The
SQLITE_UTF16
and
SQLITE_UTF16_ALIGNED
values
for
eTextRep
The
SQLITE_UTF16_ALIGNED
value
for
eTextRep
forces
strings
to
begin
The
fourth
argument
pArg
is
an
application
data
pointer
that
is
passed
The
fifth
argument
xCompare
is
a
pointer
to
the
collating
function
with
different
eTextRep
parameters
and
SQLite
will
use
whichever
If
the
xCompare
argument
is
NULL
then
the
collating
function
is
that
collation
is
no
longer
usable
The
collating
function
callback
is
invoked
with
a
copy
of
the
pArg
by
the
eTextRep
argument
The
two
integer
parameters
to
the
collating
function
must
return
an
integer
that
is
negative
zero
or
positive
respectively
A
collating
function
must
always
return
the
same
answer
to
the
same
collation
name
using
different
eTextRep
values
then
all
The
collating
function
must
obey
the
following
properties
for
all
ol
li
If
A
B
and
B
C
then
A
C
li
If
A
lt
B
and
B
lt
C
then
A
lt
C
If
a
collating
function
fails
any
of
the
above
constraints
and
that
is
undefined
The
sqlite3_create_collation_v2
works
like
sqlite3_create_collation
the
collating
function
is
deleted
calls
to
the
collation
creation
functions
or
when
the
The
xDestroy
callback
is
u
not
called
if
the
sqlite3_create_collation_v2
with
a
non
NULL
xDestroy
argument
should
themselves
rather
than
expecting
SQLite
to
deal
with
it
for
them
is
unfortunate
but
cannot
be
changed
without
breaking
backwards
See
also
sqlite3_collation_needed
and
sqlite3_collation_needed16
int
sqlite3_create_collation
sqlite3
const
char
zName
int
eTextRep
void
pArg
int
xCompare
void
int
const
void
int
const
void
int
sqlite3_create_collation_v2
sqlite3
const
char
zName
int
eTextRep
void
pArg
int
xCompare
void
int
const
void
int
const
void
void
xDestroy
void
int
sqlite3_create_collation16
sqlite3
const
void
zName
int
eTextRep
void
pArg
int
xCompare
void
int
const
void
int
const
void
CAPI3REF
Collation
Needed
Callbacks
To
avoid
having
to
register
all
collation
sequences
before
a
database
database
connection
to
be
invoked
whenever
an
undefined
collation
If
the
function
is
registered
using
the
sqlite3_collation_needed
API
encoded
in
UTF
If
sqlite3_collation_needed16
is
used
A
call
to
either
function
replaces
the
existing
collation
needed
callback
When
the
callback
is
invoked
the
first
argument
passed
is
a
copy
sqlite3_collation_needed16
The
second
argument
is
the
database
or
SQLITE_UTF16LE
indicating
the
most
desirable
form
of
the
collation
required
collation
sequence
The
callback
function
should
register
the
desired
collation
using
sqlite3_create_collation_v2
int
sqlite3_collation_needed
sqlite3
void
void
void
sqlite3
int
eTextRep
const
char
int
sqlite3_collation_needed16
sqlite3
void
void
void
sqlite3
int
eTextRep
const
void
ifdef
SQLITE_ENABLE_CEROD
Specify
the
activation
key
for
a
CEROD
database
Unless
void
sqlite3_activate_cerod
const
char
zPassPhrase
endif
CAPI3REF
Suspend
Execution
For
A
Short
Time
The
sqlite3_sleep
function
causes
the
current
thread
to
suspend
execution
If
the
operating
system
does
not
support
sleep
requests
with
the
nearest
second
The
number
of
milliseconds
of
sleep
actually
SQLite
implements
this
interface
by
calling
the
xSleep
of
the
default
VFS
is
not
implemented
correctly
or
not
implemented
at
in
the
previous
paragraphs
int
sqlite3_sleep
int
CAPI3REF
Name
Of
The
Folder
Holding
Temporary
Files
If
this
global
variable
is
made
to
point
to
a
string
which
is
created
by
SQLite
when
using
a
built
in
sqlite3_vfs
VFS
is
a
NULL
pointer
then
SQLite
performs
a
search
for
an
appropriate
Applications
are
strongly
discouraged
from
using
this
global
variable
But
for
all
other
platforms
it
is
highly
recommended
that
applications
that
exists
for
backwards
compatibility
of
legacy
applications
and
should
It
is
not
safe
to
read
or
modify
this
variable
in
more
than
one
if
a
database
connection
is
being
used
at
the
same
time
in
a
separate
It
is
intended
that
this
variable
be
set
once
routines
have
been
called
and
that
this
variable
remain
unchanged
The
temp_store_directory
pragma
may
modify
this
variable
and
cause
the
temp_store_directory
pragma
always
assumes
that
any
string
sqlite3_malloc
and
the
pragma
may
attempt
to
free
that
memory
Hence
if
this
variable
is
modified
directly
either
it
should
be
or
else
the
use
of
the
temp_store_directory
pragma
should
be
avoided
does
not
free
the
memory
that
sqlite3_temp_directory
points
to
If
so
itself
taking
care
to
only
do
so
after
all
database
connection
b
Note
to
Windows
Runtime
users
The
temporary
directory
must
be
set
features
that
require
the
use
of
temporary
files
may
fail
Here
is
an
blockquote
pre
nbsp
TemporaryFolder
Path
Data
memset
zPathBuf
sizeof
zPathBuf
nbsp
NULL
NULL
re
lockquote
SQLITE_EXTERN
char
sqlite3_temp_directory
CAPI3REF
Name
Of
The
Folder
Holding
Database
Files
If
this
global
variable
is
made
to
point
to
a
string
which
is
specified
with
a
relative
pathname
and
created
or
accessed
by
to
be
relative
to
that
directory
If
this
variable
is
a
NULL
with
a
relative
pathname
are
relative
to
the
current
directory
variable
it
is
ignored
by
the
unix
VFS
Changing
the
value
of
this
variable
while
a
database
connection
is
It
is
not
safe
to
read
or
modify
this
variable
in
more
than
one
if
a
database
connection
is
being
used
at
the
same
time
in
a
separate
It
is
intended
that
this
variable
be
set
once
routines
have
been
called
and
that
this
variable
remain
unchanged
The
data_store_directory
pragma
may
modify
this
variable
and
cause
the
data_store_directory
pragma
always
assumes
that
any
string
sqlite3_malloc
and
the
pragma
may
attempt
to
free
that
memory
Hence
if
this
variable
is
modified
directly
either
it
should
be
or
else
the
use
of
the
data_store_directory
pragma
should
be
avoided
SQLITE_EXTERN
char
sqlite3_data_directory
CAPI3REF
Win32
Specific
Interface
These
interfaces
are
available
only
on
Windows
The
with
the
sqlite3_temp_directory
or
sqlite3_data_directory
variable
to
should
be
NULL
to
cause
the
previous
value
to
be
freed
via
sqlite3_free
prior
to
being
used
The
sqlite3_win32_set_directory
interface
returns
or
SQLITE_NOMEM
if
memory
could
not
be
allocated
The
value
of
the
the
current
directory
on
the
sub
platforms
of
Win32
where
that
concept
is
sqlite3_win32_set_directory16
interfaces
behave
exactly
the
same
as
the
UTF
or
UTF
respectively
int
sqlite3_win32_set_directory
unsigned
long
type
void
zValue
int
sqlite3_win32_set_directory8
unsigned
long
type
const
char
zValue
int
sqlite3_win32_set_directory16
unsigned
long
type
const
void
zValue
CAPI3REF
Win32
Directory
Types
These
macros
are
only
available
on
Windows
They
define
the
allowed
values
define
SQLITE_WIN32_DATA_DIRECTORY_TYPE
define
SQLITE_WIN32_TEMP_DIRECTORY_TYPE
CAPI3REF
Test
For
Auto
Commit
Mode
METHOD
sqlite3
The
sqlite3_get_autocommit
interface
returns
non
zero
or
respectively
Autocommit
mode
is
on
by
default
Autocommit
mode
is
re
enabled
by
a
COMMIT
or
ROLLBACK
If
certain
kinds
of
errors
occur
on
a
statement
within
a
multi
statement
SQLITE_NOMEM
SQLITE_BUSY
and
SQLITE_INTERRUPT
then
the
find
out
whether
SQLite
automatically
rolled
back
the
transaction
after
If
another
thread
changes
the
autocommit
status
of
the
database
is
undefined
int
sqlite3_get_autocommit
sqlite3
CAPI3REF
Find
The
Database
Handle
Of
A
Prepared
Statement
The
sqlite3_db_handle
interface
returns
the
database
connection
handle
returned
by
sqlite3_db_handle
is
the
same
database
connection
to
the
sqlite3_prepare_v2
call
or
its
variants
that
was
used
to
sqlite3
sqlite3_db_handle
sqlite3_stmt
CAPI3REF
Return
The
Schema
Name
For
A
Database
Connection
The
sqlite3_db_name
D
N
interface
returns
a
pointer
to
the
schema
name
out
of
range
An
N
value
of
means
the
main
database
file
An
N
of
is
databases
Space
to
hold
the
string
that
is
returned
by
sqlite3_db_name
is
managed
changes
the
schema
including
ATTACH
or
DETACH
or
calls
to
occur
on
a
different
thread
Applications
that
need
to
are
accessing
the
same
database
connection
simultaneously
on
multiple
private
copy
of
the
result
prior
to
releasing
the
mutex
const
char
sqlite3_db_name
sqlite3
db
int
N
CAPI3REF
Return
The
Filename
For
A
Database
Connection
The
sqlite3_db_filename
D
N
interface
returns
a
pointer
to
the
filename
If
there
is
no
attached
database
N
on
the
database
this
function
will
return
either
a
NULL
pointer
or
an
empty
string
The
string
value
returned
by
this
routine
is
owned
and
managed
by
is
DETACH
ed
or
until
the
database
connection
closes
The
filename
returned
by
this
function
is
the
output
of
the
will
be
an
absolute
pathname
even
if
the
filename
used
If
the
filename
pointer
returned
by
this
routine
is
not
NULL
then
it
ul
li
sqlite3_uri_boolean
li
sqlite3_filename_database
li
sqlite3_filename_wal
sqlite3_filename
sqlite3_db_filename
sqlite3
db
const
char
zDbName
CAPI3REF
Determine
if
a
database
is
read
only
The
sqlite3_db_readonly
D
N
interface
returns
if
the
database
N
the
name
of
a
database
on
connection
D
int
sqlite3_db_readonly
sqlite3
db
const
char
zDbName
CAPI3REF
Determine
the
transaction
state
of
a
database
The
sqlite3_txn_state
D
S
interface
returns
the
current
then
the
highest
transaction
state
of
any
schema
on
database
connection
D
ol
li
value
SQLITE_TXN_READ
l
a
valid
schema
then
is
returned
int
sqlite3_txn_state
sqlite3
const
char
zSchema
CAPI3REF
Allowed
return
values
from
sqlite3_txn_state
These
constants
define
the
current
transaction
state
of
a
database
file
constants
in
order
to
describe
the
transaction
state
of
schema
S
dl
dd
The
SQLITE_TXN_NONE
state
means
that
no
transaction
is
currently
SQLITE_TXN_READ
dt
SQLITE_TXN_READ
t
in
a
read
transaction
Content
has
been
read
from
the
database
file
will
advanced
to
SQLITE_TXN_WRITE
if
any
changes
occur
and
there
are
state
will
revert
to
SQLITE_TXN_NONE
following
a
ROLLBACK
or
SQLITE_TXN_WRITE
dt
SQLITE_TXN_WRITE
t
in
a
write
transaction
Content
has
been
written
to
the
database
file
to
SQLITE_TXN_NONE
at
the
next
ROLLBACK
or
COMMIT
d
define
SQLITE_TXN_NONE
define
SQLITE_TXN_READ
define
SQLITE_TXN_WRITE
CAPI3REF
Find
the
next
prepared
statement
This
interface
returns
a
pointer
to
the
next
prepared
statement
after
then
this
interface
returns
a
pointer
to
the
first
prepared
statement
satisfies
the
conditions
of
this
routine
it
returns
NULL
The
database
connection
pointer
D
in
a
call
to
connection
and
in
particular
must
not
be
a
NULL
pointer
sqlite3_stmt
sqlite3_next_stmt
sqlite3
pDb
sqlite3_stmt
pStmt
CAPI3REF
Commit
And
Rollback
Notification
Callbacks
The
sqlite3_commit_hook
interface
registers
a
callback
Any
callback
set
by
a
previous
call
to
sqlite3_commit_hook
The
sqlite3_rollback_hook
interface
registers
a
callback
Any
callback
set
by
a
previous
call
to
sqlite3_rollback_hook
The
pArg
argument
is
passed
through
to
the
callback
then
the
commit
is
converted
into
a
rollback
The
sqlite3_commit_hook
D
C
P
and
sqlite3_rollback_hook
D
C
P
functions
on
the
same
database
connection
D
or
NULL
for
The
commit
and
rollback
hook
callbacks
are
not
reentrant
the
database
connection
that
invoked
the
callback
Any
actions
completion
of
the
sqlite3_step
call
that
triggered
the
commit
Note
that
running
any
other
SQL
statements
including
SELECT
statements
the
database
connections
for
the
meaning
of
in
this
paragraph
Registering
a
NULL
function
disables
the
callback
When
the
commit
hook
callback
routine
returns
zero
the
COMMIT
returns
non
zero
then
the
COMMIT
is
converted
into
a
ROLLBACK
hook
returning
non
zero
just
as
it
would
be
with
any
other
rollback
For
the
purposes
of
this
API
a
transaction
is
said
to
have
been
an
error
or
constraint
causes
an
implicit
rollback
to
occur
automatically
rolled
back
because
the
database
connection
is
closed
See
also
the
sqlite3_update_hook
interface
void
sqlite3_commit_hook
sqlite3
int
void
void
void
sqlite3_rollback_hook
sqlite3
void
void
void
CAPI3REF
Autovacuum
Compaction
Amount
Callback
The
sqlite3_autovacuum_pages
D
C
P
X
interface
registers
a
callback
file
The
callback
is
passed
a
copy
of
the
generic
data
pointer
P
the
size
of
the
database
file
in
pages
the
number
of
free
pages
return
the
number
of
free
pages
that
should
be
removed
by
the
If
the
value
returned
is
greater
than
or
equal
to
the
number
of
p
If
there
are
multiple
ATTACH
ed
database
files
that
are
being
callback
is
invoked
separately
for
each
file
p
b
The
callback
is
not
reentrant
The
callback
function
should
things
may
happen
including
segmentation
faults
and
corrupt
database
does
some
arithmetic
on
its
input
parameters
and
returns
a
result
The
X
parameter
to
sqlite3_autovacuum_pages
D
C
P
X
is
an
optional
invoked
whenever
the
database
connection
closes
or
when
the
callback
p
There
is
only
one
autovacuum
pages
callback
per
database
connection
previous
invocations
for
that
database
connection
If
the
callback
then
the
autovacuum
steps
callback
is
cancelled
The
return
value
be
some
other
error
code
if
something
goes
wrong
The
current
return
codes
might
be
added
in
future
releases
p
If
no
autovacuum
pages
callback
is
specified
the
usual
case
or
then
the
default
behavior
is
to
vacuum
all
free
pages
So
in
other
were
something
like
this
blockquote
pre
nbsp
void
pClientData
nbsp
unsigned
int
nDbPage
nbsp
unsigned
int
nBytePerPage
nbsp
return
nFreePage
re
lockquote
int
sqlite3_autovacuum_pages
sqlite3
db
unsigned
int
void
const
char
unsigned
int
unsigned
int
unsigned
int
void
void
void
CAPI3REF
Data
Change
Notification
Callbacks
The
sqlite3_update_hook
interface
registers
a
callback
function
to
be
invoked
whenever
a
row
is
updated
inserted
or
deleted
in
Any
callback
set
by
a
previous
call
to
this
function
The
second
argument
is
a
pointer
to
the
function
to
invoke
when
a
The
first
argument
to
the
callback
is
a
copy
of
the
third
argument
The
second
callback
argument
is
one
of
SQLITE_INSERT
SQLITE_DELETE
to
be
invoked
database
and
table
name
containing
the
affected
row
In
the
case
of
an
update
this
is
the
rowid
after
the
update
takes
place
The
update
hook
is
not
invoked
when
internal
system
tables
are
The
update
hook
is
not
invoked
when
WITHOUT
ROWID
tables
are
modified
In
the
current
implementation
the
update
hook
ON
CONFLICT
ON
CONFLICT
REPLACE
clause
Nor
is
the
update
hook
The
exceptions
defined
in
this
paragraph
might
change
in
a
future
The
update
hook
implementation
must
not
do
anything
that
will
modify
to
modify
the
database
connection
must
be
deferred
until
after
the
Note
that
sqlite3_prepare_v2
and
sqlite3_step
both
modify
their
The
sqlite3_update_hook
D
C
P
function
on
the
same
database
connection
D
or
NULL
for
See
also
the
sqlite3_commit_hook
sqlite3_rollback_hook
void
sqlite3_update_hook
sqlite3
void
void
int
char
const
char
const
sqlite3_int64
void
CAPI3REF
Enable
Or
Disable
Shared
Pager
Cache
This
routine
enables
or
disables
the
sharing
of
the
database
cache
to
the
same
database
Sharing
is
enabled
if
the
argument
is
true
This
interface
is
omitted
if
SQLite
is
compiled
with
compile
time
option
is
recommended
because
the
Cache
sharing
is
enabled
and
disabled
for
an
entire
process
In
prior
versions
of
SQLite
The
cache
sharing
mode
set
by
this
interface
effects
all
subsequent
Existing
database
connections
continue
to
use
the
sharing
mode
This
routine
returns
SQLITE_OK
if
shared
cache
was
enabled
or
disabled
Shared
cache
is
disabled
by
default
It
is
recommended
that
it
stay
continues
to
be
provided
for
historical
compatibility
but
its
use
is
must
be
used
it
is
recommended
that
shared
cache
only
be
enabled
for
with
the
SQLITE_OPEN_SHAREDCACHE
flag
Note
This
method
is
disabled
on
MacOS
X
and
iOS
version
shared
cache
mode
should
be
enabled
per
database
connection
via
This
interface
is
threadsafe
on
processors
where
writing
a
See
Also
SQLite
Shared
Cache
Mode
int
sqlite3_enable_shared_cache
int
CAPI3REF
Attempt
To
Free
Heap
Memory
The
sqlite3_release_memory
interface
attempts
to
free
N
bytes
held
by
the
database
library
Memory
used
to
cache
database
sqlite3_release_memory
returns
the
number
of
bytes
actually
freed
The
sqlite3_release_memory
routine
is
a
no
op
returning
zero
See
also
sqlite3_db_release_memory
int
sqlite3_release_memory
int
CAPI3REF
Free
Memory
Used
By
A
Database
Connection
The
sqlite3_db_release_memory
D
interface
attempts
to
free
as
much
heap
sqlite3_release_memory
interface
this
interface
is
in
effect
even
omitted
See
also
sqlite3_release_memory
int
sqlite3_db_release_memory
sqlite3
CAPI3REF
Impose
A
Limit
On
Heap
Size
These
interfaces
impose
limits
on
the
amount
of
heap
memory
that
will
be
The
sqlite3_soft_heap_limit64
interface
sets
and
r
queries
the
SQLite
strives
to
keep
heap
memory
utilization
below
the
soft
heap
as
heap
memory
usages
approaches
the
limit
below
the
limit
it
will
exceed
the
limit
rather
than
generate
is
advisory
only
The
sqlite3_hard_heap_limit64
N
interface
sets
a
hard
upper
bound
of
sqlite3_hard_heap_limit64
N
interface
is
similar
to
when
the
hard
heap
limit
is
reached
The
return
value
from
both
sqlite3_soft_heap_limit64
and
the
heap
limit
prior
to
the
call
or
negative
in
the
case
of
an
then
no
change
is
made
to
the
heap
limit
Hence
the
current
sqlite3_soft_heap_limit64
or
sqlite3_hard_heap_limit
Setting
the
heap
limits
to
zero
disables
the
heap
limiter
mechanism
The
soft
heap
limit
may
not
be
greater
than
the
hard
heap
limit
is
invoked
with
a
value
of
N
that
is
greater
than
the
hard
heap
limit
The
soft
heap
limit
is
automatically
enabled
whenever
the
hard
heap
the
soft
heap
limit
is
outside
the
range
of
N
then
the
soft
heap
hard
heap
limit
is
enabled
makes
the
soft
heap
limit
equal
to
the
The
memory
allocation
limits
can
also
be
adjusted
using
The
heap
limits
are
not
enforced
in
the
current
implementation
ul
li
Memory
accounting
is
disabled
using
a
combination
of
the
the
SQLITE_DEFAULT_MEMSTATUS
compile
time
option
sqlite3_config
SQLITE_CONFIG_PCACHE2
by
sqlite3_config
SQLITE_CONFIG_PAGECACHE
rather
than
l
The
circumstances
under
which
SQLite
will
enforce
the
heap
limits
may
sqlite3_int64
sqlite3_soft_heap_limit64
sqlite3_int64
N
sqlite3_int64
sqlite3_hard_heap_limit64
sqlite3_int64
N
CAPI3REF
Deprecated
Soft
Heap
Limit
Interface
This
is
a
deprecated
version
of
the
sqlite3_soft_heap_limit64
only
All
new
applications
should
use
the
SQLITE_DEPRECATED
void
sqlite3_soft_heap_limit
int
N
CAPI3REF
Extract
Metadata
About
A
Column
Of
A
Table
The
sqlite3_table_column_metadata
X
D
T
C
routine
returns
on
database
connection
X
The
sqlite3_table_column_metadata
the
final
five
arguments
with
appropriate
values
if
the
specified
SQLITE_ERROR
if
the
specified
column
does
not
exist
NULL
pointer
then
this
routine
simply
checks
for
the
existence
of
the
does
not
If
the
table
name
parameter
T
in
a
call
to
undefined
behavior
The
column
is
identified
by
the
second
third
and
fourth
parameters
to
i
e
or
an
attached
database
containing
the
specified
for
the
table
using
the
same
algorithm
used
by
the
database
engine
to
The
third
and
fourth
parameters
to
this
function
are
the
table
and
column
Metadata
is
returned
by
writing
to
the
memory
locations
passed
as
the
th
NULL
in
which
case
the
corresponding
element
of
metadata
is
omitted
blockquote
tr
th
Parameter
th
Output
br
Type
th
Description
tr
td
th
td
const
char
td
Data
type
tr
td
th
td
int
td
True
if
column
has
a
NOT
NULL
constraint
tr
td
th
td
int
td
True
if
column
is
AUTOINCREMENT
lockquote
The
memory
pointed
to
by
the
character
pointers
returned
for
the
call
to
any
SQLite
API
function
If
the
specified
table
is
actually
a
view
an
error
code
is
returned
If
the
specified
column
is
or
and
the
table
INTEGER
PRIMARY
KEY
column
has
been
explicitly
declared
then
the
output
INTEGER
PRIMARY
KEY
column
then
the
outputs
pre
collation
sequence
primary
key
re
This
function
causes
all
database
schemas
to
be
read
from
disk
and
any
errors
are
encountered
while
loading
the
schema
int
sqlite3_table_column_metadata
sqlite3
db
const
char
zDbName
const
char
zTableName
const
char
zColumnName
char
const
pzDataType
char
const
pzCollSeq
int
pNotNull
int
pPrimaryKey
int
pAutoinc
CAPI3REF
Load
An
Extension
This
interface
loads
an
SQLite
extension
library
from
the
named
file
The
sqlite3_load_extension
interface
attempts
to
load
an
the
file
cannot
be
loaded
directly
attempts
are
made
to
load
So
for
example
if
cannot
be
loaded
then
names
like
be
tried
also
The
entry
point
is
zProc
entry
point
name
on
its
own
It
first
tries
X
is
consists
of
the
lower
case
equivalent
of
all
ASCII
alphabetic
and
omitting
any
initial
SQLITE_OK
on
success
and
SQLITE_ERROR
if
something
goes
wrong
sqlite3_load_extension
interface
shall
attempt
to
obtained
from
sqlite3_malloc
The
calling
function
Extension
loading
must
be
enabled
using
sqlite3_db_config
db
SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION
NULL
otherwise
an
error
will
be
returned
b
Security
warning
It
is
recommended
that
the
interface
The
use
of
the
sqlite3_enable_load_extension
interface
disabled
and
prevent
SQL
injections
from
giving
attackers
See
also
the
load_extension
SQL
function
int
sqlite3_load_extension
sqlite3
db
const
char
zFile
const
char
zProc
char
pzErrMsg
CAPI3REF
Enable
Or
Disable
Extension
Loading
So
as
not
to
open
security
holes
in
older
applications
that
are
extension
loading
while
evaluating
user
entered
SQL
the
following
API
Extension
loading
is
off
by
default
to
turn
extension
loading
on
and
call
it
with
onoff
to
turn
This
interface
enables
or
disables
both
the
C
API
Use
sqlite3_db_config
db
SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION
b
Security
warning
It
is
recommended
that
extension
loading
rather
than
this
interface
so
the
load_extension
SQL
function
access
to
extension
loading
capabilities
int
sqlite3_enable_load_extension
sqlite3
db
int
onoff
CAPI3REF
Automatically
Load
Statically
Linked
Extensions
This
interface
causes
the
xEntryPoint
function
to
be
invoked
for
xEntryPoint
is
the
entry
point
for
a
statically
linked
SQLite
extension
Even
though
the
function
prototype
shows
that
xEntryPoint
takes
arguments
and
expects
an
integer
result
as
if
the
signature
of
the
blockquote
pre
nbsp
sqlite3
db
nbsp
const
struct
sqlite3_api_routines
pThunk
re
lockquote
If
the
xEntryPoint
routine
encounters
an
error
it
should
make
pzErrMsg
and
return
an
appropriate
error
code
SQLite
ensures
that
pzErrMsg
sqlite3_free
on
pzErrMsg
after
xEntryPoint
returns
If
any
or
sqlite3_open_v2
call
that
provoked
the
xEntryPoint
will
fail
Calling
sqlite3_auto_extension
X
with
an
entry
point
X
that
is
already
will
be
called
more
than
once
for
each
database
connection
that
is
opened
See
also
sqlite3_reset_auto_extension
int
sqlite3_auto_extension
void
xEntryPoint
void
CAPI3REF
Cancel
Automatic
Extension
Loading
The
sqlite3_cancel_auto_extension
X
interface
unregisters
the
sqlite3_auto_extension
X
The
sqlite3_cancel_auto_extension
X
unregistered
and
it
returns
if
X
was
not
on
the
list
of
initialization
int
sqlite3_cancel_auto_extension
void
xEntryPoint
void
CAPI3REF
Reset
Automatic
Extension
Loading
This
interface
disables
all
automatic
extensions
previously
void
sqlite3_reset_auto_extension
void
The
interface
to
the
virtual
table
mechanism
is
currently
considered
If
this
is
a
problem
for
you
do
not
use
the
interface
at
this
time
When
the
virtual
table
mechanism
stabilizes
we
will
declare
the
Structures
used
by
the
virtual
table
interface
typedef
struct
sqlite3_vtab
sqlite3_vtab
typedef
struct
sqlite3_index_info
sqlite3_index_info
typedef
struct
sqlite3_vtab_cursor
sqlite3_vtab_cursor
typedef
struct
sqlite3_module
sqlite3_module
CAPI3REF
Virtual
Table
Object
This
structure
sometimes
called
a
This
structure
consists
mostly
of
methods
for
the
module
A
virtual
table
module
is
created
by
filling
in
a
persistent
to
sqlite3_create_module
or
sqlite3_create_module_v2
module
or
until
the
database
connection
closes
The
content
any
database
connection
struct
sqlite3_module
int
iVersion
int
xCreate
sqlite3
void
pAux
int
argc
const
char
const
argv
sqlite3_vtab
ppVTab
char
int
xConnect
sqlite3
void
pAux
int
argc
const
char
const
argv
sqlite3_vtab
ppVTab
char
int
xBestIndex
sqlite3_vtab
pVTab
sqlite3_index_info
int
xDisconnect
sqlite3_vtab
pVTab
int
xDestroy
sqlite3_vtab
pVTab
int
xOpen
sqlite3_vtab
pVTab
sqlite3_vtab_cursor
ppCursor
int
xClose
sqlite3_vtab_cursor
int
xFilter
sqlite3_vtab_cursor
int
idxNum
const
char
idxStr
int
argc
sqlite3_value
argv
int
xNext
sqlite3_vtab_cursor
int
xEof
sqlite3_vtab_cursor
int
xColumn
sqlite3_vtab_cursor
sqlite3_context
int
int
xRowid
sqlite3_vtab_cursor
sqlite3_int64
pRowid
int
xUpdate
sqlite3_vtab
int
sqlite3_value
sqlite3_int64
int
xBegin
sqlite3_vtab
pVTab
int
xSync
sqlite3_vtab
pVTab
int
xCommit
sqlite3_vtab
pVTab
int
xRollback
sqlite3_vtab
pVTab
int
xFindFunction
sqlite3_vtab
pVtab
int
nArg
const
char
zName
void
pxFunc
sqlite3_context
int
sqlite3_value
void
ppArg
int
xRename
sqlite3_vtab
pVtab
const
char
zNew
below
are
for
version
and
greater
int
xSavepoint
sqlite3_vtab
pVTab
int
int
xRelease
sqlite3_vtab
pVTab
int
int
xRollbackTo
sqlite3_vtab
pVTab
int
Those
below
are
for
version
and
greater
int
xShadowName
const
char
CAPI3REF
Virtual
Table
Indexing
Information
The
sqlite3_index_info
structure
and
its
substructures
is
used
as
part
pass
information
into
and
receive
the
reply
from
the
xBestIndex
inputs
to
xBestIndex
and
are
read
only
xBestIndex
inserts
its
The
aConstraint
array
records
WHERE
clause
constraints
of
the
form
blockquote
column
OP
expr
lockquote
where
OP
is
lt
lt
gt
or
gt
The
particular
operator
is
SQLITE_INDEX_CONSTRAINT_EQ
SQLITE_INDEX_CONSTRAINT_
values
aConstraint
iColumn
aConstraint
usable
is
TRUE
if
the
is
usable
and
false
if
it
cannot
The
optimizer
automatically
inverts
terms
of
the
form
get
as
many
WHERE
clause
terms
into
the
form
shown
above
as
possible
relevant
to
the
particular
virtual
table
being
queried
Information
about
the
ORDER
BY
clause
is
stored
in
aOrderBy
The
colUsed
field
indicates
which
columns
of
the
virtual
table
may
be
zero
in
the
order
in
which
they
appear
within
the
CREATE
TABLE
statement
the
corresponding
bit
is
set
within
the
colUsed
mask
if
the
column
may
be
to
the
right
of
the
first
is
required
then
bit
of
colUsed
is
also
colUsed
sqlite3_uint64
iCol
iCol
evaluates
to
The
xBestIndex
method
must
fill
aConstraintUsage
with
information
the
right
hand
side
of
the
corresponding
aConstraint
is
evaluated
is
true
then
the
constraint
is
assumed
to
be
fully
handled
by
the
aConstraintUsage
omit
flag
is
an
optimization
hint
When
the
omit
flag
checked
separately
in
byte
code
If
the
omit
flag
is
change
to
true
then
when
the
omit
flag
is
true
there
is
no
guarantee
that
the
constraint
will
The
idxNum
and
idxPtr
values
are
recorded
and
passed
into
the
sqlite3_free
is
used
to
free
idxPtr
if
and
only
if
The
orderByConsumed
means
that
output
from
xFilter
xNext
will
occur
in
sorting
step
is
required
The
estimatedCost
value
is
an
estimate
of
the
cost
of
a
particular
to
a
linear
scan
of
an
SQLite
table
with
N
rows
A
cost
of
log
N
binary
search
on
a
unique
indexed
field
of
an
SQLite
table
with
N
rows
The
estimatedRows
value
is
an
estimate
of
the
number
of
rows
that
The
xBestIndex
method
may
optionally
populate
the
idxFlags
field
with
a
SQLITE_INDEX_SCAN_UNIQUE
If
the
xBestIndex
method
sets
this
flag
SQLite
Additionally
if
xBestIndex
sets
the
SQLITE_INDEX_SCAN_UNIQUE
flag
then
part
of
the
same
statement
to
delete
or
update
a
virtual
table
row
and
the
any
database
changes
In
other
words
if
the
xUpdate
returns
before
xUpdate
was
called
By
contrast
if
SQLITE_INDEX_SCAN_UNIQUE
is
not
the
xUpdate
method
are
automatically
rolled
back
by
SQLite
IMPORTANT
The
estimatedRows
field
was
added
to
the
sqlite3_index_info
If
a
virtual
table
extension
is
to
read
or
write
the
estimatedRows
field
are
undefined
but
are
likely
therefore
only
be
used
if
sqlite3_libversion_number
returns
a
was
added
for
version
dateof
sqlite3_libversion_number
returns
a
value
greater
than
or
equal
to
struct
sqlite3_index_info
int
nConstraint
struct
sqlite3_index_constraint
int
iColumn
unsigned
char
op
unsigned
char
usable
int
iTermOffset
aConstraint
int
nOrderBy
struct
sqlite3_index_orderby
int
iColumn
unsigned
char
desc
aOrderBy
struct
sqlite3_index_constraint_usage
int
argvIndex
unsigned
char
omit
aConstraintUsage
int
idxNum
char
idxStr
int
needToFreeIdxStr
int
orderByConsumed
double
estimatedCost
sqlite3_int64
estimatedRows
int
idxFlags
sqlite3_uint64
colUsed
CAPI3REF
Virtual
Table
Scan
Flags
Virtual
table
implementations
are
allowed
to
set
the
these
bits
define
SQLITE_INDEX_SCAN_UNIQUE
CAPI3REF
Virtual
Table
Constraint
Operator
Codes
These
macros
define
the
allowed
values
for
the
an
operator
that
is
part
of
a
constraint
term
in
the
WHERE
clause
of
The
left
hand
operand
of
the
operator
is
given
by
the
corresponding
operand
is
the
rowid
operators
have
no
left
hand
operand
and
so
for
those
operators
the
used
All
operator
values
from
SQLITE_INDEX_CONSTRAINT_FUNCTION
through
by
the
xFindFunction
xFindFunction
method
of
the
virtual
table
The
right
hand
operands
for
each
constraint
might
be
accessible
using
operand
is
only
available
if
it
appears
as
a
single
constant
literal
expression
even
a
constant
expression
or
a
parameter
then
the
The
SQLITE_INDEX_CONSTRAINT_ISNULL
and
and
hence
calls
to
sqlite3_vtab_rhs_value
for
those
operators
will
The
collating
sequence
to
be
used
for
comparison
can
be
found
using
tables
the
collating
sequence
of
constraints
does
not
matter
for
example
interface
is
no
commonly
needed
define
SQLITE_INDEX_CONSTRAINT_EQ
define
SQLITE_INDEX_CONSTRAINT_GT
define
SQLITE_INDEX_CONSTRAINT_LE
define
SQLITE_INDEX_CONSTRAINT_LT
define
SQLITE_INDEX_CONSTRAINT_GE
define
SQLITE_INDEX_CONSTRAINT_MATCH
define
SQLITE_INDEX_CONSTRAINT_LIKE
define
SQLITE_INDEX_CONSTRAINT_GLOB
define
SQLITE_INDEX_CONSTRAINT_REGEXP
define
SQLITE_INDEX_CONSTRAINT_NE
define
SQLITE_INDEX_CONSTRAINT_ISNOT
define
SQLITE_INDEX_CONSTRAINT_ISNOTNULL
define
SQLITE_INDEX_CONSTRAINT_ISNULL
define
SQLITE_INDEX_CONSTRAINT_IS
define
SQLITE_INDEX_CONSTRAINT_LIMIT
define
SQLITE_INDEX_CONSTRAINT_OFFSET
define
SQLITE_INDEX_CONSTRAINT_FUNCTION
CAPI3REF
Register
A
Virtual
Table
Implementation
These
routines
are
used
to
register
a
new
virtual
table
module
name
creating
a
new
virtual
table
using
the
module
and
before
using
a
The
module
name
is
registered
on
the
database
connection
specified
second
parameter
The
third
parameter
is
a
pointer
to
parameter
is
an
arbitrary
client
data
pointer
that
is
passed
through
when
a
new
virtual
table
is
be
being
created
or
reinitialized
The
sqlite3_create_module_v2
interface
has
a
fifth
parameter
which
invoke
the
destructor
function
if
it
is
not
NULL
when
SQLite
be
invoked
if
the
call
to
sqlite3_create_module_v2
fails
interface
is
equivalent
to
sqlite3_create_module_v2
with
a
NULL
If
the
third
parameter
the
pointer
to
the
sqlite3_module
object
is
same
name
are
dropped
See
also
sqlite3_drop_modules
int
sqlite3_create_module
sqlite3
db
const
char
zName
const
sqlite3_module
p
void
pClientData
int
sqlite3_create_module_v2
sqlite3
db
const
char
zName
const
sqlite3_module
p
void
pClientData
void
xDestroy
void
CAPI3REF
Remove
Unnecessary
Virtual
Table
Implementations
The
sqlite3_drop_modules
D
L
interface
removes
all
virtual
The
L
parameter
must
be
either
NULL
or
a
pointer
to
an
array
of
pointers
If
the
L
parameter
is
NULL
then
all
virtual
table
modules
are
removed
See
also
sqlite3_create_module
int
sqlite3_drop_modules
sqlite3
db
const
char
azKeep
CAPI3REF
Virtual
Table
Instance
Object
Every
virtual
table
module
implementation
uses
a
subclass
of
the
virtual
table
Each
subclass
will
The
purpose
of
this
superclass
is
to
define
certain
fields
that
are
Virtual
tables
methods
can
set
an
error
message
by
assigning
a
take
care
that
any
prior
string
is
freed
by
a
call
to
sqlite3_free
is
delivered
up
to
the
client
application
the
string
will
be
automatically
struct
sqlite3_vtab
const
sqlite3_module
pModule
int
nRef
char
zErrMsg
CAPI3REF
Virtual
Table
Cursor
Object
Every
virtual
table
module
implementation
uses
a
subclass
of
the
virtual
table
and
are
used
sqlite3_module
xOpen
xOpen
method
of
the
module
and
are
destroyed
by
the
xFilter
xNext
xEof
xColumn
and
xRowid
methods
the
content
of
a
cursor
structure
to
suit
its
own
needs
This
superclass
exists
in
order
to
define
fields
of
the
cursor
that
struct
sqlite3_vtab_cursor
sqlite3_vtab
pVtab
CAPI3REF
Declare
The
Schema
Of
A
Virtual
Table
The
xCreate
and
xConnect
methods
of
a
to
declare
the
format
the
names
and
datatypes
of
the
columns
of
int
sqlite3_declare_vtab
sqlite3
const
char
zSQL
CAPI3REF
Overload
A
Function
For
A
Virtual
Table
Virtual
tables
can
provide
alternative
implementations
of
functions
But
global
versions
of
those
functions
This
API
makes
sure
a
global
version
of
a
function
with
a
particular
before
this
API
is
called
a
new
function
is
created
The
implementation
the
new
function
is
not
good
for
anything
by
itself
Its
only
by
a
virtual
table
int
sqlite3_overload_function
sqlite3
const
char
zFuncName
int
nArg
The
interface
to
the
virtual
table
mechanism
defined
above
back
up
to
be
experimental
The
interface
might
change
in
incompatible
ways
When
the
virtual
table
mechanism
stabilizes
we
will
declare
the
CAPI3REF
A
Handle
To
An
Open
BLOB
An
instance
of
this
object
represents
an
open
BLOB
on
which
Objects
of
this
type
are
created
by
sqlite3_blob_open
The
sqlite3_blob_read
and
sqlite3_blob_write
interfaces
The
sqlite3_blob_bytes
interface
returns
the
size
of
the
BLOB
in
bytes
typedef
struct
sqlite3_blob
sqlite3_blob
CAPI3REF
Open
A
BLOB
For
Incremental
I
CONSTRUCTOR
sqlite3_blob
This
interfaces
opens
a
BLOB
handle
handle
to
the
BLOB
located
in
other
words
the
same
BLOB
that
would
be
selected
by
pre
re
Parameter
zDb
is
not
the
filename
that
contains
the
database
but
the
name
that
appears
after
the
AS
keyword
in
the
ATTACH
statement
tables
the
database
name
is
If
the
flags
parameter
is
non
zero
then
the
BLOB
is
opened
for
read
read
only
access
On
success
SQLITE_OK
is
returned
and
the
new
BLOB
handle
is
stored
code
is
SQLITE_MISUSE
ppBlob
is
set
to
NULL
This
means
that
provided
on
ppBlob
after
this
function
it
returns
This
function
fails
with
SQLITE_ERROR
if
any
of
the
following
are
true
li
Database
zDb
does
not
exist
li
Table
zTable
is
a
WITHOUT
ROWID
table
li
Row
iRow
is
not
present
in
the
table
a
TEXT
or
BLOB
value
constraint
and
the
blob
is
being
opened
for
read
rite
access
column
zColumn
is
part
of
a
child
key
definition
and
the
blob
is
l
Unless
it
returns
SQLITE_MISUSE
this
function
sets
the
sqlite3_errcode
and
sqlite3_errmsg
and
related
functions
A
BLOB
referenced
by
sqlite3_blob_open
may
be
read
using
the
sqlite3_blob_write
The
BLOB
handle
can
be
moved
to
a
interface
However
the
column
table
or
database
of
a
BLOB
handle
If
the
row
that
a
BLOB
handle
points
to
is
modified
by
an
then
the
BLOB
handle
is
marked
as
other
than
the
one
the
BLOB
handle
is
open
on
an
expired
BLOB
handle
fail
with
a
return
code
of
SQLITE_ABORT
rolled
back
by
the
expiration
of
the
BLOB
Such
changes
will
eventually
Use
the
sqlite3_blob_bytes
interface
to
determine
the
size
of
interface
Use
the
UPDATE
SQL
command
to
change
the
size
of
a
The
sqlite3_bind_zeroblob
and
sqlite3_result_zeroblob
interfaces
zero
filled
blob
to
read
or
write
using
the
incremental
blob
interface
To
avoid
a
resource
leak
every
open
BLOB
handle
should
eventually
See
also
sqlite3_blob_close
sqlite3_blob_bytes
sqlite3_blob_write
int
sqlite3_blob_open
sqlite3
const
char
zDb
const
char
zTable
const
char
zColumn
sqlite3_int64
iRow
int
flags
sqlite3_blob
ppBlob
CAPI3REF
Move
a
BLOB
Handle
to
a
New
Row
This
function
is
used
to
move
an
existing
BLOB
handle
so
that
it
points
by
the
rowid
value
passed
as
the
second
argument
Only
the
row
can
be
remain
the
same
Moving
an
existing
BLOB
handle
to
a
new
row
is
The
new
row
must
meet
the
same
criteria
as
for
sqlite3_blob_open
the
nominated
column
If
the
new
row
is
not
present
in
the
table
or
if
SQLite
error
code
is
returned
and
the
blob
handle
is
considered
aborted
sqlite3_blob_reopen
on
an
aborted
blob
handle
immediately
return
always
returns
zero
This
function
sets
the
database
handle
error
code
and
message
int
sqlite3_blob_reopen
sqlite3_blob
sqlite3_int64
CAPI3REF
Close
A
BLOB
Handle
This
function
closes
an
open
BLOB
handle
The
BLOB
handle
is
closed
handle
is
still
closed
If
the
blob
handle
being
closed
was
opened
for
read
write
access
and
if
blob
handles
or
active
write
statements
the
current
transaction
is
code
is
returned
and
the
transaction
rolled
back
Calling
this
function
with
an
argument
that
is
not
a
NULL
pointer
or
an
with
a
null
pointer
such
as
would
be
returned
by
a
failed
call
to
is
passed
a
valid
open
blob
handle
the
values
returned
by
the
int
sqlite3_blob_close
sqlite3_blob
CAPI3REF
Return
The
Size
Of
An
Open
BLOB
Returns
the
size
in
bytes
of
the
BLOB
accessible
via
the
incremental
blob
I
routines
can
only
read
or
overwriting
existing
This
routine
only
works
on
a
BLOB
handle
which
has
been
created
been
closed
by
sqlite3_blob_close
Passing
any
other
pointer
in
int
sqlite3_blob_bytes
sqlite3_blob
CAPI3REF
Read
Data
From
A
BLOB
Incrementally
This
function
is
used
to
read
data
from
an
open
BLOB
handle
into
a
from
the
open
BLOB
starting
at
offset
iOffset
If
offset
iOffset
is
less
than
N
bytes
from
the
end
of
the
BLOB
less
than
zero
SQLITE_ERROR
is
returned
and
no
data
is
read
can
be
determined
using
the
sqlite3_blob_bytes
interface
An
attempt
to
read
from
an
expired
BLOB
handle
fails
with
an
On
success
sqlite3_blob_read
returns
SQLITE_OK
This
routine
only
works
on
a
BLOB
handle
which
has
been
created
been
closed
by
sqlite3_blob_close
Passing
any
other
pointer
in
See
also
sqlite3_blob_write
int
sqlite3_blob_read
sqlite3_blob
void
Z
int
N
int
iOffset
CAPI3REF
Write
Data
Into
A
BLOB
Incrementally
This
function
is
used
to
write
data
into
an
open
BLOB
handle
from
a
into
the
open
BLOB
starting
at
offset
iOffset
On
success
sqlite3_blob_write
returns
SQLITE_OK
Unless
SQLITE_MISUSE
is
returned
this
function
sets
the
sqlite3_errcode
and
sqlite3_errmsg
and
related
functions
If
the
BLOB
handle
passed
as
the
first
argument
was
not
opened
for
this
function
returns
SQLITE_READONLY
This
function
may
only
modify
the
contents
of
the
BLOB
it
is
If
offset
iOffset
is
less
than
N
bytes
from
the
end
of
the
BLOB
BLOB
and
hence
the
maximum
value
of
N
iOffset
can
be
determined
than
zero
SQLITE_ERROR
is
returned
and
no
data
is
written
An
attempt
to
write
to
an
expired
BLOB
handle
fails
with
an
before
the
BLOB
handle
expired
are
not
rolled
back
by
the
have
been
overwritten
by
the
statement
that
expired
the
BLOB
handle
This
routine
only
works
on
a
BLOB
handle
which
has
been
created
been
closed
by
sqlite3_blob_close
Passing
any
other
pointer
in
See
also
sqlite3_blob_read
int
sqlite3_blob_write
sqlite3_blob
const
void
z
int
n
int
iOffset
CAPI3REF
Virtual
File
System
Objects
A
virtual
filesystem
VFS
is
an
sqlite3_vfs
object
with
the
underlying
operating
system
Most
SQLite
builds
come
with
a
New
VFSes
can
be
registered
and
existing
VFSes
can
be
unregistered
The
sqlite3_vfs_find
interface
returns
a
pointer
to
a
VFS
given
its
name
Names
are
zero
terminated
UTF
strings
If
zVfsName
is
NULL
then
the
default
VFS
is
returned
New
VFSes
are
registered
with
sqlite3_vfs_register
The
same
VFS
can
be
registered
multiple
times
without
injury
with
the
makeDflt
flag
set
If
two
different
VFSes
with
the
VFS
is
registered
with
a
name
that
is
NULL
or
an
empty
string
Unregister
a
VFS
with
the
sqlite3_vfs_unregister
interface
the
default
The
choice
for
the
new
VFS
is
arbitrary
sqlite3_vfs
sqlite3_vfs_find
const
char
zVfsName
int
sqlite3_vfs_register
sqlite3_vfs
int
makeDflt
int
sqlite3_vfs_unregister
sqlite3_vfs
CAPI3REF
Mutexes
The
SQLite
core
uses
these
routines
for
thread
use
by
SQLite
code
that
links
against
SQLite
is
The
SQLite
source
code
contains
multiple
implementations
is
selected
automatically
at
compile
time
The
following
ul
li
SQLITE_MUTEX_W32
l
The
SQLITE_MUTEX_NOOP
implementation
is
a
set
of
routines
a
single
threaded
application
The
SQLITE_MUTEX_PTHREADS
and
and
Windows
If
SQLite
is
compiled
with
the
SQLITE_MUTEX_APPDEF
preprocessor
implementation
is
included
with
the
library
In
this
case
the
SQLITE_CONFIG_MUTEX
option
of
the
sqlite3_config
function
function
that
calls
sqlite3_initialize
The
sqlite3_mutex_alloc
routine
allocates
a
new
routine
returns
NULL
if
it
is
unable
to
allocate
the
requested
integer
constants
ul
li
SQLITE_MUTEX_RECURSIVE
li
SQLITE_MUTEX_STATIC_MEM
li
SQLITE_MUTEX_STATIC_PRNG
li
SQLITE_MUTEX_STATIC_PMEM
li
SQLITE_MUTEX_STATIC_APP2
li
SQLITE_MUTEX_STATIC_VFS1
li
SQLITE_MUTEX_STATIC_VFS3
The
first
two
constants
SQLITE_MUTEX_FAST
and
SQLITE_MUTEX_RECURSIVE
a
new
mutex
The
new
mutex
is
recursive
when
SQLITE_MUTEX_RECURSIVE
The
mutex
implementation
does
not
need
to
make
a
distinction
not
want
to
SQLite
will
only
request
a
recursive
mutex
in
implementation
is
available
on
the
host
platform
the
mutex
subsystem
The
other
allowed
parameters
to
sqlite3_mutex_alloc
anything
other
a
pointer
to
a
static
preexisting
mutex
Nine
static
mutexes
are
may
add
additional
static
mutexes
Static
mutexes
are
for
internal
use
only
the
dynamic
mutexes
returned
by
SQLITE_MUTEX_FAST
or
Note
that
if
one
of
the
dynamic
mutex
parameters
SQLITE_MUTEX_FAST
returns
a
different
mutex
on
every
call
For
the
static
the
same
type
number
The
sqlite3_mutex_free
routine
deallocates
a
previously
mutex
results
in
undefined
behavior
The
sqlite3_mutex_enter
and
sqlite3_mutex_try
routines
attempt
sqlite3_mutex_enter
will
block
and
sqlite3_mutex_try
will
return
upon
successful
entry
Mutexes
created
using
In
such
cases
the
can
enter
If
the
same
thread
tries
to
enter
any
mutex
other
Some
systems
for
example
Windows
do
not
support
the
operation
will
always
return
SQLITE_BUSY
The
SQLite
core
only
ever
uses
behavior
The
sqlite3_mutex_leave
routine
exits
a
mutex
that
was
is
undefined
if
the
mutex
is
not
currently
entered
by
the
If
the
argument
to
sqlite3_mutex_enter
sqlite3_mutex_try
or
behave
as
no
ops
See
also
sqlite3_mutex_held
and
sqlite3_mutex_notheld
sqlite3_mutex
sqlite3_mutex_alloc
int
void
sqlite3_mutex_free
sqlite3_mutex
void
sqlite3_mutex_enter
sqlite3_mutex
int
sqlite3_mutex_try
sqlite3_mutex
void
sqlite3_mutex_leave
sqlite3_mutex
CAPI3REF
Mutex
Methods
Object
An
instance
of
this
structure
defines
the
low
level
routines
Usually
the
default
mutex
implementations
provided
by
SQLite
are
implementation
for
specialized
deployments
or
systems
for
which
SQLite
creates
and
populates
an
instance
of
this
structure
to
pass
Additionally
an
instance
of
this
structure
can
be
used
as
an
implementation
using
the
SQLITE_CONFIG_GETMUTEX
option
The
xMutexInit
method
defined
by
this
structure
is
invoked
as
The
xMutexInit
routine
is
called
by
SQLite
exactly
once
for
each
The
xMutexEnd
method
defined
by
this
structure
is
invoked
as
implementation
of
this
method
is
expected
to
release
all
outstanding
those
obtained
by
the
xMutexInit
method
The
xMutexEnd
The
remaining
seven
methods
defined
by
this
structure
xMutexAlloc
xMutexNotheld
implement
the
following
interfaces
respectively
ul
li
sqlite3_mutex_free
i
li
sqlite3_mutex_try
i
li
sqlite3_mutex_held
i
l
The
only
difference
is
that
the
public
sqlite3_XXX
functions
enumerated
of
a
valid
mutex
handle
The
implementations
of
the
methods
defined
of
passing
a
NULL
pointer
instead
of
a
valid
mutex
handle
are
undefined
it
is
passed
a
NULL
pointer
The
xMutexInit
method
must
be
threadsafe
It
must
be
harmless
to
intervening
calls
to
xMutexEnd
Second
and
subsequent
calls
to
xMutexInit
must
not
use
SQLite
memory
allocation
sqlite3_malloc
allocation
for
a
static
mutex
However
xMutexAlloc
may
use
SQLite
SQLite
will
invoke
the
xMutexEnd
method
when
sqlite3_shutdown
is
If
xMutexInit
fails
in
any
way
it
is
expected
to
clean
up
after
itself
typedef
struct
sqlite3_mutex_methods
sqlite3_mutex_methods
struct
sqlite3_mutex_methods
int
xMutexInit
void
int
xMutexEnd
void
sqlite3_mutex
xMutexAlloc
int
void
xMutexFree
sqlite3_mutex
void
xMutexEnter
sqlite3_mutex
int
xMutexTry
sqlite3_mutex
void
xMutexLeave
sqlite3_mutex
int
xMutexHeld
sqlite3_mutex
int
xMutexNotheld
sqlite3_mutex
CAPI3REF
Mutex
Verification
Routines
The
sqlite3_mutex_held
and
sqlite3_mutex_notheld
routines
never
uses
these
routines
except
inside
an
assert
and
applications
provides
implementations
for
these
routines
when
it
is
compiled
are
only
required
to
provide
these
routines
if
SQLITE_DEBUG
is
These
routines
should
return
true
if
the
mutex
in
their
argument
The
implementation
is
not
required
to
provide
versions
of
these
versions
of
these
routines
it
should
at
least
provide
stubs
that
always
If
the
argument
to
sqlite3_mutex_held
is
a
NULL
pointer
then
clearly
the
mutex
cannot
be
held
if
it
does
not
exist
But
using
mutexes
And
we
do
not
want
the
assert
containing
the
the
appropriate
thing
to
do
The
sqlite3_mutex_notheld
ifndef
NDEBUG
int
sqlite3_mutex_held
sqlite3_mutex
int
sqlite3_mutex_notheld
sqlite3_mutex
endif
CAPI3REF
Mutex
Types
The
sqlite3_mutex_alloc
interface
takes
a
single
argument
The
set
of
static
mutexes
may
change
from
one
SQLite
release
to
the
prepared
to
accommodate
additional
static
mutexes
define
SQLITE_MUTEX_FAST
define
SQLITE_MUTEX_RECURSIVE
define
SQLITE_MUTEX_STATIC_MAIN
define
SQLITE_MUTEX_STATIC_MEM
define
SQLITE_MUTEX_STATIC_MEM2
define
SQLITE_MUTEX_STATIC_OPEN
define
SQLITE_MUTEX_STATIC_PRNG
define
SQLITE_MUTEX_STATIC_LRU
define
SQLITE_MUTEX_STATIC_LRU2
define
SQLITE_MUTEX_STATIC_PMEM
define
SQLITE_MUTEX_STATIC_APP1
define
SQLITE_MUTEX_STATIC_APP2
define
SQLITE_MUTEX_STATIC_APP3
define
SQLITE_MUTEX_STATIC_VFS1
define
SQLITE_MUTEX_STATIC_VFS2
define
SQLITE_MUTEX_STATIC_VFS3
define
SQLITE_MUTEX_STATIC_MASTER
CAPI3REF
Retrieve
the
mutex
for
a
database
connection
This
interface
returns
a
pointer
the
sqlite3_mutex
object
that
when
the
threading
mode
is
Serialized
routine
returns
a
NULL
pointer
sqlite3_mutex
sqlite3_db_mutex
sqlite3
CAPI3REF
Low
Level
Control
Of
Database
Files
KEYWORDS
file
control
The
sqlite3_file_control
interface
makes
a
direct
call
to
the
with
a
particular
database
identified
by
the
second
argument
The
TEMP
database
or
the
name
that
appears
after
the
AS
keyword
for
A
NULL
pointer
can
be
used
in
place
of
to
refer
to
the
The
third
and
fourth
parameters
to
this
routine
the
xFileControl
method
The
return
value
of
the
xFileControl
A
few
opcodes
for
sqlite3_file_control
are
handled
directly
sqlite3_io_methods
xFileControl
method
a
pointer
to
the
underlying
sqlite3_file
object
to
be
written
into
SQLITE_FCNTL_JOURNAL_POINTER
works
similarly
except
that
it
returns
the
main
database
The
SQLITE_FCNTL_VFS_POINTER
opcode
returns
The
SQLITE_FCNTL_DATA_VERSION
returns
the
data
version
counter
If
the
second
parameter
zDbName
does
not
match
the
name
of
any
code
is
not
remembered
and
will
not
be
recalled
by
sqlite3_errcode
also
return
SQLITE_ERROR
There
is
no
way
to
distinguish
between
xFileControl
method
See
also
file
control
opcodes
int
sqlite3_file_control
sqlite3
const
char
zDbName
int
op
void
CAPI3REF
Testing
Interface
The
sqlite3_test_control
interface
is
used
to
read
out
internal
purposes
The
first
parameter
is
an
operation
code
that
determines
This
interface
is
not
for
use
by
applications
It
exists
solely
on
how
the
SQLite
library
is
compiled
this
interface
might
not
exist
The
details
of
the
operation
codes
their
meanings
the
parameters
Unlike
most
of
the
SQLite
API
this
function
is
not
guaranteed
to
int
sqlite3_test_control
int
op
CAPI3REF
Testing
Interface
Operation
Codes
These
constants
are
the
valid
operation
code
parameters
used
These
parameters
and
their
meanings
are
subject
to
change
Applications
should
not
use
any
of
these
parameters
or
the
define
SQLITE_TESTCTRL_FIRST
define
SQLITE_TESTCTRL_PRNG_SAVE
define
SQLITE_TESTCTRL_PRNG_RESTORE
define
SQLITE_TESTCTRL_PRNG_RESET
define
SQLITE_TESTCTRL_BITVEC_TEST
define
SQLITE_TESTCTRL_FAULT_INSTALL
define
SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS
define
SQLITE_TESTCTRL_PENDING_BYTE
define
SQLITE_TESTCTRL_ASSERT
define
SQLITE_TESTCTRL_ALWAYS
define
SQLITE_TESTCTRL_RESERVE
define
SQLITE_TESTCTRL_OPTIMIZATIONS
define
SQLITE_TESTCTRL_ISKEYWORD
define
SQLITE_TESTCTRL_SCRATCHMALLOC
define
SQLITE_TESTCTRL_INTERNAL_FUNCTIONS
define
SQLITE_TESTCTRL_LOCALTIME_FAULT
define
SQLITE_TESTCTRL_EXPLAIN_STMT
define
SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD
define
SQLITE_TESTCTRL_NEVER_CORRUPT
define
SQLITE_TESTCTRL_VDBE_COVERAGE
define
SQLITE_TESTCTRL_BYTEORDER
define
SQLITE_TESTCTRL_ISINIT
define
SQLITE_TESTCTRL_SORTER_MMAP
define
SQLITE_TESTCTRL_IMPOSTER
define
SQLITE_TESTCTRL_PARSER_COVERAGE
define
SQLITE_TESTCTRL_RESULT_INTREAL
define
SQLITE_TESTCTRL_PRNG_SEED
define
SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS
define
SQLITE_TESTCTRL_SEEK_COUNT
define
SQLITE_TESTCTRL_TRACEFLAGS
define
SQLITE_TESTCTRL_TUNE
define
SQLITE_TESTCTRL_LOGEST
define
SQLITE_TESTCTRL_LAST
CAPI3REF
SQL
Keyword
Checking
These
routines
provide
access
to
the
set
of
SQL
language
keywords
whether
or
not
a
specific
identifier
needs
to
be
escaped
for
example
The
sqlite3_keyword_count
interface
returns
the
number
of
distinct
The
sqlite3_keyword_name
N
Z
L
interface
finds
the
N
th
keyword
and
of
bytes
in
the
keyword
into
L
The
string
that
Z
points
to
is
not
SQLITE_OK
if
N
is
within
bounds
and
SQLITE_ERROR
if
not
If
either
Z
sqlite3_keyword_name
N
Z
L
result
in
undefined
behavior
The
sqlite3_keyword_check
Z
L
interface
checks
to
see
whether
or
not
if
it
is
and
zero
if
not
The
parser
used
by
SQLite
is
forgiving
It
is
often
possible
to
use
parsing
ambiguity
For
example
the
statement
creates
a
new
table
named
with
three
columns
named
using
keywords
as
identifiers
Common
techniques
used
to
avoid
keyword
ul
SQL
way
to
escape
identifier
names
but
it
is
what
SQL
Server
does
and
so
lots
of
programmers
use
this
li
Begin
every
identifier
with
the
letter
as
no
SQL
keywords
start
li
Include
a
digit
somewhere
in
every
identifier
name
Note
that
the
number
of
keywords
understood
by
SQLite
can
depend
on
SQLite
is
compiled
with
the
DSQLITE_OMIT_VACUUM
option
Also
int
sqlite3_keyword_count
void
int
sqlite3_keyword_name
int
const
char
int
int
sqlite3_keyword_check
const
char
int
CAPI3REF
Dynamic
String
Object
An
instance
of
the
sqlite3_str
object
contains
a
dynamically
sized
The
lifecycle
of
an
sqlite3_str
object
is
as
follows
li
The
sqlite3_str
object
is
created
using
sqlite3_str_new
methods
such
as
sqlite3_str_appendf
is
returned
using
the
sqlite3_str_finish
interface
typedef
struct
sqlite3_str
sqlite3_str
CAPI3REF
Create
A
New
Dynamic
String
Object
The
sqlite3_str_new
D
interface
allocates
and
initializes
sqlite3_str_new
must
be
freed
by
a
subsequent
call
to
The
sqlite3_str_new
D
interface
always
returns
a
pointer
to
a
error
the
returned
object
might
be
a
special
singleton
that
will
sqlite3_str_errcode
always
return
for
sqlite3_str_finish
X
It
is
always
safe
to
use
the
value
to
any
of
the
other
sqlite3_str
methods
The
D
parameter
to
sqlite3_str_new
D
may
be
NULL
If
the
length
of
the
string
contained
in
the
sqlite3_str
object
will
be
of
SQLITE_MAX_LENGTH
sqlite3_str
sqlite3_str_new
sqlite3
CAPI3REF
Finalize
A
Dynamic
String
The
sqlite3_str_finish
X
interface
destroys
the
sqlite3_str
object
X
that
contains
the
constructed
string
The
calling
application
should
The
sqlite3_str_finish
X
interface
may
return
a
NULL
pointer
if
any
sqlite3_str_finish
X
interface
will
also
return
a
NULL
pointer
if
the
char
sqlite3_str_finish
sqlite3_str
CAPI3REF
Add
Content
To
A
Dynamic
String
These
interfaces
add
content
to
an
sqlite3_str
object
previously
obtained
The
sqlite3_str_appendf
X
F
and
functionality
of
SQLite
to
append
formatted
text
onto
the
end
of
The
sqlite3_str_append
X
S
N
method
appends
exactly
N
bytes
from
string
S
S
must
contain
at
least
N
non
zero
bytes
of
content
To
append
a
method
instead
The
sqlite3_str_appendall
X
S
method
appends
the
complete
content
of
The
sqlite3_str_appendchar
X
N
C
method
appends
N
copies
of
the
This
method
can
be
used
for
example
to
add
whitespace
indentation
The
sqlite3_str_reset
X
method
resets
the
string
under
construction
These
methods
do
not
return
a
result
code
If
an
error
occurs
that
fact
subsequent
call
to
sqlite3_str_errcode
X
void
sqlite3_str_appendf
sqlite3_str
const
char
zFormat
void
sqlite3_str_vappendf
sqlite3_str
const
char
zFormat
va_list
void
sqlite3_str_append
sqlite3_str
const
char
zIn
int
N
void
sqlite3_str_appendall
sqlite3_str
const
char
zIn
void
sqlite3_str_appendchar
sqlite3_str
int
N
char
C
void
sqlite3_str_reset
sqlite3_str
CAPI3REF
Status
Of
A
Dynamic
String
These
interfaces
return
the
current
status
of
an
sqlite3_str
object
If
any
prior
errors
have
occurred
while
constructing
the
dynamic
string
an
appropriate
error
code
The
sqlite3_str_errcode
X
method
returns
SQLITE_TOOBIG
if
the
size
of
the
dynamic
string
exceeds
The
sqlite3_str_length
X
method
returns
the
current
length
in
bytes
The
length
returned
by
sqlite3_str_length
X
does
not
include
the
The
sqlite3_str_value
X
method
returns
a
pointer
to
the
current
returned
by
sqlite3_str_value
X
is
managed
by
the
sqlite3_str
object
X
sqlite3_str
object
Applications
must
not
used
the
pointer
returned
object
Applications
may
change
the
content
of
the
string
returned
outside
the
range
of
to
sqlite3_str_length
X
and
do
not
read
or
int
sqlite3_str_errcode
sqlite3_str
int
sqlite3_str_length
sqlite3_str
char
sqlite3_str_value
sqlite3_str
CAPI3REF
SQLite
Runtime
Status
These
interfaces
are
used
to
retrieve
runtime
status
information
highwater
marks
The
first
argument
is
an
integer
code
for
are
of
the
form
status
parameters
SQLITE_STATUS_
The
highest
recorded
value
is
returned
in
pHighwater
If
the
pHighwater
is
written
Some
parameters
do
not
record
the
highest
nothing
is
written
into
pHighwater
and
the
resetFlag
is
ignored
value
For
these
latter
parameters
nothing
is
written
into
pCurrent
The
sqlite3_status
and
sqlite3_status64
routines
return
If
either
the
current
value
or
the
highwater
mark
is
too
large
to
sqlite3_status
are
undefined
See
also
sqlite3_db_status
int
sqlite3_status
int
op
int
pCurrent
int
pHighwater
int
resetFlag
int
sqlite3_status64
int
op
sqlite3_int64
pCurrent
sqlite3_int64
pHighwater
int
resetFlag
CAPI3REF
Status
Parameters
These
integer
constants
designate
various
run
time
status
parameters
dl
dd
This
parameter
is
the
current
amount
of
memory
checked
out
figure
includes
calls
made
to
sqlite3_malloc
by
the
application
memory
controlled
by
SQLITE_CONFIG_PAGECACHE
is
not
included
in
sizes
as
reported
by
the
xSize
method
in
sqlite3_mem_methods
d
SQLITE_STATUS_MALLOC_SIZE
dt
SQLITE_STATUS_MALLOC_SIZE
t
handed
to
sqlite3_malloc
or
sqlite3_realloc
or
their
pHighwater
parameter
to
sqlite3_status
is
of
interest
SQLITE_STATUS_MALLOC_COUNT
dt
SQLITE_STATUS_MALLOC_COUNT
t
currently
checked
out
d
SQLITE_STATUS_PAGECACHE_USED
dt
SQLITE_STATUS_PAGECACHE_USED
t
pagecache
memory
allocator
that
was
configured
using
value
returned
is
in
pages
not
in
bytes
d
SQLITE_STATUS_PAGECACHE_OVERFLOW
dd
This
parameter
returns
the
number
of
bytes
of
page
cache
buffer
and
where
forced
to
overflow
to
sqlite3_malloc
The
where
too
large
they
were
larger
than
the
parameter
to
no
space
was
left
in
the
page
cache
d
SQLITE_STATUS_PAGECACHE_SIZE
dt
SQLITE_STATUS_PAGECACHE_SIZE
t
handed
to
the
pagecache
memory
allocator
Only
the
value
returned
in
the
The
value
written
into
the
pCurrent
parameter
is
undefined
d
SQLITE_STATUS_SCRATCH_USED
dt
SQLITE_STATUS_SCRATCH_USED
t
SQLITE_STATUS_SCRATCH_OVERFLOW
dt
SQLITE_STATUS_SCRATCH_OVERFLOW
t
SQLITE_STATUS_SCRATCH_SIZE
dt
SQLITE_STATUS_SCRATCH_SIZE
t
SQLITE_STATUS_PARSER_STACK
dt
SQLITE_STATUS_PARSER_STACK
t
The
pCurrent
value
is
undefined
The
pHighwater
value
is
only
l
New
status
parameters
may
be
added
from
time
to
time
define
SQLITE_STATUS_MEMORY_USED
define
SQLITE_STATUS_PAGECACHE_USED
define
SQLITE_STATUS_PAGECACHE_OVERFLOW
define
SQLITE_STATUS_SCRATCH_USED
define
SQLITE_STATUS_SCRATCH_OVERFLOW
define
SQLITE_STATUS_MALLOC_SIZE
define
SQLITE_STATUS_PARSER_STACK
define
SQLITE_STATUS_PAGECACHE_SIZE
define
SQLITE_STATUS_SCRATCH_SIZE
define
SQLITE_STATUS_MALLOC_COUNT
CAPI3REF
Database
Connection
Status
This
interface
is
used
to
retrieve
runtime
status
information
database
connection
object
to
be
interrogated
The
second
argument
SQLITE_DBSTATUS
options
that
SQLITE_DBSTATUS
options
is
likely
The
current
value
of
the
requested
parameter
is
written
into
pCur
the
resetFlg
is
true
then
the
highest
instantaneous
value
is
The
sqlite3_db_status
routine
returns
SQLITE_OK
on
success
and
a
See
also
sqlite3_status
and
sqlite3_stmt_status
int
sqlite3_db_status
sqlite3
int
op
int
pCur
int
pHiwtr
int
resetFlg
CAPI3REF
Status
Parameters
for
database
connections
These
constants
are
the
available
integer
that
can
be
passed
as
New
verbs
may
be
added
in
future
releases
of
SQLite
Existing
verbs
sqlite3_db_status
to
make
sure
that
the
call
worked
if
a
discontinued
or
unsupported
verb
is
invoked
dl
dd
This
parameter
returns
the
number
of
lookaside
memory
slots
currently
SQLITE_DBSTATUS_LOOKASIDE_HIT
dt
SQLITE_DBSTATUS_LOOKASIDE_HIT
t
satisfied
using
lookaside
memory
Only
the
high
water
value
is
meaningful
SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE
dd
This
parameter
returns
the
number
malloc
attempts
that
might
have
memory
requested
being
larger
than
the
lookaside
slot
size
the
current
value
is
always
zero
SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL
dd
This
parameter
returns
the
number
malloc
attempts
that
might
have
memory
already
being
in
use
the
current
value
is
always
zero
SQLITE_DBSTATUS_CACHE_USED
dt
SQLITE_DBSTATUS_CACHE_USED
t
memory
used
by
all
pager
caches
associated
with
the
database
connection
SQLITE_DBSTATUS_CACHE_USED_SHARED
dd
This
parameter
is
similar
to
DBSTATUS_CACHE_USED
except
that
if
a
memory
used
by
that
pager
cache
is
divided
evenly
between
the
attached
with
the
database
connection
are
shared
this
request
returns
the
same
shared
the
value
returned
by
this
call
will
be
smaller
than
that
returned
SQLITE_DBSTATUS_CACHE_USED_SHARED
is
always
SQLITE_DBSTATUS_SCHEMA_USED
dt
SQLITE_DBSTATUS_SCHEMA_USED
t
memory
used
to
store
the
schema
for
all
databases
associated
The
full
amount
of
memory
used
by
the
schemas
is
reported
even
if
the
shared
cache
mode
being
enabled
SQLITE_DBSTATUS_STMT_USED
dt
SQLITE_DBSTATUS_STMT_USED
t
and
lookaside
memory
used
by
all
prepared
statements
associated
with
The
highwater
mark
associated
with
SQLITE_DBSTATUS_STMT_USED
is
always
SQLITE_DBSTATUS_CACHE_HIT
dt
SQLITE_DBSTATUS_CACHE_HIT
t
occurred
The
highwater
mark
associated
with
SQLITE_DBSTATUS_CACHE_HIT
d
SQLITE_DBSTATUS_CACHE_MISS
dt
SQLITE_DBSTATUS_CACHE_MISS
t
occurred
The
highwater
mark
associated
with
SQLITE_DBSTATUS_CACHE_MISS
d
SQLITE_DBSTATUS_CACHE_WRITE
dt
SQLITE_DBSTATUS_CACHE_WRITE
t
been
written
to
disk
Specifically
the
number
of
pages
written
to
the
database
file
in
rollback
mode
databases
Any
pages
written
as
part
of
If
an
IO
or
other
error
occurs
while
writing
a
page
to
disk
the
effect
highwater
mark
associated
with
SQLITE_DBSTATUS_CACHE_WRITE
is
always
SQLITE_DBSTATUS_CACHE_SPILL
dt
SQLITE_DBSTATUS_CACHE_SPILL
t
been
written
to
disk
in
the
middle
of
a
transaction
due
to
the
page
to
disk
all
at
once
When
pages
spill
mid
transaction
that
introduces
inefficiencies
that
can
be
resolved
by
increasing
the
cache
size
SQLITE_DBSTATUS_DEFERRED_FKS
dt
SQLITE_DBSTATUS_DEFERRED_FKS
t
all
foreign
key
constraints
deferred
or
immediate
have
been
d
define
SQLITE_DBSTATUS_LOOKASIDE_USED
define
SQLITE_DBSTATUS_CACHE_USED
define
SQLITE_DBSTATUS_SCHEMA_USED
define
SQLITE_DBSTATUS_STMT_USED
define
SQLITE_DBSTATUS_LOOKASIDE_HIT
define
SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE
define
SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL
define
SQLITE_DBSTATUS_CACHE_HIT
define
SQLITE_DBSTATUS_CACHE_MISS
define
SQLITE_DBSTATUS_CACHE_WRITE
define
SQLITE_DBSTATUS_DEFERRED_FKS
define
SQLITE_DBSTATUS_CACHE_USED_SHARED
define
SQLITE_DBSTATUS_CACHE_SPILL
define
SQLITE_DBSTATUS_MAX
CAPI3REF
Prepared
Statement
Status
Each
prepared
statement
maintains
various
of
times
it
has
performed
specific
operations
These
counters
can
statements
For
example
if
the
number
of
table
steps
greatly
exceeds
that
the
prepared
statement
is
using
a
full
table
scan
rather
than
This
interface
is
used
to
retrieve
and
reset
counter
values
from
object
to
be
interrogated
The
second
argument
to
be
interrogated
If
the
resetFlg
is
true
then
the
counter
is
reset
to
zero
after
this
See
also
sqlite3_status
and
sqlite3_db_status
int
sqlite3_stmt_status
sqlite3_stmt
int
op
int
resetFlg
CAPI3REF
Status
Parameters
for
prepared
statements
These
preprocessor
macros
define
integer
codes
that
name
counter
The
meanings
of
the
various
counters
are
as
follows
dl
dd
This
is
the
number
of
times
that
SQLite
has
stepped
forward
in
may
indicate
opportunities
for
performance
improvement
through
SQLITE_STMTSTATUS_SORT
dt
SQLITE_STMTSTATUS_SORT
t
A
non
zero
value
in
this
counter
may
indicate
an
opportunity
to
SQLITE_STMTSTATUS_AUTOINDEX
dt
SQLITE_STMTSTATUS_AUTOINDEX
t
were
created
automatically
in
order
to
help
joins
run
faster
improvement
performance
by
adding
permanent
indices
that
do
not
SQLITE_STMTSTATUS_VM_STEP
dt
SQLITE_STMTSTATUS_VM_STEP
t
by
the
prepared
statement
if
that
number
is
less
than
or
equal
used
as
a
proxy
for
the
total
work
done
by
the
prepared
statement
then
the
value
returned
by
this
statement
status
code
is
undefined
SQLITE_STMTSTATUS_REPREPARE
dt
SQLITE_STMTSTATUS_REPREPARE
t
automatically
regenerated
due
to
schema
changes
or
changes
to
SQLITE_STMTSTATUS_RUN
dt
SQLITE_STMTSTATUS_RUN
t
been
run
A
single
for
the
purposes
of
this
counter
is
one
The
counter
is
incremented
on
the
first
sqlite3_step
call
of
each
SQLITE_STMTSTATUS_FILTER_MISS
dt
SQLITE_STMTSTATUS_FILTER_HIT
br
dd
SQLITE_STMTSTATUS_FILTER_HIT
is
the
number
of
times
that
a
join
corresponding
SQLITE_STMTSTATUS_FILTER_MISS
value
is
the
number
of
had
to
be
processed
as
normal
SQLITE_STMTSTATUS_MEMUSED
dt
SQLITE_STMTSTATUS_MEMUSED
t
used
to
store
the
prepared
statement
This
value
is
not
actually
is
ignored
when
the
opcode
is
SQLITE_STMTSTATUS_MEMUSED
l
define
SQLITE_STMTSTATUS_FULLSCAN_STEP
define
SQLITE_STMTSTATUS_SORT
define
SQLITE_STMTSTATUS_AUTOINDEX
define
SQLITE_STMTSTATUS_VM_STEP
define
SQLITE_STMTSTATUS_REPREPARE
define
SQLITE_STMTSTATUS_RUN
define
SQLITE_STMTSTATUS_FILTER_MISS
define
SQLITE_STMTSTATUS_FILTER_HIT
define
SQLITE_STMTSTATUS_MEMUSED
CAPI3REF
Custom
Page
Cache
Object
The
sqlite3_pcache
type
is
opaque
It
is
implemented
by
its
size
or
internal
structure
and
never
deals
with
the
to
the
object
See
sqlite3_pcache_methods2
for
additional
information
typedef
struct
sqlite3_pcache
sqlite3_pcache
CAPI3REF
Custom
Page
Cache
Object
The
sqlite3_pcache_page
object
represents
a
single
page
in
the
object
Various
methods
of
the
page
cache
use
pointers
to
instances
See
sqlite3_pcache_methods2
for
additional
information
typedef
struct
sqlite3_pcache_page
sqlite3_pcache_page
struct
sqlite3_pcache_page
void
pBuf
void
pExtra
CAPI3REF
Application
Defined
Page
Cache
The
sqlite3_config
SQLITE_CONFIG_PCACHE2
interface
can
instance
of
the
sqlite3_pcache_methods2
structure
SQLite
is
used
for
the
page
cache
custom
page
cache
using
this
API
an
application
can
better
control
that
memory
is
allocated
and
released
and
the
policies
used
to
how
long
The
alternative
page
cache
mechanism
is
an
The
built
in
page
cache
is
recommended
for
most
uses
The
contents
of
the
sqlite3_pcache_methods2
structure
are
copied
to
an
the
application
may
discard
the
parameter
after
the
call
to
the
xInit
page
cache
method
call
to
sqlite3_initialize
method
is
passed
a
copy
of
the
sqlite3_pcache_methods2
pArg
value
required
by
the
custom
page
cache
implementation
built
in
default
page
cache
is
used
instead
of
the
application
defined
the
xShutdown
page
cache
method
It
can
be
used
to
clean
up
The
xShutdown
method
may
be
NULL
SQLite
automatically
serializes
calls
to
the
xInit
method
xShutdown
method
is
only
called
from
sqlite3_shutdown
so
it
does
in
multithreaded
applications
SQLite
will
never
invoke
xInit
more
than
once
without
an
intervening
the
xCreate
page
cache
methods
SQLite
will
typically
create
one
cache
instance
for
each
open
database
file
first
parameter
szPage
is
the
size
in
bytes
of
the
pages
that
must
second
parameter
szExtra
is
a
number
of
bytes
of
extra
storage
a
number
less
than
SQLite
will
use
the
database
page
on
disk
The
value
passed
into
szExtra
depends
The
third
argument
to
xCreate
bPurgeable
is
true
if
the
cache
being
false
if
it
is
used
for
an
in
memory
database
The
cache
implementation
it
is
purely
advisory
On
a
cache
where
bPurgeable
is
false
SQLite
will
In
other
words
calls
to
xUnpin
on
a
cache
with
bPurgeable
set
to
Hence
a
cache
created
with
bPurgeable
false
will
the
xCachesize
page
cache
method
suggested
maximum
cache
size
number
of
pages
stored
by
the
cache
the
SQLite
command
As
with
the
bPurgeable
value
it
is
advisory
only
the
xPagecount
page
cache
methods
stored
in
the
cache
both
pinned
and
unpinned
the
xFetch
page
cache
methods
an
sqlite3_pcache_page
object
associated
with
that
page
or
a
NULL
pointer
pointer
to
a
buffer
of
szPage
bytes
used
to
store
the
content
of
a
a
pointer
to
the
szExtra
bytes
of
extra
storage
that
SQLite
has
requested
The
page
to
be
fetched
is
determined
by
the
key
The
minimum
key
value
to
be
If
the
requested
page
is
already
in
the
page
cache
then
the
page
cache
intact
If
the
requested
page
is
not
already
in
the
cache
then
the
parameter
to
help
it
determined
what
action
to
take
table
border
width
align
center
tr
td
td
Do
not
allocate
a
new
page
Return
NULL
Otherwise
return
NULL
NULL
if
allocating
a
new
page
is
effectively
impossible
SQLite
will
normally
invoke
xFetch
with
a
createFlag
of
or
SQLite
failed
In
between
the
xFetch
calls
SQLite
may
pinned
pages
to
disk
and
synching
the
operating
system
disk
cache
the
xUnpin
page
cache
method
as
its
second
argument
If
the
third
parameter
discard
is
non
zero
If
the
discard
parameter
is
page
cache
implementation
The
page
cache
implementation
The
cache
must
not
perform
any
reference
counting
A
single
to
xFetch
the
xRekey
page
cache
methods
page
passed
as
the
second
argument
If
the
cache
discarded
Any
prior
cache
entry
associated
with
newKey
is
guaranteed
not
When
SQLite
calls
the
xTruncate
method
the
cache
must
discard
all
to
the
value
of
the
iLimit
parameter
passed
to
xTruncate
If
any
they
can
be
safely
discarded
the
xDestroy
page
cache
method
All
resources
associated
with
the
specified
cache
should
be
freed
After
handle
invalid
and
will
not
use
it
with
any
other
sqlite3_pcache_methods2
the
xShrink
page
cache
method
free
up
as
much
of
heap
memory
as
possible
The
page
cache
implementation
do
their
best
typedef
struct
sqlite3_pcache_methods2
sqlite3_pcache_methods2
struct
sqlite3_pcache_methods2
int
iVersion
void
pArg
int
xInit
void
void
xShutdown
void
sqlite3_pcache
xCreate
int
szPage
int
szExtra
int
bPurgeable
void
xCachesize
sqlite3_pcache
int
nCachesize
int
xPagecount
sqlite3_pcache
sqlite3_pcache_page
xFetch
sqlite3_pcache
unsigned
key
int
createFlag
void
xUnpin
sqlite3_pcache
sqlite3_pcache_page
int
discard
void
xRekey
sqlite3_pcache
sqlite3_pcache_page
unsigned
oldKey
unsigned
newKey
void
xTruncate
sqlite3_pcache
unsigned
iLimit
void
xDestroy
sqlite3_pcache
void
xShrink
sqlite3_pcache
This
is
the
obsolete
pcache_methods
object
that
has
now
been
replaced
retained
in
the
header
file
for
backwards
compatibility
only
typedef
struct
sqlite3_pcache_methods
sqlite3_pcache_methods
struct
sqlite3_pcache_methods
void
pArg
int
xInit
void
void
xShutdown
void
sqlite3_pcache
xCreate
int
szPage
int
bPurgeable
void
xCachesize
sqlite3_pcache
int
nCachesize
int
xPagecount
sqlite3_pcache
void
xFetch
sqlite3_pcache
unsigned
key
int
createFlag
void
xUnpin
sqlite3_pcache
void
int
discard
void
xRekey
sqlite3_pcache
void
unsigned
oldKey
unsigned
newKey
void
xTruncate
sqlite3_pcache
unsigned
iLimit
void
xDestroy
sqlite3_pcache
CAPI3REF
Online
Backup
Object
The
sqlite3_backup
object
records
state
information
about
an
ongoing
a
call
to
sqlite3_backup_init
and
is
destroyed
by
a
call
to
See
Also
Using
the
SQLite
Online
Backup
API
typedef
struct
sqlite3_backup
sqlite3_backup
CAPI3REF
Online
Backup
API
The
backup
API
copies
the
content
of
one
database
into
another
for
copying
in
memory
databases
to
or
from
persistent
files
See
Also
Using
the
SQLite
Online
Backup
API
SQLite
holds
a
write
transaction
open
on
the
destination
database
file
The
source
database
is
read
locked
only
while
it
is
being
read
Thus
the
backup
may
be
performed
on
a
live
source
database
without
reading
or
writing
to
the
source
database
while
the
backup
is
underway
To
perform
a
backup
operation
li
b
sqlite3_backup_init
is
called
once
to
initialize
the
li
b
sqlite3_backup_step
is
called
one
or
more
times
to
transfer
li
b
sqlite3_backup_finish
is
called
to
release
all
resources
l
successful
call
to
sqlite3_backup_init
sqlite3_backup_init
b
sqlite3_backup_init
The
D
and
N
arguments
to
sqlite3_backup_init
D
N
S
M
are
the
and
the
database
name
respectively
temporary
database
or
the
name
specified
after
the
AS
keyword
in
The
S
and
M
arguments
passed
to
and
database
name
of
the
source
database
respectively
must
be
different
or
else
sqlite3_backup_init
D
N
S
M
will
fail
with
A
call
to
sqlite3_backup_init
will
fail
returning
NULL
if
destination
database
If
an
error
occurs
within
sqlite3_backup_init
D
N
S
M
then
NULL
is
destination
database
connection
D
can
be
retrieved
using
the
sqlite3_errcode
sqlite3_errmsg
and
r
A
successful
call
to
sqlite3_backup_init
returns
a
pointer
to
an
The
sqlite3_backup
object
may
be
used
with
the
sqlite3_backup_step
and
operation
sqlite3_backup_step
b
sqlite3_backup_step
Function
sqlite3_backup_step
B
N
will
copy
up
to
N
pages
between
If
N
is
negative
all
remaining
source
pages
are
copied
are
still
more
pages
to
be
copied
then
the
function
returns
SQLITE_OK
from
source
to
destination
then
it
returns
SQLITE_DONE
then
an
error
code
is
returned
As
well
as
SQLITE_OK
and
SQLITE_NOMEM
SQLITE_BUSY
SQLITE_LOCKED
or
an
The
sqlite3_backup_step
might
return
SQLITE_READONLY
if
li
the
destination
database
was
opened
read
only
or
and
the
destination
and
source
page
sizes
differ
or
destination
and
source
page
sizes
differ
If
sqlite3_backup_step
cannot
obtain
a
required
file
system
lock
then
is
invoked
if
one
is
specified
If
the
SQLITE_BUSY
is
returned
to
the
caller
In
this
case
the
call
to
database
connection
is
called
then
SQLITE_LOCKED
is
returned
immediately
Again
in
this
SQLITE_IOERR_ACCESS
SQLITE_IOERR_XXX
SQLITE_NOMEM
or
there
is
no
point
in
retrying
the
call
to
sqlite3_backup_step
These
that
the
backup
operation
has
failed
and
pass
the
backup
operation
handle
The
first
call
to
sqlite3_backup_step
obtains
an
exclusive
lock
sqlite3_backup_finish
is
called
or
the
backup
operation
is
complete
sqlite3_backup_step
obtains
a
shared
lock
on
the
source
database
that
Because
the
source
database
is
not
locked
between
calls
to
through
the
backup
process
If
the
source
database
is
modified
by
an
used
by
the
backup
operation
then
the
backup
will
be
automatically
database
is
modified
by
the
using
the
same
database
connection
as
is
used
updated
at
the
same
time
sqlite3_backup_finish
b
sqlite3_backup_finish
When
sqlite3_backup_step
has
returned
SQLITE_DONE
or
when
the
should
destroy
the
sqlite3_backup
by
passing
it
to
sqlite3_backup_finish
resources
associated
with
the
sqlite3_backup
object
active
write
transaction
on
the
destination
database
is
rolled
back
and
may
not
be
used
following
a
call
to
sqlite3_backup_finish
The
value
returned
by
sqlite3_backup_finish
is
SQLITE_OK
if
no
sqlite3_backup_step
completed
sqlite3_backup_step
call
on
the
same
sqlite3_backup
object
then
A
return
of
SQLITE_BUSY
or
SQLITE_LOCKED
from
sqlite3_backup_step
sqlite3_backup_finish
sqlite3_backup_remaining
sqlite3_backup_pagecount
The
sqlite3_backup_remaining
routine
returns
the
number
of
pages
still
The
sqlite3_backup_pagecount
routine
returns
the
total
number
of
pages
sqlite3_backup_step
sqlite3_backup_step
If
the
source
database
is
modified
in
a
way
that
those
changes
are
not
reflected
in
the
output
of
sqlite3_backup_pagecount
sqlite3_backup_step
b
Concurrent
Usage
of
Database
Handles
The
source
database
connection
may
be
used
by
the
application
for
other
If
SQLite
is
compiled
and
configured
to
support
threadsafe
database
from
within
other
threads
However
the
application
must
guarantee
that
the
destination
sqlite3_backup_init
is
called
and
before
the
corresponding
call
to
if
the
application
incorrectly
accesses
the
destination
database
connection
nevertheless
Use
of
the
destination
database
connection
while
a
If
running
in
shared
cache
mode
the
application
must
is
not
accessed
while
the
backup
is
running
In
practice
this
means
backed
up
to
is
not
accessed
by
any
connection
within
the
process
The
sqlite3_backup
object
itself
is
partially
threadsafe
Multiple
However
the
sqlite3_backup_remaining
and
sqlite3_backup_pagecount
same
time
as
another
thread
is
invoking
sqlite3_backup_step
it
is
sqlite3_backup
sqlite3_backup_init
sqlite3
pDest
const
char
zDestName
sqlite3
pSource
const
char
zSourceName
int
sqlite3_backup_step
sqlite3_backup
p
int
nPage
int
sqlite3_backup_finish
sqlite3_backup
p
int
sqlite3_backup_remaining
sqlite3_backup
p
int
sqlite3_backup_pagecount
sqlite3_backup
p
CAPI3REF
Unlock
Notification
When
running
in
shared
cache
mode
a
database
operation
may
fail
with
individual
tables
within
the
shared
cache
cannot
be
obtained
See
This
API
may
be
used
to
register
a
callback
that
SQLite
will
invoke
This
API
is
only
available
if
the
library
was
compiled
with
the
See
Also
Using
the
SQLite
Unlock
Notification
Feature
Shared
cache
locks
are
released
when
a
database
connection
concludes
When
a
connection
known
as
the
blocked
connection
fails
to
obtain
a
identity
of
the
database
connection
the
blocking
connection
that
application
receives
an
SQLITE_LOCKED
error
it
may
call
the
the
first
argument
to
register
for
a
callback
that
will
be
invoked
callback
is
invoked
from
within
the
sqlite3_step
or
sqlite3_close
If
sqlite3_unlock_notify
is
called
in
a
multi
threaded
application
concluded
its
transaction
by
the
time
sqlite3_unlock_notify
is
invoked
from
within
the
call
to
sqlite3_unlock_notify
If
the
blocked
connection
is
attempting
to
obtain
a
write
lock
on
a
a
read
lock
on
the
same
table
then
SQLite
arbitrarily
selects
one
of
There
may
be
at
most
one
unlock
notify
callback
registered
by
a
blocked
connection
already
has
a
registered
unlock
notify
callback
called
with
a
NULL
pointer
as
its
second
argument
then
any
existing
unlock
notify
callback
may
also
be
canceled
by
closing
the
blocked
The
unlock
notify
callback
is
not
reentrant
If
an
application
invokes
crash
or
deadlock
may
be
the
result
Unless
deadlock
is
detected
see
below
sqlite3_unlock_notify
always
b
Callback
Invocation
Details
When
an
unlock
notify
callback
is
registered
the
application
provides
a
However
the
signature
of
the
callback
function
allows
SQLite
to
pass
an
unlock
notify
callback
is
a
pointer
to
an
array
of
void
pointers
When
a
blocking
connection
s
transaction
is
concluded
there
may
be
callback
If
two
or
more
such
blocked
connections
have
specified
the
multiple
times
it
is
invoked
once
with
the
set
of
void
context
pointers
This
gives
the
application
an
opportunity
to
prioritize
any
actions
b
Deadlock
Detection
Assuming
that
after
registering
for
an
unlock
notify
callback
a
action
a
reasonable
assumption
then
using
this
API
may
cause
the
connection
Y
s
transaction
to
be
concluded
and
similarly
connection
will
proceed
and
the
system
may
remain
deadlocked
indefinitely
To
avoid
this
scenario
the
sqlite3_unlock_notify
performs
deadlock
system
in
a
deadlocked
state
then
SQLITE_LOCKED
is
returned
and
no
a
deadlocked
state
if
connection
A
has
registered
for
an
unlock
notify
B
has
itself
registered
for
an
unlock
notify
callback
when
connection
the
system
is
also
considered
to
be
deadlocked
if
connection
B
has
C
s
transaction
where
connection
C
is
waiting
on
connection
A
Any
b
The
Exception
When
a
call
to
sqlite3_step
returns
SQLITE_LOCKED
it
is
almost
one
exception
When
executing
a
or
statement
that
belong
to
the
same
connection
If
there
are
SQLITE_LOCKED
is
sqlite3_unlock_notify
results
in
the
unlock
notify
callback
being
or
query
an
infinite
loop
might
be
the
result
One
way
around
this
problem
is
to
check
the
extended
error
code
returned
extended
error
code
is
set
to
SQLITE_LOCKED_SHAREDCACHE
Otherwise
in
SQLITE_LOCKED
int
sqlite3_unlock_notify
sqlite3
pBlocked
void
xNotify
void
apArg
int
nArg
void
pNotifyArg
CAPI3REF
String
Comparison
The
sqlite3_stricmp
and
sqlite3_strnicmp
APIs
allow
applications
strings
in
a
case
independent
fashion
using
the
same
definition
of
that
SQLite
uses
internally
when
comparing
identifiers
int
sqlite3_stricmp
const
char
const
char
int
sqlite3_strnicmp
const
char
const
char
int
CAPI3REF
String
Globbing
string
X
matches
the
GLOB
pattern
P
sqlite3_strglob
P
X
is
the
same
as
for
the
operator
in
the
is
case
sensitive
Note
that
this
routine
returns
zero
on
a
match
and
non
zero
if
the
strings
See
also
sqlite3_strlike
int
sqlite3_strglob
const
char
zGlob
const
char
zStr
CAPI3REF
String
LIKE
Matching
string
X
matches
the
LIKE
pattern
P
with
escape
character
E
sqlite3_strlike
P
X
E
is
the
same
as
for
the
the
ESCAPE
clause
set
the
E
parameter
of
sqlite3_strlike
P
X
E
to
insensitive
equivalent
upper
and
lower
case
ASCII
characters
match
The
sqlite3_strlike
P
X
E
function
matches
Unicode
characters
though
Note
that
this
routine
returns
zero
on
a
match
and
non
zero
if
the
strings
See
also
sqlite3_strglob
int
sqlite3_strlike
const
char
zGlob
const
char
zStr
unsigned
int
cEsc
CAPI3REF
Error
Logging
Interface
The
sqlite3_log
interface
writes
a
message
into
the
error
log
If
logging
is
enabled
the
zFormat
string
and
subsequent
arguments
are
The
sqlite3_log
interface
is
intended
for
use
by
extensions
such
as
nothing
to
prevent
an
application
from
calling
sqlite3_log
doing
so
The
zFormat
string
must
not
be
NULL
To
avoid
deadlocks
and
other
threading
problems
the
sqlite3_log
routine
a
fixed
length
buffer
on
the
stack
If
the
log
message
is
longer
than
buffer
void
sqlite3_log
int
iErrCode
const
char
zFormat
CAPI3REF
Write
Ahead
Log
Commit
Hook
The
sqlite3_wal_hook
function
is
used
to
register
a
callback
that
The
callback
is
invoked
by
SQLite
after
the
commit
has
taken
place
and
may
read
write
or
checkpoint
the
database
as
required
The
first
parameter
passed
to
the
callback
function
when
it
is
invoked
registering
the
callback
The
second
is
a
copy
of
the
database
handle
either
or
the
name
of
an
ATTACH
ed
database
The
fourth
parameter
including
those
that
were
just
committed
The
callback
function
should
normally
return
SQLITE_OK
If
an
error
SQLite
code
base
to
cause
the
statement
that
provoked
the
callback
callback
returns
SQLITE_ROW
or
SQLITE_DONE
or
if
it
returns
a
value
are
undefined
A
single
database
handle
may
have
at
most
a
single
write
ahead
log
callback
previously
registered
write
ahead
log
callback
The
return
value
is
Note
that
the
sqlite3_wal_autocheckpoint
interface
and
the
overwrite
any
prior
sqlite3_wal_hook
settings
void
sqlite3_wal_hook
sqlite3
int
void
sqlite3
const
char
int
void
CAPI3REF
Configure
an
auto
checkpoint
The
sqlite3_wal_autocheckpoint
D
N
is
a
wrapper
around
to
automatically
checkpoint
more
frames
in
the
write
ahead
log
file
Passing
zero
or
checkpoints
entirely
The
callback
registered
by
this
function
replaces
any
existing
callback
using
sqlite3_wal_hook
disables
the
automatic
checkpoint
mechanism
The
wal_autocheckpoint
pragma
can
be
used
to
invoke
this
interface
Checkpoints
initiated
by
this
mechanism
are
Every
new
database
connection
defaults
to
having
the
auto
checkpoint
pages
The
use
of
this
interface
for
a
particular
application
int
sqlite3_wal_autocheckpoint
sqlite3
db
int
N
CAPI3REF
Checkpoint
a
database
The
sqlite3_wal_checkpoint
D
X
is
equivalent
to
In
brief
sqlite3_wal_checkpoint
D
X
causes
the
content
in
the
transferred
into
the
database
file
and
for
the
write
ahead
log
to
information
This
interface
used
to
be
the
only
way
to
cause
a
checkpoint
to
interface
was
added
This
interface
is
retained
for
backwards
start
a
callback
but
which
do
not
need
the
full
power
and
corresponding
int
sqlite3_wal_checkpoint
sqlite3
db
const
char
zDb
CAPI3REF
Checkpoint
a
database
The
sqlite3_wal_checkpoint_v2
D
X
M
L
C
interface
runs
a
checkpoint
information
is
written
back
into
integers
pointed
to
by
L
and
C
dl
Checkpoint
as
many
frames
as
possible
without
waiting
for
any
database
in
the
log
were
checkpointed
The
busy
handler
callback
On
the
other
hand
passive
mode
might
leave
the
checkpoint
unfinished
dt
SQLITE_CHECKPOINT_FULL
dd
sqlite3_busy_handler
busy
handler
callback
until
there
is
no
snapshot
It
then
checkpoints
all
frames
in
the
log
file
and
syncs
the
but
new
database
readers
are
allowed
to
continue
unimpeded
dt
SQLITE_CHECKPOINT_RESTART
dd
that
after
checkpointing
the
log
file
it
blocks
calls
the
until
all
readers
are
reading
from
the
database
file
only
This
ensures
Like
SQLITE_CHECKPOINT_FULL
this
mode
blocks
new
dt
SQLITE_CHECKPOINT_TRUNCATE
dd
addition
that
it
also
truncates
the
log
file
to
zero
bytes
just
prior
l
If
pnLog
is
not
NULL
then
pnLog
is
set
to
the
total
number
of
frames
in
of
an
error
or
because
the
database
is
not
in
WAL
mode
If
pnCkpt
is
not
log
file
including
any
that
were
already
checkpointed
before
the
function
because
the
database
is
not
in
WAL
mode
Note
that
upon
successful
truncated
to
zero
bytes
and
so
both
pnLog
and
pnCkpt
will
be
set
to
zero
All
calls
obtain
an
exclusive
lock
on
the
database
file
If
lock
cannot
be
obtained
and
SQLITE_BUSY
is
returned
Even
if
there
is
a
The
SQLITE_CHECKPOINT_FULL
RESTART
and
TRUNCATE
modes
also
obtain
the
obtained
immediately
and
a
busy
handler
is
configured
it
is
invoked
and
is
successfully
obtained
The
busy
handler
is
also
invoked
while
waiting
for
the
writer
lock
is
obtained
or
while
waiting
for
database
readers
the
SQLITE_CHECKPOINT_PASSIVE
checkpointing
as
many
frames
as
possible
If
parameter
zDb
is
NULL
or
points
to
a
zero
length
string
then
the
database
connection
db
In
this
case
the
an
SQLITE_BUSY
error
is
encountered
when
processing
one
or
more
of
the
attached
databases
and
SQLITE_BUSY
is
returned
at
the
end
If
any
other
and
the
error
code
is
returned
to
the
caller
immediately
If
no
error
databases
SQLITE_OK
is
returned
If
database
zDb
is
the
name
of
an
attached
database
that
is
not
in
WAL
zDb
is
not
NULL
or
a
zero
length
string
and
is
not
the
name
of
any
Unless
it
returns
SQLITE_MISUSE
sets
the
error
information
that
is
queried
by
The
PRAGMA
wal_checkpoint
command
can
be
used
to
invoke
this
interface
int
sqlite3_wal_checkpoint_v2
sqlite3
db
const
char
zDb
int
eMode
int
pnLog
int
pnCkpt
CAPI3REF
Checkpoint
Mode
Values
These
constants
define
all
valid
values
for
the
passed
See
the
sqlite3_wal_checkpoint_v2
documentation
for
details
on
the
define
SQLITE_CHECKPOINT_PASSIVE
define
SQLITE_CHECKPOINT_FULL
define
SQLITE_CHECKPOINT_RESTART
define
SQLITE_CHECKPOINT_TRUNCATE
CAPI3REF
Virtual
Table
Interface
Configuration
This
function
may
be
called
by
either
the
xConnect
or
xCreate
method
various
facets
of
the
virtual
table
interface
If
this
interface
is
invoked
outside
the
context
of
an
xConnect
or
In
the
call
sqlite3_vtab_config
D
C
the
D
parameter
is
the
which
is
passed
in
as
the
first
argument
to
the
xConnect
or
xCreate
of
the
virtual
table
configuration
options
The
presence
and
meaning
is
used
int
sqlite3_vtab_config
sqlite3
int
op
CAPI3REF
Virtual
Table
Configuration
Options
KEYWORDS
virtual
table
configuration
option
These
macros
define
the
various
options
to
the
can
use
to
customize
and
optimize
their
behavior
dl
dt
SQLITE_VTAB_CONSTRAINT_SUPPORT
t
sqlite3_vtab_config
db
SQLITE_VTAB_CONSTRAINT_SUPPORT
X
are
supported
xCreate
or
xConnect
method
invoked
sqlite3_vtab_config
does
not
a
call
to
the
xUpdate
method
returns
SQLITE_CONSTRAINT
then
the
entire
specified
as
part
of
the
users
SQL
statement
regardless
of
the
actual
If
X
is
non
zero
then
the
virtual
table
implementation
guarantees
any
modifications
to
internal
or
persistent
data
structures
have
been
made
is
able
to
roll
back
a
statement
or
database
transaction
and
abandon
If
the
ON
CONFLICT
mode
is
REPLACE
and
the
xUpdate
method
returns
had
been
ABORT
Virtual
table
implementations
that
are
required
to
handle
OR
REPLACE
sqlite3_vtab_on_conflict
function
indicates
that
the
current
ON
silently
replace
the
appropriate
rows
within
the
xUpdate
callback
and
SQLITE_CONSTRAINT
in
which
case
SQLite
falls
back
to
OR
ABORT
d
SQLITE_VTAB_DIRECTONLY
dt
SQLITE_VTAB_DIRECTONLY
t
sqlite3_vtab_config
db
SQLITE_VTAB_DIRECTONLY
from
within
the
prohibits
that
virtual
table
from
being
used
from
within
triggers
and
d
SQLITE_VTAB_INNOCUOUS
dt
SQLITE_VTAB_INNOCUOUS
t
sqlite3_vtab_config
db
SQLITE_VTAB_INNOCUOUS
from
within
the
identify
that
virtual
table
as
being
safe
to
use
from
within
triggers
virtual
table
can
do
no
serious
harm
even
if
it
is
controlled
by
a
flag
unless
absolutely
necessary
l
define
SQLITE_VTAB_CONSTRAINT_SUPPORT
define
SQLITE_VTAB_INNOCUOUS
define
SQLITE_VTAB_DIRECTONLY
CAPI3REF
Determine
The
Virtual
Table
Conflict
Policy
This
function
may
only
be
called
from
within
a
call
to
the
xUpdate
method
value
returned
is
one
of
SQLITE_ROLLBACK
SQLITE_IGNORE
SQLITE_FAIL
of
the
SQL
statement
that
triggered
the
call
to
the
xUpdate
method
of
the
int
sqlite3_vtab_on_conflict
sqlite3
CAPI3REF
Determine
If
Virtual
Table
Column
Access
Is
For
UPDATE
If
the
sqlite3_vtab_nochange
X
routine
is
called
within
the
xColumn
column
is
being
fetched
as
part
of
an
UPDATE
operation
during
which
the
this
hint
as
permission
to
substitute
a
return
value
that
is
less
xUpdate
method
understands
as
a
value
If
the
xColumn
method
calls
sqlite3_vtab_nochange
and
finds
that
method
can
optionally
return
without
setting
a
result
without
calling
In
that
case
sqlite3_value_nochange
X
will
return
true
for
the
The
sqlite3_vtab_nochange
routine
is
an
optimization
Virtual
table
sqlite3_vtab_nochange
interface
were
to
always
return
false
In
the
returns
false
for
the
enhanced
UPDATE
FROM
statement
int
sqlite3_vtab_nochange
sqlite3_context
CAPI3REF
Determine
The
Collation
For
a
Virtual
Table
Constraint
This
function
may
only
be
called
from
within
a
call
to
the
xBestIndex
that
is
the
name
of
the
appropriate
collation
sequence
to
use
for
text
The
first
argument
must
be
the
pointer
to
the
sqlite3_index_info
object
must
be
an
index
into
the
aConstraint
array
belonging
to
the
Important
xBestMethod
method
The
first
parameter
may
not
be
a
pointer
to
a
The
return
value
is
computed
as
follows
ol
a
COLLATE
operator
then
the
name
of
the
collation
specified
by
li
p
If
there
is
no
COLLATE
operator
but
the
column
that
is
the
subject
a
COLLATE
clause
on
the
column
definition
within
the
CREATE
TABLE
name
of
that
alternative
collating
sequence
is
returned
l
SQLITE_EXPERIMENTAL
const
char
sqlite3_vtab_collation
sqlite3_index_info
int
CAPI3REF
Determine
if
a
virtual
table
query
is
DISTINCT
This
API
may
only
be
used
from
within
an
xBestIndex
xBestIndex
method
interface
from
outside
of
xBestIndex
is
undefined
and
probably
harmful
The
sqlite3_vtab_distinct
interface
returns
an
integer
between
and
gives
the
virtual
table
additional
information
about
how
the
query
can
meet
the
ordering
requirements
of
the
query
planner
it
may
set
ol
li
value
p
that
the
query
planner
needs
the
virtual
table
to
return
all
rows
in
the
sqlite3_index_info
object
This
is
the
default
expectation
If
the
the
xBestIndex
method
to
set
the
flag
regardless
of
li
value
p
that
the
query
planner
does
not
need
the
rows
to
be
returned
in
sorted
order
field
are
adjacent
This
mode
is
used
when
the
query
planner
li
value
p
that
the
query
planner
does
not
need
the
rows
returned
in
any
particular
are
adjacent
Furthermore
only
a
single
row
for
each
particular
needs
to
be
returned
It
is
always
ok
for
two
or
more
rows
with
the
same
are
adjacent
The
virtual
table
may
if
it
chooses
omit
extra
rows
However
omitting
the
extra
rows
is
optional
li
value
p
that
the
query
planner
needs
only
distinct
rows
but
it
does
need
the
rows
that
are
identical
in
all
aOrderBy
columns
if
it
wants
to
but
that
have
both
DISTINCT
and
ORDER
BY
clauses
For
the
purposes
of
comparing
virtual
table
output
values
to
see
if
the
to
be
the
same
In
other
words
the
comparison
operator
is
If
a
virtual
table
implementation
is
unable
to
meet
the
requirements
sqlite3_index_info
object
or
an
incorrect
answer
may
result
A
virtual
table
implementation
is
always
free
to
return
rows
in
any
order
the
flag
is
unset
the
query
planner
will
add
extra
ordered
correctly
The
use
of
the
flag
and
the
use
of
the
sqlite3_vtab_distinct
interface
and
the
overly
aggressive
and
setting
the
flag
when
it
is
not
results
int
sqlite3_vtab_distinct
sqlite3_index_info
CAPI3REF
Identify
and
handle
IN
constraints
in
xBestIndex
This
interface
may
only
be
used
from
within
an
The
result
of
invoking
this
interface
from
any
other
context
is
A
constraint
on
a
virtual
table
of
the
form
communicated
to
the
xBestIndex
method
as
a
this
constraint
it
must
set
the
corresponding
the
usual
mode
of
handling
IN
operators
SQLite
generates
bytecode
on
the
right
hand
side
of
the
IN
operator
Thus
the
virtual
table
at
a
time
In
some
cases
however
it
would
be
advantageous
for
the
virtual
once
The
sqlite3_vtab_in
interfaces
facilitates
this
in
two
ways
ol
A
call
to
sqlite3_vtab_in
P
N
will
return
true
non
zero
is
an
IN
operator
that
can
be
processed
all
at
once
In
other
words
by
which
the
virtual
table
can
ask
SQLite
if
all
at
once
processing
li
p
to
SQLite
that
the
virtual
table
does
or
does
not
want
to
process
parameter
F
is
non
negative
this
interface
is
the
mechanism
by
IN
operator
The
sqlite3_vtab_in
P
N
F
interface
can
be
invoked
multiple
times
the
return
value
from
sqlite3_vtab_in
P
N
F
will
always
be
the
same
non
zero
that
means
that
the
constraint
is
an
IN
operator
operator
or
cannot
be
processed
all
at
once
then
the
interface
returns
All
at
once
processing
of
the
IN
operator
is
selected
if
both
of
the
ol
integer
This
is
how
the
virtual
table
tells
SQLite
that
it
wants
to
li
p
The
last
call
to
sqlite3_vtab_in
P
N
F
for
which
F
was
l
If
either
or
both
of
the
conditions
above
are
false
then
SQLite
uses
If
both
conditions
are
true
then
the
argvIndex
th
parameter
to
the
but
which
can
be
passed
to
sqlite3_vtab_in_first
and
of
the
IN
constraint
int
sqlite3_vtab_in
sqlite3_index_info
int
iCons
int
bHandle
CAPI3REF
Find
all
elements
on
the
right
hand
side
of
an
IN
constraint
These
interfaces
are
only
useful
from
within
the
The
result
of
invoking
these
interfaces
from
any
other
context
The
X
parameter
in
a
call
to
sqlite3_vtab_in_first
X
P
or
xFilter
method
which
invokes
these
routines
and
specifically
processing
use
the
sqlite3_vtab_in
interface
in
the
an
xFilter
argument
that
was
selected
for
all
at
once
IN
constraint
exhibit
some
other
undefined
or
harmful
behavior
Use
these
routines
to
access
all
values
on
the
right
hand
side
blockquote
pre
nbsp
rc
SQLITE_OK
pVal
nbsp
nbsp
nbsp
nbsp
On
success
the
sqlite3_vtab_in_first
X
P
and
sqlite3_vtab_in_next
X
P
on
the
RHS
of
the
IN
constraint
If
there
are
no
more
values
on
the
routines
return
SQLITE_DONE
The
return
value
might
be
The
ppOut
values
returned
by
these
routines
are
only
valid
until
the
method
from
which
these
routines
were
called
If
the
virtual
table
copies
The
ppOut
values
are
protected
sqlite3_value
protected
int
sqlite3_vtab_in_first
sqlite3_value
pVal
sqlite3_value
ppOut
int
sqlite3_vtab_in_next
sqlite3_value
pVal
sqlite3_value
ppOut
CAPI3REF
Constraint
values
in
xBestIndex
This
API
may
only
be
used
from
within
the
xBestIndex
xBestIndex
method
from
outside
of
an
xBestIndex
method
are
undefined
and
probably
harmful
When
the
sqlite3_vtab_rhs_value
P
J
V
interface
is
invoked
from
within
a
copy
of
the
sqlite3_index_info
object
pointer
passed
into
xBestIndex
and
attempts
to
set
V
to
the
value
of
the
right
hand
operand
of
right
hand
operand
is
not
known
then
V
is
set
to
a
NULL
pointer
and
only
if
V
is
set
to
a
value
The
sqlite3_vtab_rhs_value
P
J
V
constraint
is
not
available
The
sqlite3_vtab_rhs_value
interface
something
goes
wrong
The
sqlite3_vtab_rhs_value
interface
is
usually
only
successful
if
SQL
statement
If
the
right
hand
operand
is
an
expression
or
a
reference
will
probably
return
SQLITE_NOTFOUND
Some
constraints
such
as
SQLITE_INDEX_CONSTRAINT_ISNULL
and
constraints
sqlite3_vtab_rhs_value
always
returns
SQLITE_NOTFOUND
The
sqlite3_value
object
returned
in
V
is
a
protected
sqlite3_value
When
xBestIndex
returns
the
sqlite3_value
object
returned
by
The
in
the
name
of
this
routine
is
an
abbreviation
for
int
sqlite3_vtab_rhs_value
sqlite3_index_info
int
sqlite3_value
ppVal
CAPI3REF
Conflict
resolution
modes
These
constants
are
returned
by
sqlite3_vtab_on_conflict
to
is
for
the
SQL
statement
being
evaluated
Note
that
the
SQLITE_IGNORE
constant
is
also
used
as
a
potential
SQLITE_ABORT
is
also
a
result
code
define
SQLITE_ROLLBACK
define
SQLITE_FAIL
define
SQLITE_REPLACE
CAPI3REF
Prepared
Statement
Scan
Status
Opcodes
The
following
constants
can
be
used
for
the
T
parameter
to
the
different
metric
for
sqlite3_stmt_scanstatus
to
return
When
the
value
returned
to
V
is
a
string
space
to
hold
that
string
is
S
is
finalized
dl
dd
The
sqlite3_int64
variable
pointed
to
by
the
V
parameter
will
be
SQLITE_SCANSTAT_NVISIT
dt
SQLITE_SCANSTAT_NVISIT
t
to
the
total
number
of
rows
examined
by
all
iterations
of
the
X
th
loop
d
SQLITE_SCANSTAT_EST
dt
SQLITE_SCANSTAT_EST
t
query
planner
s
estimate
for
the
average
number
of
rows
output
from
each
then
this
value
will
approximate
the
quotient
NVISIT
LOOP
and
the
be
the
NLOOP
value
for
the
current
loop
SQLITE_SCANSTAT_NAME
dt
SQLITE_SCANSTAT_NAME
t
to
a
zero
terminated
UTF
string
containing
the
name
of
the
index
or
table
SQLITE_SCANSTAT_EXPLAIN
dt
SQLITE_SCANSTAT_EXPLAIN
t
to
a
zero
terminated
UTF
string
containing
the
EXPLAIN
QUERY
PLAN
SQLITE_SCANSTAT_SELECTID
dt
SQLITE_SCANSTAT_SELECT
t
for
the
X
th
loop
The
select
id
identifies
which
query
or
The
select
id
is
the
same
value
as
is
output
in
the
first
column
l
define
SQLITE_SCANSTAT_NLOOP
define
SQLITE_SCANSTAT_NVISIT
define
SQLITE_SCANSTAT_EST
define
SQLITE_SCANSTAT_NAME
define
SQLITE_SCANSTAT_EXPLAIN
define
SQLITE_SCANSTAT_SELECTID
CAPI3REF
Prepared
Statement
Scan
Status
This
interface
returns
information
about
the
predicted
and
measured
interface
to
compare
the
predicted
and
the
measured
performance
and
Since
this
interface
is
expected
to
be
rarely
used
it
is
only
compile
time
option
The
parameter
determines
which
status
information
to
return
of
this
interface
is
undefined
the
parameter
Loops
are
numbered
starting
from
zero
If
idx
is
out
of
range
less
than
the
statement
a
non
zero
value
is
returned
and
the
variable
that
pOut
Statistics
might
not
be
available
for
all
loops
in
all
statements
In
cases
as
if
the
loop
did
not
exist
it
returns
non
zero
and
leave
the
variable
See
also
sqlite3_stmt_scanstatus_reset
int
sqlite3_stmt_scanstatus
sqlite3_stmt
pStmt
int
idx
int
iScanStatusOp
void
pOut
CAPI3REF
Zero
Scan
Status
Counters
Zero
all
sqlite3_stmt_scanstatus
related
event
counters
This
API
is
only
available
if
the
library
is
built
with
pre
processor
void
sqlite3_stmt_scanstatus_reset
sqlite3_stmt
CAPI3REF
Flush
caches
to
disk
mid
transaction
If
a
write
transaction
is
open
on
database
connection
D
when
the
pages
in
the
pager
cache
that
are
not
currently
in
use
are
written
out
active
SQL
statement
is
reading
from
it
or
if
it
is
page
of
a
database
interface
flushes
caches
for
all
schemas
and
If
this
function
needs
to
obtain
extra
database
locks
before
dirty
pages
immediately
and
there
is
a
busy
handler
callback
configured
it
is
invoked
the
database
is
skipped
and
an
attempt
made
to
flush
any
dirty
pages
because
locks
cannot
be
obtained
but
no
other
error
occurs
this
If
any
other
error
occurs
while
flushing
dirty
pages
to
disk
for
abandoned
and
an
SQLite
error
code
is
returned
to
the
caller
immediately
Otherwise
if
no
error
occurs
sqlite3_db_cacheflush
returns
SQLITE_OK
This
function
does
not
set
the
database
handle
error
code
or
message
int
sqlite3_db_cacheflush
sqlite3
CAPI3REF
The
pre
update
hook
These
interfaces
are
only
available
if
SQLite
is
compiled
using
the
The
sqlite3_preupdate_hook
interface
registers
a
callback
function
on
a
database
table
database
connection
each
call
to
sqlite3_preupdate_hook
overrides
The
preupdate
hook
is
disabled
by
invoking
sqlite3_preupdate_hook
The
third
parameter
to
sqlite3_preupdate_hook
is
passed
through
as
The
preupdate
hook
only
fires
for
changes
to
real
database
tables
the
system
tables
like
sqlite_sequence
or
sqlite_stat1
The
second
parameter
to
the
preupdate
callback
is
a
pointer
to
The
third
parameter
to
the
preupdate
callback
is
one
of
the
constants
kind
of
update
operation
that
is
about
to
occur
database
within
the
database
connection
that
is
being
modified
This
the
name
given
after
the
AS
keyword
in
the
ATTACH
statement
for
attached
The
fifth
parameter
to
the
preupdate
callback
is
the
name
of
the
For
an
UPDATE
or
DELETE
operation
on
a
rowid
table
the
sixth
row
being
modified
or
deleted
For
an
INSERT
operation
on
a
rowid
table
parameter
is
undefined
For
an
INSERT
or
UPDATE
on
a
rowid
table
the
or
updated
The
value
of
the
seventh
parameter
passed
to
the
callback
DELETE
operations
on
rowid
tables
The
sqlite3_preupdate_old
sqlite3_preupdate_new
provide
additional
information
about
a
preupdate
event
These
routines
these
routines
from
outside
of
a
preupdate
callback
or
with
a
to
the
preupdate
callback
results
in
undefined
and
probably
undesirable
The
sqlite3_preupdate_count
D
interface
returns
the
number
of
columns
The
sqlite3_preupdate_old
D
N
P
interface
writes
into
P
a
pointer
to
the
table
row
before
it
is
updated
The
N
parameter
must
be
between
undefined
This
must
only
be
used
within
SQLITE_UPDATE
and
SQLITE_DELETE
behavior
is
undefined
The
sqlite3_value
that
P
points
to
The
sqlite3_preupdate_new
D
N
P
interface
writes
into
P
a
pointer
to
the
table
row
after
it
is
updated
The
N
parameter
must
be
between
undefined
This
must
only
be
used
within
SQLITE_INSERT
and
SQLITE_UPDATE
behavior
is
undefined
The
sqlite3_value
that
P
points
to
The
sqlite3_preupdate_depth
D
interface
returns
if
the
preupdate
operation
or
for
inserts
updates
or
deletes
invoked
by
top
level
triggers
and
so
forth
When
the
sqlite3_blob_write
API
is
used
to
update
a
blob
column
in
this
case
the
new
values
are
not
available
In
this
case
when
a
sqlite3_blob_write
API
the
sqlite3_preupdate_blobwrite
returns
pre
update
hook
is
being
invoked
for
some
other
reason
including
a
See
also
sqlite3_update_hook
ifdef
SQLITE_ENABLE_PREUPDATE_HOOK
void
sqlite3_preupdate_hook
sqlite3
db
void
xPreUpdate
void
pCtx
sqlite3
db
int
op
char
const
zDb
char
const
zName
sqlite3_int64
iKey1
sqlite3_int64
iKey2
void
int
sqlite3_preupdate_old
sqlite3
int
sqlite3_value
int
sqlite3_preupdate_count
sqlite3
int
sqlite3_preupdate_depth
sqlite3
int
sqlite3_preupdate_new
sqlite3
int
sqlite3_value
int
sqlite3_preupdate_blobwrite
sqlite3
endif
CAPI3REF
Low
level
system
error
code
Attempt
to
return
the
underlying
operating
system
error
code
or
error
The
return
value
is
OS
dependent
For
example
on
unix
systems
after
called
to
get
back
the
underlying
that
caused
the
problem
such
int
sqlite3_system_errno
sqlite3
CAPI3REF
Database
Snapshot
An
instance
of
the
snapshot
object
records
the
state
of
a
WAL
mode
In
WAL
mode
multiple
database
connections
that
are
open
on
the
of
the
database
file
When
a
database
connection
begins
a
read
as
it
existed
for
the
point
in
time
when
the
transaction
first
started
by
the
reader
until
a
new
read
transaction
is
started
The
sqlite3_snapshot
object
records
state
information
about
an
historical
transaction
that
sees
that
historical
version
of
the
database
rather
than
typedef
struct
sqlite3_snapshot
unsigned
char
hidden
sqlite3_snapshot
CAPI3REF
Record
A
Database
Snapshot
The
sqlite3_snapshot_get
D
S
P
interface
attempts
to
make
a
schema
S
in
database
connection
D
On
success
the
created
sqlite3_snapshot
object
into
P
and
returns
SQLITE_OK
this
function
is
called
one
is
opened
automatically
The
following
must
be
true
for
this
function
to
succeed
If
any
of
called
SQLITE_ERROR
is
returned
The
final
value
of
P
is
undefined
ul
li
Schema
S
of
database
connection
D
must
be
a
WAL
mode
database
li
There
must
not
be
a
write
transaction
open
on
schema
S
of
database
li
One
or
more
transactions
must
have
been
written
to
the
current
wal
that
a
snapshot
cannot
be
taken
on
a
wal
mode
database
with
no
wal
must
be
written
to
it
first
This
function
may
also
return
SQLITE_NOMEM
If
it
is
called
with
the
whether
or
not
a
read
transaction
is
opened
on
schema
S
is
undefined
The
sqlite3_snapshot
object
returned
from
a
successful
call
to
to
avoid
a
memory
leak
The
sqlite3_snapshot_get
interface
is
only
available
when
the
SQLITE_EXPERIMENTAL
int
sqlite3_snapshot_get
sqlite3
db
const
char
zSchema
sqlite3_snapshot
ppSnapshot
CAPI3REF
Start
a
read
transaction
on
an
historical
snapshot
The
sqlite3_snapshot_open
D
S
P
interface
either
starts
a
new
read
database
connection
D
such
that
the
read
transaction
refers
to
database
The
sqlite3_snapshot_open
interface
returns
SQLITE_OK
In
order
to
succeed
the
database
connection
must
not
be
in
is
already
a
read
transaction
open
on
schema
S
then
the
database
handle
to
sqlite3_step
but
not
sqlite3_reset
or
sqlite3_finalize
if
schema
S
does
not
exist
or
if
the
snapshot
object
is
invalid
A
call
to
sqlite3_snapshot_open
will
fail
to
open
if
the
specified
SQLITE_ERROR_SNAPSHOT
is
returned
If
there
is
already
a
read
transaction
open
when
this
function
is
database
snapshot
if
SQLITE_ERROR
SQLITE_BUSY
or
SQLITE_ERROR_SNAPSHOT
SQLITE_IOERR
error
code
is
returned
then
the
final
state
of
the
read
transaction
is
now
open
on
database
snapshot
P
A
call
to
sqlite3_snapshot_open
D
S
P
will
fail
if
the
schema
S
is
in
WAL
mode
A
database
connection
might
not
know
I
on
that
database
connection
or
if
the
database
entered
WAL
mode
Hint
Run
against
a
newly
opened
The
sqlite3_snapshot_open
interface
is
only
available
when
the
SQLITE_EXPERIMENTAL
int
sqlite3_snapshot_open
sqlite3
db
const
char
zSchema
sqlite3_snapshot
pSnapshot
CAPI3REF
Destroy
a
snapshot
The
sqlite3_snapshot_free
P
interface
destroys
sqlite3_snapshot
P
using
this
routine
to
avoid
a
memory
leak
The
sqlite3_snapshot_free
interface
is
only
available
when
the
SQLITE_EXPERIMENTAL
void
sqlite3_snapshot_free
sqlite3_snapshot
CAPI3REF
Compare
the
ages
of
two
snapshot
handles
The
sqlite3_snapshot_cmp
P1
P2
interface
is
used
to
compare
the
ages
If
the
two
snapshot
handles
are
not
associated
with
the
same
database
Additionally
the
result
of
the
comparison
is
only
valid
if
both
of
the
last
time
the
wal
file
was
deleted
The
wal
file
is
deleted
when
the
clients
drops
to
zero
If
either
snapshot
handle
was
obtained
before
the
is
undefined
Otherwise
this
API
returns
a
negative
value
if
P1
refers
to
an
older
snapshot
and
a
positive
value
if
P1
is
a
newer
snapshot
than
P2
This
interface
is
only
available
if
SQLite
is
compiled
with
the
SQLITE_EXPERIMENTAL
int
sqlite3_snapshot_cmp
sqlite3_snapshot
p1
sqlite3_snapshot
p2
CAPI3REF
Recover
snapshots
from
a
wal
file
If
a
WAL
file
remains
on
disk
after
all
database
connections
close
or
because
the
last
process
to
have
the
database
opened
exited
without
on
that
database
and
WAL
file
the
sqlite3_snapshot_open
interface
even
though
the
WAL
file
contains
other
valid
transactions
This
function
attempts
to
scan
the
WAL
file
associated
with
database
zDb
sqlite3_snapshot_open
It
is
an
error
if
there
is
already
a
read
database
SQLITE_OK
is
returned
if
successful
or
an
SQLite
error
code
otherwise
This
interface
is
only
available
if
SQLite
is
compiled
with
the
SQLITE_EXPERIMENTAL
int
sqlite3_snapshot_recover
sqlite3
db
const
char
zDb
CAPI3REF
Serialize
a
database
The
sqlite3_serialize
D
S
P
F
interface
returns
a
pointer
to
memory
If
P
is
not
a
NULL
pointer
then
the
size
of
the
database
in
bytes
For
an
ordinary
on
disk
database
file
the
serialization
is
just
a
the
serialization
is
the
same
sequence
of
bytes
which
would
be
written
The
usual
case
is
that
sqlite3_serialize
copies
the
serialization
of
a
pointer
to
that
memory
The
caller
is
responsible
for
freeing
the
contains
the
SQLITE_SERIALIZE_NOCOPY
bit
then
no
memory
allocations
to
the
contiguous
memory
representation
of
the
database
that
SQLite
memory
representation
of
the
database
exists
A
contiguous
memory
been
a
prior
call
to
sqlite3_deserialize
D
S
with
the
same
The
size
of
the
database
is
written
into
P
even
if
the
of
the
database
exists
A
call
to
sqlite3_serialize
D
S
P
F
might
return
NULL
even
if
the
allocation
error
occurs
This
interface
is
omitted
if
SQLite
is
compiled
with
the
unsigned
char
sqlite3_serialize
sqlite3
db
const
char
zSchema
sqlite3_int64
piSize
unsigned
int
mFlags
CAPI3REF
Flags
for
sqlite3_serialize
Zero
or
more
of
the
following
constants
can
be
OR
ed
together
for
SQLITE_SERIALIZE_NOCOPY
means
that
sqlite3_serialize
will
return
without
making
a
copy
of
the
database
If
SQLite
is
not
currently
using
sqlite3_serialize
to
return
a
NULL
pointer
SQLite
will
only
be
prior
call
to
sqlite3_deserialize
define
SQLITE_SERIALIZE_NOCOPY
x001
CAPI3REF
Deserialize
a
database
The
sqlite3_deserialize
D
S
P
N
M
F
interface
causes
the
reopen
S
as
an
in
memory
database
based
on
the
serialization
contained
the
buffer
P
which
might
be
larger
than
N
If
M
is
larger
than
N
and
permitted
to
add
content
to
the
in
memory
database
as
long
as
the
total
If
the
SQLITE_DESERIALIZE_FREEONCLOSE
bit
is
set
in
F
then
SQLite
will
connection
closes
If
the
SQLITE_DESERIALIZE_RESIZEABLE
bit
is
set
then
if
writes
on
the
database
cause
it
to
grow
larger
than
M
bytes
The
sqlite3_deserialize
interface
will
fail
with
SQLITE_BUSY
if
the
operation
It
is
not
possible
to
deserialized
into
the
TEMP
database
If
the
function
returns
SQLITE_ERROR
If
sqlite3_deserialize
D
S
P
N
M
F
fails
for
any
reason
and
if
the
sqlite3_free
is
invoked
on
argument
P
prior
to
returning
This
interface
is
omitted
if
SQLite
is
compiled
with
the
int
sqlite3_deserialize
sqlite3
db
const
char
zSchema
unsigned
char
pData
sqlite3_int64
szDb
sqlite3_int64
szBuf
unsigned
mFlags
CAPI3REF
Flags
for
sqlite3_deserialize
The
following
are
allowed
values
for
th
argument
the
F
argument
to
The
SQLITE_DESERIALIZE_FREEONCLOSE
means
that
the
database
serialization
and
that
SQLite
should
take
ownership
of
this
memory
and
automatically
is
responsible
for
freeing
any
dynamically
allocated
memory
The
SQLITE_DESERIALIZE_RESIZEABLE
flag
means
that
SQLite
is
allowed
to
flag
should
only
be
used
if
SQLITE_DESERIALIZE_FREEONCLOSE
is
also
used
the
number
of
bytes
specified
by
the
M
parameter
The
SQLITE_DESERIALIZE_READONLY
flag
means
that
the
deserialized
database
define
SQLITE_DESERIALIZE_FREEONCLOSE
define
SQLITE_DESERIALIZE_RESIZEABLE
define
SQLITE_DESERIALIZE_READONLY
Undo
the
hack
that
converts
floating
point
types
to
integer
for
ifdef
SQLITE_OMIT_FLOATING_POINT
undef
double
endif
ifdef
__cplusplus
endif
endif
