Overview of the compiler pipeline:

1. Preparation
 1.1. Map source code character set to UTF-8.
 1.2. Replace "\r\n", "\n\r" to "\n".
 1.3. Insert "\n" at end of file if it doesn't exist.
2. Preprocessor
 2.0. Replace trigraphs by their equivalent character, if any.
 2.1. Skip line continuation, if any.
 2.2. Run lexer and return `pp_token_t`.
 2.3. Handle preprocessor directives.
 2.4. Expand macros (Tricky but fun).
 2.5. Convert escape character sequence in char constant and string literal.
 2.6. Merge adjacent string literals.
 2.7. Convert `pp_token` to `token_t`.
 2.8. Keep scan the file until EOF.
 2.9. When all files are preprocessed, it returns a list of `token_t`s.
3. Parser
 The most boring phase.
 Statements and declarations parsed by Recursive descent parser, and expression 
 by Pratt parser.
 When done, it returns AST.
4. Semantic analysis
 I made it separate because semantic analysis for C is tricky and if UB exists,
 it will messed up the next phase, including the result of generated assembly.
 When done, it returns another intermediate representation (IR).

From this, everything is extremely fun and never made me bored unlike when
writing parser and semantic analysis.

5. Optimization
 5.1. Construct Control-flow Graph and SSA.
  5.1.1. Compute dominance frontiers.
  5.1.2. Insert Phi.
 5.m. Run instruction selection.
 5.n. Run register allocation.
 5.o. Run peephole (Easy, e.g. `mov eax, 1` to `xor eax, eax`).
6. Code generation
 It just output `.s` file then fork() + exec() the assembler and the linker.

